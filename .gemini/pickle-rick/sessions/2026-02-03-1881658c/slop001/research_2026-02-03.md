# Research: Global Codebase Audit & Optimization (Slop Purge)

**Date**: 2026-02-03

## 1. Executive Summary
The `bsopt` codebase is a mix of high-performance JIT-optimized kernels and "Jerry-grade" boilerplate. Major bottlenecks identified in the ML pipeline (`iterrows`) and pricing services (manual loops). Authentication is tightly coupled to Keycloak, and the RL agent lacks temporal awareness.

## 2. Technical Context
- **Pricing Core**: `src/pricing/black_scholes.py` uses Numba JIT (good), but `src/services/pricing_service.py` performs manual orchestration loops (L32, L187, L217) which could be vectorized.
- **ML Pipeline**: `src/ml/autonomous_pipeline.py:356` uses `df.iterrows()`, a major performance anti-pattern.
- **Security**: `src/auth/security.py` is hardcoded to Keycloak endpoints, preventing multi-provider support.
- **RL Environment**: `src/ml/reinforcement_learning/trading_env.py` returns a flat 100-dim observation without history, limiting the agent to Markovian states.

## 3. Findings & Analysis
- **Vectorization Opportunities**: Many services use `for i in range(n)` to process options sequentially. These should be moved to NumPy vectorized operations or pre-allocated shared memory buffers.
- **Memory Management**: `src/utils/shared_memory.py` exists but is underutilized in the main pricing path.
- **Data Flow**: Market data is parsed and re-parsed multiple times across `src/ml/scraper.py` and `src/ml/data_loader.py`.

## 4. Technical Constraints
- **Library Versioning**: `numpy` versioning in `requirements.txt` is inconsistent (`>=1.26.0,<2.3` and `>=1.26.4`).
- **Dependency Bloat**: Multiple competing JWT libraries (`python-jose` and `PyJWT`).

## 5. Architecture Documentation
- **Current Pattern**: Heavy reliance on `stable-baselines3` for RL and `FastAPI` for the API layer.
- **Concurrency**: Mix of `asyncio`, `celery`, and `ray`. Coordination overhead is visible in `src/api/main.py` lifespan events.
