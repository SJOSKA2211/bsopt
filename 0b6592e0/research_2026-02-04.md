# Research: Investigate & Resolve Critical Backend API Failures

**Date**: 2026-02-04

## 1. Executive Summary
This research investigates potential causes and manifestation points for "Critical Backend API Failures" within the application. Analysis focused on core API components (`src/api/main.py`), authentication (`src/auth/service.py`), database interaction (`src/database/__init__.py`), and a representative business logic route (`src/api/routes/pricing.py` and `src/services/pricing_service.py`). Numerous critical failure points were identified, primarily stemming from configuration dependencies, generic error handling, and concurrency management within batch processing.

## 2. Technical Context

### 2.1. API Entry Point (`src/api/main.py`)
- **Initialization**: FastAPI app setup, including middleware for CORS, Brotli compression, and custom logging.
- **Global Exception Handler (`api_exception_handler`)**: `src/api/main.py:L53-L58` catches all `Exception` types, logs a generic error, and returns a 500 status. While preventing uncaught exceptions, it abstracts away critical detail for specific debugging, re-raising a generic `ValueError` for authentication issues.
- **Authentication Dependency (`verify_token`)**: `src/api/main.py:L69-L81` depends on `AuthService` for token validation.
- **Router Inclusion**: `auth_router`, `pricing_router` (public/self-authenticating), `ml_router` (protected by `verify_token`).

### 2.2. Authentication Service (`src/auth/service.py`)
- **`AuthService` Class**: Manages client verification, token creation, and token validation.
- **Token Validation (`validate_token`)**: `src/auth/service.py:L46-L50` uses `jwt.decode` and `payload.validate()`. It catches a generic `Exception` and raises `ValueError("Invalid or expired token")`, obscuring specific validation failure reasons.
- **Token Creation (`create_token`)**: `src/auth/service.py:L26-L34` uses `settings.rsa_private_key` for JWT signing and `settings.ACCESS_TOKEN_EXPIRE_MINUTES` for token expiry.

### 2.3. Database Session Management (`src/database/__init__.py`)
- **Configuration**: Uses `settings.DATABASE_URL`. Forces `sslmode=require` for Neon.
- **Connection Pooling**: `NullPool` in production (`src/database/__init__.py:L9`, `L23`) for serverless environments; `QueuePool` in development.
- **Asynchronous Engine**: `create_async_engine` with specific SSL handling (`src/database/__init__.py:L36-L40`).
- **Session Providers**: `get_db` (sync Generator) and `get_async_db` (async AsyncGenerator).

### 2.4. Pricing Route & Service (`src/api/routes/pricing.py` & `src/services/pricing_service.py`)
- **Route Definitions**: `src/api/routes/pricing.py` defines `/price`, `/batch`, `/greeks` endpoints. These are public (no `verify_token` dependency).
- **`PricingService` Instantiation**: `src/api/routes/pricing.py:L17` instantiates `PricingService` globally at module level, making it a singleton.
- **`PricingEngineFactory`**: `src/services/pricing_service.py:L20`, `L54` used to select pricing engines (e.g., "black_scholes").
- **CPU-bound Offloading**: `anyio.to_thread.run_sync` (`src/services/pricing_service.py:L27`, `L56`) offloads synchronous pricing calculations to a thread pool.
- **Batch Processing**: `price_batch` uses `asyncio.gather` (`src/services/pricing_service.py:L38-L45`) for concurrent processing of multiple options.

## 3. Findings & Analysis

### 3.1. Generic Exception Handling in `main.py` and `auth/service.py`
- The global `api_exception_handler` (`src/api/main.py:L53`) logs a generic error string (`str(exc)`) and returns a non-specific 500 error. This makes it difficult to ascertain the exact nature of an API failure without deep log diving or reproducing the error.
- Similarly, `AuthService.validate_token` (`src/auth/service.py:L46`) catches all exceptions and transforms them into a generic `ValueError`. This obfuscates the specific reason for token invalidation (e.g., malformed header, expired token, invalid signature), hindering rapid diagnosis of authentication-related API failures.

### 3.2. Configuration-Dependent Failures
- **`DATABASE_URL` and SSL**: Misconfiguration of `settings.DATABASE_URL` (`src/database/__init__.py:L13`) or issues with SSL/TLS (forced `sslmode=require` for Neon) would prevent database connections, leading to cascading failures across any API endpoint requiring database access.
- **JWT Key Management**: Errors in `settings.rsa_private_key` or `settings.ACCESS_TOKEN_EXPIRE_MINUTES` (`src/auth/service.py:L33`, `L26`) could lead to authentication failures, either by preventing token creation or causing tokens to expire prematurely.

### 3.3. Concurrency and Batch Processing Fragility
- **`NullPool` in Production**: While appropriate for serverless, `NullPool` (`src/database/__init__.py:L9`) can introduce latency under consistent load due to frequent connection establishment, potentially causing API timeouts or performance degradation, leading to "soft" API failures.
- **`asyncio.gather` in `price_batch`**: The current implementation of `price_batch` (`src/services/pricing_service.py:L38`) will fail the *entire batch* if even one `price_option` task raises an exception. This means a single malformed option request within a batch could lead to a critical API failure for the whole `/batch` endpoint, preventing any results from being returned. This is a significant fragility point.

### 3.4. `PricingService` Dependency Opacity
- The global instantiation of `PricingService` (`src/api/routes/pricing.py:L17`) means its dependencies (e.g., `PricingEngineFactory`) are managed internally, not explicitly injected at the route level. This can make it harder to trace the source of failures if `PricingEngineFactory.get_engine` (`src/services/pricing_service.py:L20`) returns a flawed engine or fails to instantiate one for an invalid `model` parameter.

### 3.5. Uncaught Exceptions in `run_sync` Context
- While `anyio.to_thread.run_sync` (`src/services/pricing_service.py:L27`) is a good pattern for async/sync interop, any unhandled exception *within* the synchronous `engine.price` or `engine.calculate_greeks` call will propagate and eventually hit the global `api_exception_handler`. Without more granular error handling within `PricingService` itself, specific pricing calculation issues are generalized.

## 4. Technical Constraints
- The current error handling philosophy tends towards broad exception catching and generic error messages.
- Database connection pooling strategy is environment-dependent (`NullPool` in prod).
- Heavy reliance on `settings` for critical parameters (`DATABASE_URL`, JWT keys).
- Batch processing design (using `asyncio.gather`) is not fault-tolerant at the individual item level.

## 5. Architecture Documentation
- The API uses FastAPI for routing and dependency injection (though not consistently applied to all services like `PricingService`).
- Authentication uses JWTs signed with RSA keys, validated by `AuthService`.
- Database access uses SQLAlchemy, with distinct synchronous and asynchronous engines/sessions.
- Pricing logic is encapsulated in `PricingService`, leveraging a `PricingEngineFactory` and offloading CPU-bound tasks to a thread pool.
- Global exception handling is in place, but highly generic.
