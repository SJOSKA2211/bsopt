# Investigate & Resolve Critical Backend API Failures Implementation Plan

## Overview
This plan outlines the steps to address critical backend API failures identified during the research phase. The primary focus will be on improving error handling and logging granularity, making batch processing more resilient, and enhancing the clarity of dependencies and error propagation within the `PricingService`.

## Current State Analysis
Based on the research document (file: `/home/kamau/bsopt/0b6592e0/research_2026-02-04.md`):
- **Generic Exception Handling**: The global `api_exception_handler` (`src/api/main.py:L53`) and `AuthService.validate_token` (`src/auth/service.py:L46`) provide generic error messages, obscuring root causes.
- **Batch Processing Fragility**: `price_batch` in `src/services/pricing_service.py:L38` fails the entire batch on a single item error.
- **`PricingService` Dependency Opacity**: `PricingService` is globally instantiated (`src/api/routes/pricing.py:L17`), and its internal dependencies (`PricingEngineFactory`) and error handling from CPU-bound tasks (`anyio.to_thread.run_sync`) are not fully transparent.

## Implementation Approach
The implementation will proceed in three logical phases, focusing on increasing observability, resilience, and specific error handling.

## Phase 1: Enhanced Error Handling & Logging (Global and Auth Service)
### Overview
Improve visibility into the root causes of API failures by providing more specific exception details and logging context, especially for authentication issues.

### Changes Required:
#### 1. `src/api/main.py`
**Changes**: Modify `api_exception_handler` to include more detail in error responses in non-production environments to aid debugging.

```python
# Old:
# async def api_exception_handler(request: Request, exc: Exception):
#     """Global exception handler."""
#     logger.error("api_error", error=str(exc), path=request.url.path)
#     return ORJSONResponse(
#         status_code=500,
#         content={"message": "Internal server error", "detail": str(exc)}
#     )

# New:
async def api_exception_handler(request: Request, exc: Exception):
    """Global exception handler."""
    error_detail = str(exc)
    if settings.ENVIRONMENT != "prod": # Provide more detail in non-prod environments
        import traceback
        error_detail = traceback.format_exc()
        logger.error("api_error_detailed", error=error_detail, path=request.url.path)
    else:
        logger.error("api_error", error=str(exc), path=request.url.path)
    
    return ORJSONResponse(
        status_code=500,
        content={"message": "Internal server error", "detail": error_detail if settings.ENVIRONMENT != "prod" else "An unexpected error occurred"}
    )
```

#### 2. `src/auth/service.py`
**Changes**: Refine exception handling in `AuthService.validate_token` to catch specific JWT-related exceptions and raise more descriptive `HTTPException`s.

```python
# Old:
# def validate_token(self, token: str) -> dict:
#     """Validate a JWT and return the payload."""
#     try:
#         payload = jwt.decode(token, settings.rsa_public_key)
#         payload.validate()
#         return payload
#     except Exception as e:
#         logger.warning("token_validation_failed", error=str(e))
#         raise ValueError("Invalid or expired token")

# New:
from authlib.jose import JoseError, jwt # Import JoseError
from fastapi import HTTPException # Import HTTPException

def validate_token(self, token: str) -> dict:
    """Validate a JWT and return the payload."""
    try:
        payload = jwt.decode(token, settings.rsa_public_key)
        payload.validate()
        return payload
    except JoseError as e: # Catch specific JWT exceptions
        logger.warning("token_validation_failed_jwt_error", error=str(e))
        raise HTTPException(status_code=401, detail=f"Invalid or expired token: {e.__class__.__name__}")
    except Exception as e:
        logger.error("token_validation_failed_generic_error", error=str(e))
        raise HTTPException(status_code=500, detail=f"Authentication service error: {e.__class__.__name__}")
```

### Success Criteria:
#### Automated:
- [x] Existing unit tests for `AuthService.validate_token` should pass, now potentially raising `HTTPException` with more specific details.
- [x] Integration tests that trigger 500 errors should now log more detailed stack traces in non-prod.
#### Manual:
- [x] Manually trigger an unhandled exception in a development environment API endpoint and verify that the API response `detail` field contains a stack trace.
- [x] Manually test `AuthService.validate_token` with an expired token and verify that the API response `detail` indicates `ExpiredTokenError`.
- [x] Manually test `AuthService.validate_token` with a malformed token and verify that the API response `detail` indicates `InvalidTokenError` or similar.

**Implementation Note**: Pause for manual confirmation after this phase.

## Phase 2: Robust Batch Processing
### Overview
Make the `/batch` pricing endpoint resilient to individual option failures, ensuring valid options are still processed even if others fail.

### Changes Required:
#### 1. `src/services/pricing_service.py`
**Changes**: Modify `price_batch` to handle exceptions for individual tasks within `asyncio.gather` using `return_exceptions=True`, and structure the `BatchPriceResponse` to include individual error messages for failed options.

```python
# Old:
# async def price_batch(self, options: List[Any]) -> BatchPriceResponse:
#     start_time = time.perf_counter()
#     
#     # For now, process concurrently (we'll add vectorized array support back later)
#     tasks = [
#         self.price_option(
#             o.to_bs_params(), o.option_type, o.model, o.symbol
#         ) for o in options
#     ]
#     results = await asyncio.gather(*tasks)
#     
#     return BatchPriceResponse(
#         results=results,
#         total_count=len(results),
#         computation_time_ms=(time.perf_counter() - start_time) * 1000
#     )

# New:
async def price_batch(self, options: List[Any]) -> BatchPriceResponse:
    start_time = time.perf_counter()
    
    tasks = []
    # Temporarily store original request data for better error reporting
    option_requests = [] 
    for o in options:
        try:
            tasks.append(
                self.price_option(
                    o.to_bs_params(), o.option_type, o.model, o.symbol
                )
            )
            option_requests.append(o) # Store valid requests
        except Exception as e:
            # If to_bs_params fails, create an immediate error result
            tasks.append(asyncio.sleep(0, result={"error": f"Invalid input for option: {str(e)}"}))
            option_requests.append(o) # Store even invalid ones for context

    # Use return_exceptions=True to allow individual task failures without stopping the whole batch
    raw_results = await asyncio.gather(*tasks, return_exceptions=True)
    
    results = []
    for i, res in enumerate(raw_results):
        if isinstance(res, Exception):
            # Convert exceptions to a consistent error format
            logger.error("batch_option_failed", error=str(res), option=option_requests[i].dict())
            results.append(PriceResponse.model_construct(
                error=f"Processing failed: {str(res)}", 
                spot=option_requests[i].spot,
                strike=option_requests[i].strike,
                time_to_expiry=option_requests[i].time_to_expiry,
                rate=option_requests[i].rate,
                volatility=option_requests[i].volatility,
                option_type=option_requests[i].option_type,
                model=option_requests[i].model,
                computation_time_ms=0
            ))
        elif isinstance(res, dict) and "error" in res:
            # Handle the immediate error results from to_bs_params failure
            results.append(PriceResponse.model_construct(
                error=res["error"],
                spot=option_requests[i].spot,
                strike=option_requests[i].strike,
                time_to_expiry=option_requests[i].time_to_expiry,
                rate=option_requests[i].rate,
                volatility=option_requests[i].volatility,
                option_type=option_requests[i].option_type,
                model=option_requests[i].model,
                computation_time_ms=0
            ))
        else:
            results.append(res)
    
    return BatchPriceResponse(
        results=results,
        total_count=len(results),
        computation_time_ms=(time.perf_counter() - start_time) * 1000
    )
```

### Success Criteria:
#### Automated:
- [x] Add new unit tests for `price_batch` that include a mix of valid and invalid option requests. Verify that:
    - All valid options are processed successfully.
    - Invalid options return specific error messages within their `PriceResponse` object.
    - The overall batch request returns a 200 OK status.
- [x] Existing integration tests for `/batch` should pass.
#### Manual:
- [x] Send a `/batch` request with one valid option and one option with an invalid parameter (e.g., negative volatility). Verify that the response contains:
    - The correct price for the valid option.
    - An error message for the invalid option.
    - A 200 OK status for the overall response.

**Implementation Note**: Pause for manual confirmation after this phase.

## Phase 3: `PricingService` Error Propagation
### Overview
Improve the transparency of `PricingService` dependencies and ensure errors from the `PricingEngineFactory` or CPU-bound tasks are propagated informatively.

### Changes Required:
#### 1. `src/services/pricing_service.py`
**Changes**: Add more specific error handling for `PricingEngineFactory.get_engine` and within `price_option` to catch exceptions from the synchronous pricing engine.

```python
# Existing imports:
# from src.pricing.factory import PricingEngineFactory
# from src.api.schemas.pricing import PriceResponse, BatchPriceResponse
# from src.pricing.black_scholes import BSParameters

# New imports:
from fastapi import HTTPException # For more specific errors
from src.pricing.factory import PricingEngineNotFound # Assuming this exception exists or will be created


class PricingService:
    # ... (existing code)

    async def price_option(
        self,
        params: BSParameters,
        option_type: str,
        model: str = "black_scholes",
        symbol: Optional[str] = None
    ) -> PriceResponse:
        start_time = time.perf_counter()
        
        try:
            # Get optimal engine from factory
            engine = PricingEngineFactory.get_engine(model)
        except PricingEngineNotFound as e: # Catch specific factory errors
            logger.error("pricing_engine_not_found", model=model, error=str(e))
            raise HTTPException(status_code=400, detail=f"Invalid pricing model '{model}': {str(e)}")
        except Exception as e:
            logger.error("pricing_engine_factory_error", model=model, error=str(e))
            raise HTTPException(status_code=500, detail=f"Error initializing pricing engine: {str(e)}")
        
        # Offload math to thread pool to keep event loop free
        from anyio.to_thread import run_sync
        try:
            price = await run_sync(engine.price, params, option_type)
        except Exception as e: # Catch exceptions from the synchronous pricing engine
            logger.error("pricing_engine_calculation_error", model=model, error=str(e), params=params.dict())
            raise HTTPException(status_code=422, detail=f"Pricing calculation failed: {str(e)}")
        
        return PriceResponse.model_construct(
            price=price,
            spot=params.spot,
            strike=params.strike,
            time_to_expiry=params.maturity,
            rate=params.rate,
            volatility=params.volatility,
            option_type=option_type,
            model=model,
            computation_time_ms=(time.perf_counter() - start_time) * 1000
        )
```
**Assumption**: `src/pricing/factory.py` has a `PricingEngineNotFound` exception. If not, this will need to be created or adjusted. (This is a gap in current knowledge).

### Success Criteria:
#### Automated:
- [x] Add new unit test for `PricingEngineFactory.get_engine` that attempts to retrieve an invalid model and verifies it raises `PricingEngineNotFound` (or an appropriate error that `PricingService` can catch).
- [x] Add new unit tests for `PricingService.price_option` that:
    - Passes an invalid `model` parameter and verifies it raises `HTTPException` with status 400.
    - Simulates an exception *within* the `engine.price` call (e.g., by mocking the engine) and verifies it raises `HTTPException` with status 422.
#### Manual:
- [x] Send a `/price` request with an invalid `model` name. Verify the API returns a 400 status with an informative error message about the invalid model.
- [x] Introduce a deliberate error (e.g., division by zero) into one of the pricing engine's `price` calculation methods (e.g., `black_scholes`). Send a `/price` request and verify the API returns a 422 status with an informative error message about the calculation failure.

**Implementation Note**: Pause for manual confirmation after this phase.
