# Research: Diagnose & Fix Runtime Errors

**Date**: 2026-02-04

## 1. Executive Summary
This research identifies common and critical sources of runtime errors across the application, spanning configuration, API handling, authentication, database interaction, CLI operations, machine learning training, shared memory management, RL environment simulation, and real-time data streaming. The goal is to provide a comprehensive map of where runtime errors originate and how they manifest, laying the groundwork for systematic diagnosis and robust error handling improvements.

## 2. Technical Context

### 2.1. Configuration (`src/config.py`)
- **Environment Settings**: `ENVIRONMENT` and `DEBUG` flags (`src/config.py:L14`, `L15`) control application behavior, logging verbosity, and key generation.
- **`DATABASE_URL` Validation**: `src/config.py:L21-L26` validates database connection string format.
- **JWT Key Management**: `rsa_private_key`, `rsa_public_key` properties (`src/config.py:L60-L98`) handle JWT signing keys, with transient key generation in non-prod.
- **`.env` Loading**: `pydantic_settings` loads configurations from `.env` file (`src/config.py:L107`).

### 2.2. API Entry Point (`src/api/main.py`)
- **Global Exception Handler**: `src/api/main.py:L53-L58` (modified in previous ticket) catches all `Exception` types, logging errors and returning a 500 status. Now provides more detail in non-prod.
- **Authentication Dependency (`verify_token`)**: `src/api/main.py:L69-L81` relies on `AuthService` for token validation.

### 2.3. Authentication Service (`src/auth/service.py`)
- **Token Validation (`validate_token`)**: `src/auth/service.py:L46-L50` (modified in previous ticket) now specifically catches `JoseError` and other `Exception`s, raising `HTTPException`s.

### 2.4. Database Session Management (`src/database/__init__.py`)
- **Configuration**: Uses `settings.DATABASE_URL`. Forces `sslmode=require` for Neon.
- **Connection Pooling**: `NullPool` in production, `QueuePool` in development (`src/database/__init__.py:L9`).
- **Session Providers**: `get_db` (sync Generator) and `get_async_db` (async AsyncGenerator).

### 2.5. CLI Entry Point (`bs_cli.py`)
- **Venv Enforcement**: `scripts.enforce_venv.check_venv()` (`bs_cli.py:L14`) ensures virtual environment usage.
- **Asyncio in CLI**: `asyncio.run()` (`bs_cli.py:L51`) used to execute async `PricingService` calls.
- **ML Training Command**: `train_transformer` command (`bs_cli.py:L71`) calls `src.ml.reinforcement_learning.train.train_td3`.
- **Shared Memory Status**: `mesh_status` command (`bs_cli.py:L89`) uses `src.shared.shm_manager.SHMManager`.

### 2.6. ML Training (`src/ml/reinforcement_learning/train.py`)
- **Dependencies**: Imports numerous external and internal libraries.
- **`SHMWeightSyncCallback`**: Uses `SHMManager` for shared memory weight synchronization (`src/ml/reinforcement_learning/train.py:L20-L30`).
- **MLflow Tracking**: Configures MLflow for experiment tracking (`src/ml/reinforcement_learning/train.py:L33-L34`).
- **Environment Interaction**: Uses `TradingEnvironment` (`src/ml/reinforcement_learning/train.py:L37`).
- **Model Training**: `model.learn()` with `EvalCallback` and `SHMWeightSyncCallback` (`src/ml/reinforcement_learning/train.py:L70`).

### 2.7. Shared Memory Manager (`src/shared/shm_manager.py`)
- **SHM Creation**: `create()` method (`src/shared/shm_manager.py:L22`) creates or attaches to shared memory.
- **Atomic Read/Write**: Implements spin-locks (`self._shm.buf[0]`) for atomic operations (`src/shared/shm_manager.py:L31`, `L59`).
- **Msgspec Serialization**: Uses `msgspec.msgpack.Encoder` and `Decoder` (`src/shared/shm_manager.py:L19`).

### 2.8. RL Trading Environment (`src/ml/reinforcement_learning/trading_env.py`)
- **Data Provider**: Relies on an optional `data_provider` or `_get_dummy_data` (`src/ml/reinforcement_learning/trading_env.py:L40`, `L193`).
- **Observation Space**: Transforms market data into a 100-dimensional observation vector (`_construct_single_obs`, `src/ml/reinforcement_learning/trading_env.py:L58`).
- **Step Logic**: `step()` method (`src/ml/reinforcement_learning/trading_env.py:L109`) includes trading actions, cost calculations, portfolio updates, and reward computation.

### 2.9. Real-time Market Data Consumer (`src/streaming/consumer.py`)
- **Kafka Connectivity**: `Consumer` initialization (`src/streaming/consumer.py:L32`) and `bootstrap.servers` configuration.
- **Schema Registry/Avro Deserialization**: `SchemaRegistryClient` and `AvroDeserializer` (`src/streaming/consumer.py:L35-L37`) for Avro messages.
- **Batch Processing**: `consume_messages()` and `_process_batch()` (`src/streaming/consumer.py:L48`, `L74`) use `asyncio.gather`.

## 3. Findings & Analysis

### 3.1. Configuration-Related Runtime Errors
- **Missing/Malformed Environment Variables**: Critical settings like `DATABASE_URL`, `JWT_SECRET`, `REDIS_URL` are loaded from `.env`. Missing or malformed variables will cause application startup failures (e.g., `pydantic_settings` errors).
- **Production `ENVIRONMENT` Misconfigurations**: Setting `ENVIRONMENT` to `dev` in production could lead to security risks (transient RSA keys) or information leakage (verbose error messages) or `ValueError` if JWT keys are explicitly checked for production (`src/config.py:L63`).

### 3.2. Generic Error Handling & Propagation
- **`src/api/main.py:api_exception_handler`**: While improved to show details in non-prod, it's still a catch-all. Errors need to be handled more specifically closer to their origin where possible.
- **`src/streaming/consumer.py:_process_batch`**: The `asyncio.gather` call does not use `return_exceptions=True`, meaning a single exception in processing one message can cause the entire batch to fail, leading to data loss and potential downstream issues.
- **`src/ml/reinforcement_learning/train.py:train_td3`**: Unhandled exceptions during environment interaction or model training can crash the entire training process, potentially without clear diagnostic messages.

### 3.3. System-Level and Concurrency Runtime Errors
- **Shared Memory (SHMManager)**:
    - **Creation/Access Issues**: `SHMManager.create()` or `SHMManager.read()`/`write()` can fail due to OS permissions, resource limits, or if segments are not properly linked/unlinked.
    - **Spin-lock Deadlock/Timeout**: The implemented spin-lock can cause processes to hang or timeout (100ms) if the lock holder crashes or is unusually slow.
    - **Data Corruption**: Improper atomic writes or `msgspec` schema mismatches can corrupt data in shared memory, leading to `DecodeError`s on read.
- **Database Connection Pooling**: `NullPool` in production (`src/database/__init__.py`) can introduce latency under load due to frequent connection establishment, leading to timeouts or performance-related runtime errors.

### 3.4. Data-Related Runtime Errors (Streaming & Trading Environment)
- **Kafka/Schema Registry Connectivity**: Failures to connect to Kafka or Schema Registry (`src/streaming/consumer.py`) will halt data ingestion, causing `TradingEnvironment` to lack market data or receive deserialization errors.
- **Avro Deserialization**: Corrupted or schema-non-conforming Kafka messages will cause runtime errors during deserialization, leading to data loss or malformed data entering `TradingEnvironment`.
- **`TradingEnvironment` Data Quality**: Issues in `data_provider` (whether real or synthetic) such as missing keys, non-numeric values, or inconsistent shapes can lead to `IndexError`, `ValueError`, `TypeError`, or `NaN` propagation during observation construction (`_construct_single_obs`) or reward calculation (`_calculate_reward`). `np.log` of non-positive values is a specific risk.

## 4. Technical Constraints
- The application relies heavily on external services (Kafka, Schema Registry, MLflow, PostgreSQL) and system-level features (shared memory), each introducing potential points of failure and specific runtime error types.
- Error handling is often generic at higher levels, obscuring root causes.
- The `TradingEnvironment` involves complex numerical computations, making it sensitive to data quality and input validity.

## 5. Architecture Documentation
- **API**: FastAPI with `FastAPI` (sync/async) and custom middleware.
- **CLI**: `click`-based, uses `asyncio.run` for async operations.
- **Configuration**: `pydantic-settings` for environment variable management.
- **ML**: `stable_baselines3` for RL, `mlflow` for tracking, custom `TradingEnvironment`.
- **Shared Memory**: `multiprocessing.shared_memory` with `msgspec` for IPC.
- **Streaming**: `confluent_kafka` for Kafka integration, `confluent_kafka.schema_registry` for Avro.
- **Database**: SQLAlchemy (sync/async) with specific pooling strategies.
