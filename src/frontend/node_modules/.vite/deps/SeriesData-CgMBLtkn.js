import { r as __export } from "./chunk-C3fVp-vY.js";
import { n as init_tslib_es6, t as __extends } from "./tslib.es6-BMefx2Ih.js";
import { $ as Point_default, $n as retrieve2, $t as normalize$1, An as inherits, B as Displayable_default, Bn as isString, Cn as each, Ct as liftColor, D as subPixelOptimizeLine$1, E as subPixelOptimize$1, En as filter, Ft as quadraticAt, Gn as map$1, Hn as isTypedArray, Ht as applyTransform$1, It as quadraticDerivativeAt, Jn as mixin, Jt as distance, K as calculateTextPosition, Kn as merge, L as PathProxy_default, Ln as isNumber, Lt as quadraticSubdivide, M as Path_default, Mn as isArrayLike, Mt as cubicDerivativeAt, N as windingLine, Nn as isDom, O as subPixelOptimizeRect$1, On as hasOwn, Pn as isFunction, Pt as cubicSubdivide, Q as createIntersectContext, Qt as min, Rn as isObject$1, S as Text_default, T as Rect_default, Tn as extend, Tt as modifyHSL, U as Group_default, Un as keys, Ut as clone$1, Vn as isStringSafe, Vt as add, X as Eventful_default, Xn as normalizeCssArray$1, Y as parsePercent$1, Yn as noop, Z as BoundingRect_default, Zn as reduce, Zt as max, _n as clone, bn as curry, c as init$1, cn as identity, cr as setPlatformAPI, dn as mul, en as scale$1, er as retrieve3, gn as bind, hn as assert, jn as isArray, jt as cubicAt, k as Image_default, kn as indexOf, kt as LRU_default, l as registerPainter, ln as invert, n as brushSingle, nr as slice, on as copy, p as sort, q as getBoundingRect, rn as sub, rr as trim, sn as create, sr as platformApi, tr as setAsPrimitive, u as registerSSRDataGetter, v as encodeHTML, vn as concatArray, vt as env_default, wn as eqNaN, x as CompoundPath_default, xn as defaults, yn as createHashMap, zn as isRegExp, zt as Transformable_default } from "./graphic-DFooj0z9.js";

//#region node_modules/echarts/lib/util/clazz.js
init_tslib_es6();
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
/**
* Notice, parseClassType('') should returns {main: '', sub: ''}
* @public
*/
function parseClassType(componentType) {
	var ret = {
		main: "",
		sub: ""
	};
	if (componentType) {
		var typeArr = componentType.split(TYPE_DELIMITER);
		ret.main = typeArr[0] || "";
		ret.sub = typeArr[1] || "";
	}
	return ret;
}
/**
* @public
*/
function checkClassType(componentType) {
	assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), "componentType \"" + componentType + "\" illegal");
}
function isExtendedClass(clz) {
	return !!(clz && clz[IS_EXTENDED_CLASS]);
}
/**
* Implements `ExtendableConstructor` for `rootClz`.
*
* @usage
* ```ts
* class Xxx {}
* type XxxConstructor = typeof Xxx & ExtendableConstructor
* enableClassExtend(Xxx as XxxConstructor);
* ```
*/
function enableClassExtend(rootClz, mandatoryMethods) {
	rootClz.$constructor = rootClz;
	rootClz.extend = function(proto) {
		each(mandatoryMethods, function(method) {
			if (!proto[method]) console.warn("Method `" + method + "` should be implemented" + (proto.type ? " in " + proto.type : "") + ".");
		});
		var superClass = this;
		var ExtendedClass;
		if (isESClass(superClass)) ExtendedClass = function(_super) {
			__extends(class_1, _super);
			function class_1() {
				return _super.apply(this, arguments) || this;
			}
			return class_1;
		}(superClass);
		else {
			ExtendedClass = function() {
				(proto.$constructor || superClass).apply(this, arguments);
			};
			inherits(ExtendedClass, this);
		}
		extend(ExtendedClass.prototype, proto);
		ExtendedClass[IS_EXTENDED_CLASS] = true;
		ExtendedClass.extend = this.extend;
		ExtendedClass.superCall = superCall;
		ExtendedClass.superApply = superApply;
		ExtendedClass.superClass = superClass;
		return ExtendedClass;
	};
}
function isESClass(fn) {
	return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
}
/**
* A work around to both support ts extend and this extend mechanism.
* on sub-class.
* @usage
* ```ts
* class Component { ... }
* classUtil.enableClassExtend(Component);
* classUtil.enableClassManagement(Component, {registerWhenExtend: true});
*
* class Series extends Component { ... }
* // Without calling `markExtend`, `registerWhenExtend` will not work.
* Component.markExtend(Series);
* ```
*/
function mountExtend(SubClz, SupperClz) {
	SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
/**
* Implements `CheckableConstructor` for `target`.
* Can not use instanceof, consider different scope by
* cross domain or es module import in ec extensions.
* Mount a method "isInstance()" to Clz.
*
* @usage
* ```ts
* class Xxx {}
* type XxxConstructor = typeof Xxx & CheckableConstructor;
* enableClassCheck(Xxx as XxxConstructor)
* ```
*/
function enableClassCheck(target) {
	var classAttr = ["__\0is_clz", classBase++].join("_");
	target.prototype[classAttr] = true;
	assert(!target.isInstance, "The method \"is\" can not be defined.");
	target.isInstance = function(obj) {
		return !!(obj && obj[classAttr]);
	};
}
function superCall(context, methodName) {
	var args = [];
	for (var _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
	return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
	return this.superClass.prototype[methodName].apply(context, args);
}
/**
* Implements `ClassManager` for `target`
*
* @usage
* ```ts
* class Xxx {}
* type XxxConstructor = typeof Xxx & ClassManager
* enableClassManagement(Xxx as XxxConstructor);
* ```
*/
function enableClassManagement(target) {
	/**
	* Component model classes
	* key: componentType,
	* value:
	*     componentClass, when componentType is 'a'
	*     or Object.<subKey, componentClass>, when componentType is 'a.b'
	*/
	var storage = {};
	target.registerClass = function(clz) {
		var componentFullType = clz.type || clz.prototype.type;
		if (componentFullType) {
			checkClassType(componentFullType);
			clz.prototype.type = componentFullType;
			var componentTypeInfo = parseClassType(componentFullType);
			if (!componentTypeInfo.sub) {
				if (storage[componentTypeInfo.main]) console.warn(componentTypeInfo.main + " exists.");
				storage[componentTypeInfo.main] = clz;
			} else if (componentTypeInfo.sub !== IS_CONTAINER) {
				var container = makeContainer(componentTypeInfo);
				container[componentTypeInfo.sub] = clz;
			}
		}
		return clz;
	};
	target.getClass = function(mainType, subType, throwWhenNotFound) {
		var clz = storage[mainType];
		if (clz && clz[IS_CONTAINER]) clz = subType ? clz[subType] : null;
		if (throwWhenNotFound && !clz) throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
		return clz;
	};
	target.getClassesByMainType = function(componentType) {
		var componentTypeInfo = parseClassType(componentType);
		var result = [];
		var obj = storage[componentTypeInfo.main];
		if (obj && obj[IS_CONTAINER]) each(obj, function(o, type) {
			type !== IS_CONTAINER && result.push(o);
		});
		else result.push(obj);
		return result;
	};
	target.hasClass = function(componentType) {
		return !!storage[parseClassType(componentType).main];
	};
	/**
	* @return Like ['aa', 'bb'], but can not be ['aa.xx']
	*/
	target.getAllClassMainTypes = function() {
		var types = [];
		each(storage, function(obj, type) {
			types.push(type);
		});
		return types;
	};
	/**
	* If a main type is container and has sub types
	*/
	target.hasSubTypes = function(componentType) {
		var obj = storage[parseClassType(componentType).main];
		return obj && obj[IS_CONTAINER];
	};
	function makeContainer(componentTypeInfo) {
		var container = storage[componentTypeInfo.main];
		if (!container || !container[IS_CONTAINER]) {
			container = storage[componentTypeInfo.main] = {};
			container[IS_CONTAINER] = true;
		}
		return container;
	}
}

//#endregion
//#region node_modules/echarts/lib/util/log.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var ECHARTS_PREFIX = "[ECharts] ";
var storedLogs = {};
var hasConsole = typeof console !== "undefined" && console.warn && console.log;
function outputLog(type, str, onlyOnce) {
	if (hasConsole) {
		if (onlyOnce) {
			if (storedLogs[str]) return;
			storedLogs[str] = true;
		}
		console[type](ECHARTS_PREFIX + str);
	}
}
function log(str, onlyOnce) {
	outputLog("log", str, onlyOnce);
}
function warn(str, onlyOnce) {
	outputLog("warn", str, onlyOnce);
}
function error(str, onlyOnce) {
	outputLog("error", str, onlyOnce);
}
function deprecateLog(str) {
	outputLog("warn", "DEPRECATED: " + str, true);
}
function deprecateReplaceLog(oldOpt, newOpt, scope) {
	deprecateLog((scope ? "[" + scope + "]" : "") + (oldOpt + " is deprecated; use " + newOpt + " instead."));
}
/**
* If in __DEV__ environment, get console printable message for users hint.
* Parameters are separated by ' '.
* @usage
* makePrintable('This is an error on', someVar, someObj);
*
* @param hintInfo anything about the current execution context to hint users.
* @throws Error
*/
function makePrintable() {
	var hintInfo = [];
	for (var _i = 0; _i < arguments.length; _i++) hintInfo[_i] = arguments[_i];
	var msg = "";
	var makePrintableStringIfPossible_1 = function(val) {
		return val === void 0 ? "undefined" : val === Infinity ? "Infinity" : val === -Infinity ? "-Infinity" : eqNaN(val) ? "NaN" : val instanceof Date ? "Date(" + val.toISOString() + ")" : isFunction(val) ? "function () { ... }" : isRegExp(val) ? val + "" : null;
	};
	msg = map$1(hintInfo, function(arg) {
		if (isString(arg)) return arg;
		else {
			var printableStr = makePrintableStringIfPossible_1(arg);
			if (printableStr != null) return printableStr;
			else if (typeof JSON !== "undefined" && JSON.stringify) try {
				return JSON.stringify(arg, function(n, val) {
					var printableStr$1 = makePrintableStringIfPossible_1(val);
					return printableStr$1 == null ? val : printableStr$1;
				});
			} catch (err) {
				return "?";
			}
			else return "?";
		}
	}).join(" ");
	return msg;
}
/**
* @throws Error
*/
function throwError(msg) {
	throw new Error(msg);
}

//#endregion
//#region node_modules/echarts/lib/util/component.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var base = Math.round(Math.random() * 10);
/**
* @public
* @param {string} type
* @return {string}
*/
function getUID(type) {
	return [type || "", base++].join("_");
}
/**
* Implements `SubTypeDefaulterManager` for `target`.
*/
function enableSubTypeDefaulter(target) {
	var subTypeDefaulters = {};
	target.registerSubTypeDefaulter = function(componentType, defaulter) {
		var componentTypeInfo = parseClassType(componentType);
		subTypeDefaulters[componentTypeInfo.main] = defaulter;
	};
	target.determineSubType = function(componentType, option) {
		var type = option.type;
		if (!type) {
			var componentTypeMain = parseClassType(componentType).main;
			if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) type = subTypeDefaulters[componentTypeMain](option);
		}
		return type;
	};
}
/**
* Implements `TopologicalTravelable<any>` for `entity`.
*
* Topological travel on Activity Network (Activity On Vertices).
* Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
* If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
* If there is circular dependencey, Error will be thrown.
*/
function enableTopologicalTravel(entity, dependencyGetter) {
	/**
	* @param targetNameList Target Component type list.
	*                       Can be ['aa', 'bb', 'aa.xx']
	* @param fullNameList By which we can build dependency graph.
	* @param callback Params: componentType, dependencies.
	* @param context Scope of callback.
	*/
	entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
		if (!targetNameList.length) return;
		var result = makeDepndencyGraph(fullNameList);
		var graph = result.graph;
		var noEntryList = result.noEntryList;
		var targetNameSet = {};
		each(targetNameList, function(name) {
			targetNameSet[name] = true;
		});
		while (noEntryList.length) {
			var currComponentType = noEntryList.pop();
			var currVertex = graph[currComponentType];
			var isInTargetNameSet = !!targetNameSet[currComponentType];
			if (isInTargetNameSet) {
				callback.call(context, currComponentType, currVertex.originalDeps.slice());
				delete targetNameSet[currComponentType];
			}
			each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
		}
		each(targetNameSet, function() {
			var errMsg = "";
			errMsg = makePrintable("Circular dependency may exists: ", targetNameSet, targetNameList, fullNameList);
			throw new Error(errMsg);
		});
		function removeEdge(succComponentType) {
			graph[succComponentType].entryCount--;
			if (graph[succComponentType].entryCount === 0) noEntryList.push(succComponentType);
		}
		function removeEdgeAndAdd(succComponentType) {
			targetNameSet[succComponentType] = true;
			removeEdge(succComponentType);
		}
	};
	function makeDepndencyGraph(fullNameList) {
		var graph = {};
		var noEntryList = [];
		each(fullNameList, function(name) {
			var thisItem = createDependencyGraphItem(graph, name);
			var availableDeps = getAvailableDependencies(thisItem.originalDeps = dependencyGetter(name), fullNameList);
			thisItem.entryCount = availableDeps.length;
			if (thisItem.entryCount === 0) noEntryList.push(name);
			each(availableDeps, function(dependentName) {
				if (indexOf(thisItem.predecessor, dependentName) < 0) thisItem.predecessor.push(dependentName);
				var thatItem = createDependencyGraphItem(graph, dependentName);
				if (indexOf(thatItem.successor, dependentName) < 0) thatItem.successor.push(name);
			});
		});
		return {
			graph,
			noEntryList
		};
	}
	function createDependencyGraphItem(graph, name) {
		if (!graph[name]) graph[name] = {
			predecessor: [],
			successor: []
		};
		return graph[name];
	}
	function getAvailableDependencies(originalDeps, fullNameList) {
		var availableDeps = [];
		each(originalDeps, function(dep) {
			indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
		});
		return availableDeps;
	}
}
function inheritDefaultOption(superOption, subOption) {
	return merge(merge({}, superOption, true), subOption, true);
}

//#endregion
//#region node_modules/echarts/lib/view/Component.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var ComponentView = function() {
	function ComponentView$1() {
		this.group = new Group_default();
		this.uid = getUID("viewComponent");
	}
	ComponentView$1.prototype.init = function(ecModel, api) {};
	ComponentView$1.prototype.render = function(model, ecModel, api, payload) {};
	ComponentView$1.prototype.dispose = function(ecModel, api) {};
	ComponentView$1.prototype.updateView = function(model, ecModel, api, payload) {};
	ComponentView$1.prototype.updateLayout = function(model, ecModel, api, payload) {};
	ComponentView$1.prototype.updateVisual = function(model, ecModel, api, payload) {};
	/**
	* Hook for toggle blur target series.
	* Can be used in marker for blur or leave blur the markers
	*/
	ComponentView$1.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {};
	/**
	* Traverse the new rendered elements.
	*
	* It will traverse the new added element in progressive rendering.
	* And traverse all in normal rendering.
	*/
	ComponentView$1.prototype.eachRendered = function(cb) {
		var group = this.group;
		if (group) group.traverse(cb);
	};
	return ComponentView$1;
}();
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var Component_default = ComponentView;

//#endregion
//#region node_modules/echarts/lib/model/mixin/makeStyleMapper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function makeStyleMapper(properties, ignoreParent) {
	for (var i = 0; i < properties.length; i++) if (!properties[i][1]) properties[i][1] = properties[i][0];
	ignoreParent = ignoreParent || false;
	return function(model, excludes, includes) {
		var style = {};
		for (var i$1 = 0; i$1 < properties.length; i$1++) {
			var propName = properties[i$1][1];
			if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) continue;
			var val = model.getShallow(propName, ignoreParent);
			if (val != null) style[properties[i$1][0]] = val;
		}
		return style;
	};
}

//#endregion
//#region node_modules/echarts/lib/model/mixin/areaStyle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var AREA_STYLE_KEY_MAP = [
	["fill", "color"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["opacity"],
	["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = function() {
	function AreaStyleMixin$1() {}
	AreaStyleMixin$1.prototype.getAreaStyle = function(excludes, includes) {
		return getAreaStyle(this, excludes, includes);
	};
	return AreaStyleMixin$1;
}();

//#endregion
//#region node_modules/echarts/lib/util/number.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var RADIAN_EPSILON = 1e-4;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
	return str.replace(/^\s+|\s+$/g, "");
}
var mathMin = Math.min;
var mathMax = Math.max;
var mathAbs = Math.abs;
/**
* Linear mapping a value from domain to range
* @param  val
* @param  domain Domain extent domain[0] can be bigger than domain[1]
* @param  range  Range extent range[0] can be bigger than range[1]
* @param  clamp Default to be false
*/
function linearMap(val, domain, range, clamp$1) {
	var d0 = domain[0];
	var d1 = domain[1];
	var r0 = range[0];
	var r1 = range[1];
	var subDomain = d1 - d0;
	var subRange = r1 - r0;
	if (subDomain === 0) return subRange === 0 ? r0 : (r0 + r1) / 2;
	if (clamp$1) {
		if (subDomain > 0) {
			if (val <= d0) return r0;
			else if (val >= d1) return r1;
		} else if (val >= d0) return r0;
		else if (val <= d1) return r1;
	} else {
		if (val === d0) return r0;
		if (val === d1) return r1;
	}
	return (val - d0) / subDomain * subRange + r0;
}
/**
* Preserve the name `parsePercent` for backward compatibility,
* and it's effectively published as `echarts.number.parsePercent`.
*/
var parsePercent = parsePositionOption;
/**
* @see {parsePositionSizeOption} and also accept a string preset.
* @see {PositionSizeOption}
*/
function parsePositionOption(option, percentBase, percentOffset) {
	switch (option) {
		case "center":
		case "middle":
			option = "50%";
			break;
		case "left":
		case "top":
			option = "0%";
			break;
		case "right":
		case "bottom":
			option = "100%";
			break;
	}
	return parsePositionSizeOption(option, percentBase, percentOffset);
}
/**
* Accept number, or numeric stirng (`'123'`), or percentage ('100%'), as x/y/width/height pixel number.
* If null/undefined or invalid, return NaN.
* (But allow JS type coercion (`+option`) due to backward compatibility)
* @see {PositionSizeOption}
*/
function parsePositionSizeOption(option, percentBase, percentOffset) {
	if (isString(option)) {
		if (_trim(option).match(/%$/)) return parseFloat(option) / 100 * percentBase + (percentOffset || 0);
		return parseFloat(option);
	}
	return option == null ? NaN : +option;
}
function round(x, precision, returnStr) {
	if (precision == null) precision = 10;
	precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
	x = (+x).toFixed(precision);
	return returnStr ? x : +x;
}
/**
* Inplacd asc sort arr.
* The input arr will be modified.
*/
function asc(arr) {
	arr.sort(function(a, b) {
		return a - b;
	});
	return arr;
}
/**
* Get precision.
*/
function getPrecision(val) {
	val = +val;
	if (isNaN(val)) return 0;
	if (val > 1e-14) {
		var e$1 = 1;
		for (var i = 0; i < 15; i++, e$1 *= 10) if (Math.round(val * e$1) / e$1 === val) return i;
	}
	return getPrecisionSafe(val);
}
/**
* Get precision with slow but safe method
*/
function getPrecisionSafe(val) {
	var str = val.toString().toLowerCase();
	var eIndex = str.indexOf("e");
	var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
	var significandPartLen = eIndex > 0 ? eIndex : str.length;
	var dotIndex = str.indexOf(".");
	var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
	return Math.max(0, decimalPartLen - exp);
}
/**
* Minimal dicernible data precisioin according to a single pixel.
*/
function getPixelPrecision(dataExtent, pixelExtent) {
	var log$1 = Math.log;
	var LN10 = Math.LN10;
	var dataQuantity = Math.floor(log$1(dataExtent[1] - dataExtent[0]) / LN10);
	var sizeQuantity = Math.round(log$1(mathAbs(pixelExtent[1] - pixelExtent[0])) / LN10);
	var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
	return !isFinite(precision) ? 20 : precision;
}
/**
* Get a data of given precision, assuring the sum of percentages
* in valueList is 1.
* The largest remainder method is used.
* https://en.wikipedia.org/wiki/Largest_remainder_method
*
* @param valueList a list of all data
* @param idx index of the data to be processed in valueList
* @param precision integer number showing digits of precision
* @return percent ranging from 0 to 100
*/
function getPercentWithPrecision(valueList, idx, precision) {
	if (!valueList[idx]) return 0;
	return getPercentSeats(valueList, precision)[idx] || 0;
}
/**
* Get a data of given precision, assuring the sum of percentages
* in valueList is 1.
* The largest remainder method is used.
* https://en.wikipedia.org/wiki/Largest_remainder_method
*
* @param valueList a list of all data
* @param precision integer number showing digits of precision
* @return {Array<number>}
*/
function getPercentSeats(valueList, precision) {
	var sum = reduce(valueList, function(acc, val) {
		return acc + (isNaN(val) ? 0 : val);
	}, 0);
	if (sum === 0) return [];
	var digits = Math.pow(10, precision);
	var votesPerQuota = map$1(valueList, function(val) {
		return (isNaN(val) ? 0 : val) / sum * digits * 100;
	});
	var targetSeats = digits * 100;
	var seats = map$1(votesPerQuota, function(votes) {
		return Math.floor(votes);
	});
	var currentSum = reduce(seats, function(acc, val) {
		return acc + val;
	}, 0);
	var remainder = map$1(votesPerQuota, function(votes, idx) {
		return votes - seats[idx];
	});
	while (currentSum < targetSeats) {
		var max$1 = Number.NEGATIVE_INFINITY;
		var maxId = null;
		for (var i = 0, len = remainder.length; i < len; ++i) if (remainder[i] > max$1) {
			max$1 = remainder[i];
			maxId = i;
		}
		++seats[maxId];
		remainder[maxId] = 0;
		++currentSum;
	}
	return map$1(seats, function(seat) {
		return seat / digits;
	});
}
/**
* Solve the floating point adding problem like 0.1 + 0.2 === 0.30000000000000004
* See <http://0.30000000000000004.com/>
*/
function addSafe(val0, val1) {
	var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
	var sum = val0 + val1;
	return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round(sum, maxPrecision);
}
var MAX_SAFE_INTEGER = 9007199254740991;
/**
* To 0 - 2 * PI, considering negative radian.
*/
function remRadian(radian) {
	var pi2 = Math.PI * 2;
	return (radian % pi2 + pi2) % pi2;
}
/**
* @param {type} radian
* @return {boolean}
*/
function isRadianAroundZero(val) {
	return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
/**
* @param value valid type: number | string | Date, otherwise return `new Date(NaN)`
*   These values can be accepted:
*   + An instance of Date, represent a time in its own time zone.
*   + Or string in a subset of ISO 8601, only including:
*     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
*     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
*     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
*     all of which will be treated as local time if time zone is not specified
*     (see <https://momentjs.com/>).
*   + Or other string format, including (all of which will be treated as local time):
*     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
*     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
*   + a timestamp, which represent a time in UTC.
* @return date Never be null/undefined. If invalid, return `new Date(NaN)`.
*/
function parseDate(value) {
	if (value instanceof Date) return value;
	else if (isString(value)) {
		var match = TIME_REG.exec(value);
		if (!match) return /* @__PURE__ */ new Date(NaN);
		if (!match[8]) return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
		else {
			var hour = +match[4] || 0;
			if (match[8].toUpperCase() !== "Z") hour -= +match[8].slice(0, 3);
			return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
		}
	} else if (value == null) return /* @__PURE__ */ new Date(NaN);
	return new Date(Math.round(value));
}
/**
* Quantity of a number. e.g. 0.1, 1, 10, 100
*
* @param val
* @return
*/
function quantity(val) {
	return Math.pow(10, quantityExponent(val));
}
/**
* Exponent of the quantity of a number
* e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3
*
* @param val non-negative value
* @return
*/
function quantityExponent(val) {
	if (val === 0) return 0;
	var exp = Math.floor(Math.log(val) / Math.LN10);
	/**
	* exp is expected to be the rounded-down result of the base-10 log of val.
	* But due to the precision loss with Math.log(val), we need to restore it
	* using 10^exp to make sure we can get val back from exp. #11249
	*/
	if (val / Math.pow(10, exp) >= 10) exp++;
	return exp;
}
/**
* find a “nice” number approximately equal to x. Round the number if round = true,
* take ceiling if round = false. The primary observation is that the “nicest”
* numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
*
* See "Nice Numbers for Graph Labels" of Graphic Gems.
*
* @param  val Non-negative value.
* @param  round
* @return Niced number
*/
function nice(val, round$1) {
	var exponent = quantityExponent(val);
	var exp10 = Math.pow(10, exponent);
	var f = val / exp10;
	var nf;
	if (round$1) if (f < 1.5) nf = 1;
	else if (f < 2.5) nf = 2;
	else if (f < 4) nf = 3;
	else if (f < 7) nf = 5;
	else nf = 10;
	else if (f < 1) nf = 1;
	else if (f < 2) nf = 2;
	else if (f < 3) nf = 3;
	else if (f < 5) nf = 5;
	else nf = 10;
	val = nf * exp10;
	return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
/**
* This code was copied from "d3.js"
* <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.
* See the license statement at the head of this file.
* @param ascArr
*/
function quantile(ascArr, p) {
	var H = (ascArr.length - 1) * p + 1;
	var h = Math.floor(H);
	var v = +ascArr[h - 1];
	var e$1 = H - h;
	return e$1 ? v + e$1 * (ascArr[h] - v) : v;
}
/**
* Order intervals asc, and split them when overlap.
* expect(numberUtil.reformIntervals([
*     {interval: [18, 62], close: [1, 1]},
*     {interval: [-Infinity, -70], close: [0, 0]},
*     {interval: [-70, -26], close: [1, 1]},
*     {interval: [-26, 18], close: [1, 1]},
*     {interval: [62, 150], close: [1, 1]},
*     {interval: [106, 150], close: [1, 1]},
*     {interval: [150, Infinity], close: [0, 0]}
* ])).toEqual([
*     {interval: [-Infinity, -70], close: [0, 0]},
*     {interval: [-70, -26], close: [1, 1]},
*     {interval: [-26, 18], close: [0, 1]},
*     {interval: [18, 62], close: [0, 1]},
*     {interval: [62, 150], close: [0, 1]},
*     {interval: [150, Infinity], close: [0, 0]}
* ]);
* @param list, where `close` mean open or close
*        of the interval, and Infinity can be used.
* @return The origin list, which has been reformed.
*/
function reformIntervals(list) {
	list.sort(function(a, b) {
		return littleThan(a, b, 0) ? -1 : 1;
	});
	var curr = -Infinity;
	var currClose = 1;
	for (var i = 0; i < list.length;) {
		var interval = list[i].interval;
		var close_1 = list[i].close;
		for (var lg = 0; lg < 2; lg++) {
			if (interval[lg] <= curr) {
				interval[lg] = curr;
				close_1[lg] = !lg ? 1 - currClose : 1;
			}
			curr = interval[lg];
			currClose = close_1[lg];
		}
		if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) list.splice(i, 1);
		else i++;
	}
	return list;
	function littleThan(a, b, lg$1) {
		return a.interval[lg$1] < b.interval[lg$1] || a.interval[lg$1] === b.interval[lg$1] && (a.close[lg$1] - b.close[lg$1] === (!lg$1 ? 1 : -1) || !lg$1 && littleThan(a, b, 1));
	}
}
/**
* [Numeric is defined as]:
*     `parseFloat(val) == val`
* For example:
* numeric:
*     typeof number except NaN, '-123', '123', '2e3', '-2e3', '011', 'Infinity', Infinity,
*     and they rounded by white-spaces or line-terminal like ' -123 \n ' (see es spec)
* not-numeric:
*     null, undefined, [], {}, true, false, 'NaN', NaN, '123ab',
*     empty string, string with only white-spaces or line-terminal (see es spec),
*     0x12, '0x12', '-0x12', 012, '012', '-012',
*     non-string, ...
*
* @test See full test cases in `test/ut/spec/util/number.js`.
* @return Must be a typeof number. If not numeric, return NaN.
*/
function numericToNumber(val) {
	var valFloat = parseFloat(val);
	return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
}
/**
* Definition of "numeric": see `numericToNumber`.
*/
function isNumeric(val) {
	return !isNaN(numericToNumber(val));
}
/**
* Use random base to prevent users hard code depending on
* this auto generated marker id.
* @return An positive integer.
*/
function getRandomIdBase() {
	return Math.round(Math.random() * 9);
}
/**
* Get the greatest common divisor.
*
* @param {number} a one number
* @param {number} b the other number
*/
function getGreatestCommonDividor(a, b) {
	if (b === 0) return a;
	return getGreatestCommonDividor(b, a % b);
}
/**
* Get the least common multiple.
*
* @param {number} a one number
* @param {number} b the other number
*/
function getLeastCommonMultiple(a, b) {
	if (a == null) return b;
	if (b == null) return a;
	return a * b / getGreatestCommonDividor(a, b);
}

//#endregion
//#region node_modules/echarts/lib/util/model.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function interpolateNumber(p0, p1, percent) {
	return (p1 - p0) * percent + p0;
}
/**
* Make the name displayable. But we should
* make sure it is not duplicated with user
* specified name, so use '\0';
*/
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
/**
* If value is not array, then translate it to array.
* @param  {*} value
* @return {Array} [value] or value
*/
function normalizeToArray(value) {
	return value instanceof Array ? value : value == null ? [] : [value];
}
/**
* Sync default option between normal and emphasis like `position` and `show`
* In case some one will write code like
*     label: {
*          show: false,
*          position: 'outside',
*          fontSize: 18
*     },
*     emphasis: {
*          label: { show: true }
*     }
*/
function defaultEmphasis(opt, key$1, subOpts) {
	if (opt) {
		opt[key$1] = opt[key$1] || {};
		opt.emphasis = opt.emphasis || {};
		opt.emphasis[key$1] = opt.emphasis[key$1] || {};
		for (var i = 0, len = subOpts.length; i < len; i++) {
			var subOptName = subOpts[i];
			if (!opt.emphasis[key$1].hasOwnProperty(subOptName) && opt[key$1].hasOwnProperty(subOptName)) opt.emphasis[key$1][subOptName] = opt[key$1][subOptName];
		}
	}
}
var TEXT_STYLE_OPTIONS = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily",
	"rich",
	"tag",
	"color",
	"textBorderColor",
	"textBorderWidth",
	"width",
	"height",
	"lineHeight",
	"align",
	"verticalAlign",
	"baseline",
	"shadowColor",
	"shadowBlur",
	"shadowOffsetX",
	"shadowOffsetY",
	"textShadowColor",
	"textShadowBlur",
	"textShadowOffsetX",
	"textShadowOffsetY",
	"backgroundColor",
	"borderColor",
	"borderWidth",
	"borderRadius",
	"padding"
];
/**
* The method does not ensure performance.
* data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
* This helper method retrieves value from data.
*/
function getDataItemValue(dataItem) {
	return isObject$1(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
/**
* data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
* This helper method determine if dataItem has extra option besides value
*/
function isDataItemOption(dataItem) {
	return isObject$1(dataItem) && !(dataItem instanceof Array);
}
/**
* Mapping to existings for merge.
*
* Mode "normalMege":
*     The mapping result (merge result) will keep the order of the existing
*     component, rather than the order of new option. Because we should ensure
*     some specified index reference (like xAxisIndex) keep work.
*     And in most cases, "merge option" is used to update partial option but not
*     be expected to change the order.
*
* Mode "replaceMege":
*     (1) Only the id mapped components will be merged.
*     (2) Other existing components (except internal components) will be removed.
*     (3) Other new options will be used to create new component.
*     (4) The index of the existing components will not be modified.
*     That means their might be "hole" after the removal.
*     The new components are created first at those available index.
*
* Mode "replaceAll":
*     This mode try to support that reproduce an echarts instance from another
*     echarts instance (via `getOption`) in some simple cases.
*     In this scenario, the `result` index are exactly the consistent with the `newCmptOptions`,
*     which ensures the component index referring (like `xAxisIndex: ?`) corrent. That is,
*     the "hole" in `newCmptOptions` will also be kept.
*     On the contrary, other modes try best to eliminate holes.
*     PENDING: This is an experimental mode yet.
*
* @return See the comment of <MappingResult>.
*/
function mappingToExists(existings, newCmptOptions, mode) {
	var isNormalMergeMode = mode === "normalMerge";
	var isReplaceMergeMode = mode === "replaceMerge";
	var isReplaceAllMode = mode === "replaceAll";
	existings = existings || [];
	newCmptOptions = (newCmptOptions || []).slice();
	var existingIdIdxMap = createHashMap();
	each(newCmptOptions, function(cmptOption, index) {
		if (!isObject$1(cmptOption)) {
			newCmptOptions[index] = null;
			return;
		}
		if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) warnInvalidateIdOrName(cmptOption.id);
		if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) warnInvalidateIdOrName(cmptOption.name);
	});
	var result = prepareResult(existings, existingIdIdxMap, mode);
	if (isNormalMergeMode || isReplaceMergeMode) mappingById(result, existings, existingIdIdxMap, newCmptOptions);
	if (isNormalMergeMode) mappingByName(result, newCmptOptions);
	if (isNormalMergeMode || isReplaceMergeMode) mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
	else if (isReplaceAllMode) mappingInReplaceAllMode(result, newCmptOptions);
	makeIdAndName(result);
	return result;
}
function prepareResult(existings, existingIdIdxMap, mode) {
	var result = [];
	if (mode === "replaceAll") return result;
	for (var index = 0; index < existings.length; index++) {
		var existing = existings[index];
		if (existing && existing.id != null) existingIdIdxMap.set(existing.id, index);
		result.push({
			existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
			newOption: null,
			keyInfo: null,
			brandNew: null
		});
	}
	return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
	each(newCmptOptions, function(cmptOption, index) {
		if (!cmptOption || cmptOption.id == null) return;
		var optionId = makeComparableKey(cmptOption.id);
		var existingIdx = existingIdIdxMap.get(optionId);
		if (existingIdx != null) {
			var resultItem = result[existingIdx];
			assert(!resultItem.newOption, "Duplicated option on id \"" + optionId + "\".");
			resultItem.newOption = cmptOption;
			resultItem.existing = existings[existingIdx];
			newCmptOptions[index] = null;
		}
	});
}
function mappingByName(result, newCmptOptions) {
	each(newCmptOptions, function(cmptOption, index) {
		if (!cmptOption || cmptOption.name == null) return;
		for (var i = 0; i < result.length; i++) {
			var existing = result[i].existing;
			if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
				result[i].newOption = cmptOption;
				newCmptOptions[index] = null;
				return;
			}
		}
	});
}
function mappingByIndex(result, newCmptOptions, brandNew) {
	each(newCmptOptions, function(cmptOption) {
		if (!cmptOption) return;
		var resultItem;
		var nextIdx = 0;
		while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) nextIdx++;
		if (resultItem) {
			resultItem.newOption = cmptOption;
			resultItem.brandNew = brandNew;
		} else result.push({
			newOption: cmptOption,
			brandNew,
			existing: null,
			keyInfo: null
		});
		nextIdx++;
	});
}
function mappingInReplaceAllMode(result, newCmptOptions) {
	each(newCmptOptions, function(cmptOption) {
		result.push({
			newOption: cmptOption,
			brandNew: true,
			existing: null,
			keyInfo: null
		});
	});
}
/**
* Make id and name for mapping result (result of mappingToExists)
* into `keyInfo` field.
*/
function makeIdAndName(mapResult) {
	var idMap = createHashMap();
	each(mapResult, function(item) {
		var existing = item.existing;
		existing && idMap.set(existing.id, item);
	});
	each(mapResult, function(item) {
		var opt = item.newOption;
		assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
		opt && opt.id != null && idMap.set(opt.id, item);
		!item.keyInfo && (item.keyInfo = {});
	});
	each(mapResult, function(item, index) {
		var existing = item.existing;
		var opt = item.newOption;
		var keyInfo = item.keyInfo;
		if (!isObject$1(opt)) return;
		keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
		if (existing) keyInfo.id = makeComparableKey(existing.id);
		else if (opt.id != null) keyInfo.id = makeComparableKey(opt.id);
		else {
			var idNum = 0;
			do
				keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
			while (idMap.get(keyInfo.id));
		}
		idMap.set(keyInfo.id, item);
	});
}
function keyExistAndEqual(attr, obj1, obj2) {
	var key1 = convertOptionIdName(obj1[attr], null);
	var key2 = convertOptionIdName(obj2[attr], null);
	return key1 != null && key2 != null && key1 === key2;
}
/**
* @return return null if not exist.
*/
function makeComparableKey(val) {
	if (val == null) throw new Error();
	return convertOptionIdName(val, "");
}
function convertOptionIdName(idOrName, defaultValue) {
	if (idOrName == null) return defaultValue;
	return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function warnInvalidateIdOrName(idOrName) {
	warn("`" + idOrName + "` is invalid id or name. Must be a string or number.");
}
function isValidIdOrName(idOrName) {
	return isStringSafe(idOrName) || isNumeric(idOrName);
}
function isNameSpecified(componentModel) {
	var name = componentModel.name;
	return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
/**
* @public
* @param {Object} cmptOption
* @return {boolean}
*/
function isComponentIdInternal(cmptOption) {
	return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(idSuffix) {
	return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
	each(mappingResult, function(item) {
		var newOption = item.newOption;
		if (isObject$1(newOption)) {
			item.keyInfo.mainType = mainType;
			item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
		}
	});
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
	return newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
}
/**
* A helper for removing duplicate items between batchA and batchB,
* and in themselves, and categorize by series.
*
* @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
* @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
* @return result: [resultBatchA, resultBatchB]
*/
function compressBatches(batchA, batchB) {
	var mapA = {};
	var mapB = {};
	makeMap(batchA || [], mapA);
	makeMap(batchB || [], mapB, mapA);
	return [mapToArray(mapA), mapToArray(mapB)];
	function makeMap(sourceBatch, map$2, otherMap) {
		for (var i = 0, len = sourceBatch.length; i < len; i++) {
			var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);
			if (seriesId == null) return;
			var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
			var otherDataIndices = otherMap && otherMap[seriesId];
			for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
				var dataIndex = dataIndices[j];
				if (otherDataIndices && otherDataIndices[dataIndex]) otherDataIndices[dataIndex] = null;
				else (map$2[seriesId] || (map$2[seriesId] = {}))[dataIndex] = 1;
			}
		}
	}
	function mapToArray(map$2, isData) {
		var result = [];
		for (var i in map$2) if (map$2.hasOwnProperty(i) && map$2[i] != null) if (isData) result.push(+i);
		else {
			var dataIndices = mapToArray(map$2[i], true);
			dataIndices.length && result.push({
				seriesId: i,
				dataIndex: dataIndices
			});
		}
		return result;
	}
}
/**
* @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name
*                         each of which can be Array or primary type.
* @return dataIndex If not found, return undefined/null.
*/
function queryDataIndex(data, payload) {
	if (payload.dataIndexInside != null) return payload.dataIndexInside;
	else if (payload.dataIndex != null) return isArray(payload.dataIndex) ? map$1(payload.dataIndex, function(value) {
		return data.indexOfRawIndex(value);
	}) : data.indexOfRawIndex(payload.dataIndex);
	else if (payload.name != null) return isArray(payload.name) ? map$1(payload.name, function(value) {
		return data.indexOfName(value);
	}) : data.indexOfName(payload.name);
}
/**
* Enable property storage to any host object.
* Notice: Serialization is not supported.
*
* For example:
* let inner = zrUitl.makeInner();
*
* function some1(hostObj) {
*      inner(hostObj).someProperty = 1212;
*      ...
* }
* function some2() {
*      let fields = inner(this);
*      fields.someProperty1 = 1212;
*      fields.someProperty2 = 'xx';
*      ...
* }
*
* @return {Function}
*/
function makeInner() {
	var key$1 = "__ec_inner_" + innerUniqueIndex++;
	return function(hostObj) {
		return hostObj[key$1] || (hostObj[key$1] = {});
	};
}
var innerUniqueIndex = getRandomIdBase();
/**
* The same behavior as `component.getReferringComponents`.
*/
function parseFinder(ecModel, finderInput, opt) {
	var _a$1 = preParseFinder(finderInput, opt), mainTypeSpecified = _a$1.mainTypeSpecified, queryOptionMap = _a$1.queryOptionMap;
	var result = _a$1.others;
	var defaultMainType = opt ? opt.defaultMainType : null;
	if (!mainTypeSpecified && defaultMainType) queryOptionMap.set(defaultMainType, {});
	queryOptionMap.each(function(queryOption, mainType) {
		var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
			useDefault: defaultMainType === mainType,
			enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
			enableNone: opt && opt.enableNone != null ? opt.enableNone : true
		});
		result[mainType + "Models"] = queryResult.models;
		result[mainType + "Model"] = queryResult.models[0];
	});
	return result;
}
function preParseFinder(finderInput, opt) {
	var finder;
	if (isString(finderInput)) {
		var obj = {};
		obj[finderInput + "Index"] = 0;
		finder = obj;
	} else finder = finderInput;
	var queryOptionMap = createHashMap();
	var others = {};
	var mainTypeSpecified = false;
	each(finder, function(value, key$1) {
		if (key$1 === "dataIndex" || key$1 === "dataIndexInside") {
			others[key$1] = value;
			return;
		}
		var parsedKey = key$1.match(/^(\w+)(Index|Id|Name)$/) || [];
		var mainType = parsedKey[1];
		var queryType = (parsedKey[2] || "").toLowerCase();
		if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) return;
		mainTypeSpecified = mainTypeSpecified || !!mainType;
		var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
		queryOption[queryType] = value;
	});
	return {
		mainTypeSpecified,
		queryOptionMap,
		others
	};
}
var SINGLE_REFERRING = {
	useDefault: true,
	enableAll: false,
	enableNone: false
};
var MULTIPLE_REFERRING = {
	useDefault: false,
	enableAll: true,
	enableNone: true
};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
	opt = opt || SINGLE_REFERRING;
	var indexOption = userOption.index;
	var idOption = userOption.id;
	var nameOption = userOption.name;
	var result = {
		models: null,
		specified: indexOption != null || idOption != null || nameOption != null
	};
	if (!result.specified) {
		var firstCmpt = void 0;
		result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
		return result;
	}
	if (indexOption === "none" || indexOption === false) if (opt.enableNone) {
		result.models = [];
		return result;
	} else {
		error("`\"none\"` or `false` is not a valid value on index option.");
		indexOption = -1;
	}
	if (indexOption === "all") if (opt.enableAll) indexOption = idOption = nameOption = null;
	else {
		error("`\"all\"` is not a valid value on index option.");
		indexOption = -1;
	}
	result.models = ecModel.queryComponents({
		mainType,
		index: indexOption,
		id: idOption,
		name: nameOption
	});
	return result;
}
function setAttribute(dom, key$1, value) {
	dom.setAttribute ? dom.setAttribute(key$1, value) : dom[key$1] = value;
}
function getAttribute(dom, key$1) {
	return dom.getAttribute ? dom.getAttribute(key$1) : dom[key$1];
}
function getTooltipRenderMode(renderModeOption) {
	if (renderModeOption === "auto") return env_default.domSupported ? "html" : "richText";
	else return renderModeOption || "html";
}
/**
* Group a list by key.
*/
function groupData(array, getKey) {
	var buckets = createHashMap();
	var keys$1 = [];
	each(array, function(item) {
		var key$1 = getKey(item);
		(buckets.get(key$1) || (keys$1.push(key$1), buckets.set(key$1, []))).push(item);
	});
	return {
		keys: keys$1,
		buckets
	};
}
/**
* Interpolate raw values of a series with percent
*
* @param data         data
* @param labelModel   label model of the text element
* @param sourceValue  start value. May be null/undefined when init.
* @param targetValue  end value
* @param percent      0~1 percentage; 0 uses start value while 1 uses end value
* @return             interpolated values
*                     If `sourceValue` and `targetValue` are `number`, return `number`.
*                     If `sourceValue` and `targetValue` are `string`, return `string`.
*                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.
*                     Other cases do not supported.
*/
function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
	var isAutoPrecision = precision == null || precision === "auto";
	if (targetValue == null) return targetValue;
	if (isNumber(targetValue)) {
		var value = interpolateNumber(sourceValue || 0, targetValue, percent);
		return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
	} else if (isString(targetValue)) return percent < 1 ? sourceValue : targetValue;
	else {
		var interpolated = [];
		var leftArr = sourceValue;
		var rightArr = targetValue;
		var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
		for (var i = 0; i < length_1; ++i) {
			var info = data.getDimensionInfo(i);
			if (info && info.type === "ordinal") interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
			else {
				var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
				var rightVal = rightArr[i];
				var value = interpolateNumber(leftVal, rightVal, percent);
				interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
			}
		}
		return interpolated;
	}
}
/**
* Use an iterator to avoid exposing the internal list or duplicating it
* for the outside traveller, and no extra heap allocation.
* @usage
*  for (const it = resetIterator(); it.next();) {
*      const item = it.item;
*      const key = it.key;
*      const itIdx = it.itIdx;
*      // ...
*  }
* @usage
*  const it = resetIterator();
*  while (it.next()) { ... }
* @usage
*  for (resetIterator(it); it.next();) { ... }
*/
var ListIterator = function() {
	function ListIterator$1() {}
	/**
	* The loop condition is `idx < end` if `step > 0`;
	* The loop condition is `idx >= end` if `step < 0`.
	*
	* @param end By default `list.length` if `step > 0`; `0` if `step < 0`.
	* @param step By default `1`.
	*/
	ListIterator$1.prototype.reset = function(list, start, end, step) {
		this._list = list;
		this._step = step = step || 1;
		this._idx = start;
		this._end = end != null ? end : step > 0 ? list.length : 0;
		this.item = null;
		this.key = NaN;
		return this;
	};
	ListIterator$1.prototype.next = function() {
		if (this._step > 0 ? this._idx < this._end : this._idx >= this._end) {
			this.item = this._list[this._idx];
			this.key = this._idx = this._idx + this._step;
			return true;
		}
		return false;
	};
	return ListIterator$1;
}();
function clearTmpModel(model) {
	model.option = model.parentModel = model.ecModel = null;
}

//#endregion
//#region node_modules/echarts/lib/util/innerStore.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var getECData = makeInner();
var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
	if (el) {
		var ecData = getECData(el);
		ecData.dataIndex = dataIdx;
		ecData.dataType = dataType;
		ecData.seriesIndex = seriesIndex;
		ecData.ssrType = "chart";
		if (el.type === "group") el.traverse(function(child) {
			var childECData = getECData(child);
			childECData.seriesIndex = seriesIndex;
			childECData.dataIndex = dataIdx;
			childECData.dataType = dataType;
			childECData.ssrType = "chart";
		});
	}
};

//#endregion
//#region node_modules/echarts/lib/util/states.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = [
	"emphasis",
	"blur",
	"select"
];
var DISPLAY_STATES = [
	"normal",
	"emphasis",
	"blur",
	"select"
];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
var SELECT_CHANGED_EVENT_TYPE = "selectchanged";
function hasFillOrStroke(fillOrStroke) {
	return fillOrStroke != null && fillOrStroke !== "none";
}
function doChangeHoverState(el, stateName, hoverStateEnum) {
	if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) el.onHoverStateChange(stateName);
	el.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el) {
	doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el) {
	if (el.hoverState === HOVER_STATE_EMPHASIS) doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
}
function singleEnterBlur(el) {
	doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el) {
	if (el.hoverState === HOVER_STATE_BLUR) doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
}
function singleEnterSelect(el) {
	el.selected = true;
}
function singleLeaveSelect(el) {
	el.selected = false;
}
function updateElementState(el, updater, commonParam) {
	updater(el, commonParam);
}
function traverseUpdateState(el, updater, commonParam) {
	updateElementState(el, updater, commonParam);
	el.isGroup && el.traverse(function(child) {
		updateElementState(child, updater, commonParam);
	});
}
function setStatesFlag(el, stateName) {
	switch (stateName) {
		case "emphasis":
			el.hoverState = HOVER_STATE_EMPHASIS;
			break;
		case "normal":
			el.hoverState = HOVER_STATE_NORMAL;
			break;
		case "blur":
			el.hoverState = HOVER_STATE_BLUR;
			break;
		case "select": el.selected = true;
	}
}
function getFromStateStyle(el, props, toStateName, defaultValue) {
	var style = el.style;
	var fromState = {};
	for (var i = 0; i < props.length; i++) {
		var propName = props[i];
		var val = style[propName];
		fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
	}
	for (var i = 0; i < el.animators.length; i++) {
		var animator = el.animators[i];
		if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") animator.saveTo(fromState, props);
	}
	return fromState;
}
function createEmphasisDefaultState(el, stateName, targetStates, state) {
	var hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
	var cloned = false;
	if (el instanceof Path_default) {
		var store = getSavedStates(el);
		var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
		var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
		if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
			state = state || {};
			var emphasisStyle = state.style || {};
			if (emphasisStyle.fill === "inherit") {
				cloned = true;
				state = extend({}, state);
				emphasisStyle = extend({}, emphasisStyle);
				emphasisStyle.fill = fromFill;
			} else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
				cloned = true;
				state = extend({}, state);
				emphasisStyle = extend({}, emphasisStyle);
				emphasisStyle.fill = liftColor(fromFill);
			} else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
				if (!cloned) {
					state = extend({}, state);
					emphasisStyle = extend({}, emphasisStyle);
				}
				emphasisStyle.stroke = liftColor(fromStroke);
			}
			state.style = emphasisStyle;
		}
	}
	if (state) {
		if (state.z2 == null) {
			if (!cloned) state = extend({}, state);
			var z2EmphasisLift = el.z2EmphasisLift;
			state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
		}
	}
	return state;
}
function createSelectDefaultState(el, stateName, state) {
	if (state) {
		if (state.z2 == null) {
			state = extend({}, state);
			var z2SelectLift = el.z2SelectLift;
			state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
		}
	}
	return state;
}
function createBlurDefaultState(el, stateName, state) {
	var hasBlur = indexOf(el.currentStates, stateName) >= 0;
	var currentOpacity = el.style.opacity;
	var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, { opacity: 1 }) : null;
	state = state || {};
	var blurStyle = state.style || {};
	if (blurStyle.opacity == null) {
		state = extend({}, state);
		blurStyle = extend({ opacity: hasBlur ? currentOpacity : fromState.opacity * .1 }, blurStyle);
		state.style = blurStyle;
	}
	return state;
}
function elementStateProxy(stateName, targetStates) {
	var state = this.states[stateName];
	if (this.style) {
		if (stateName === "emphasis") return createEmphasisDefaultState(this, stateName, targetStates, state);
		else if (stateName === "blur") return createBlurDefaultState(this, stateName, state);
		else if (stateName === "select") return createSelectDefaultState(this, stateName, state);
	}
	return state;
}
/**
* Set hover style (namely "emphasis style") of element.
* @param el Should not be `zrender/graphic/Group`.
* @param focus 'self' | 'selfInSeries' | 'series'
*/
function setDefaultStateProxy(el) {
	el.stateProxy = elementStateProxy;
	var textContent = el.getTextContent();
	var textGuide = el.getTextGuideLine();
	if (textContent) textContent.stateProxy = elementStateProxy;
	if (textGuide) textGuide.stateProxy = elementStateProxy;
}
function enterEmphasisWhenMouseOver(el, e$1) {
	!shouldSilent(el, e$1) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e$1) {
	!shouldSilent(el, e$1) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
	el.__highByOuter |= 1 << (highlightDigit || 0);
	traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
	!(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
	traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
	traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
	traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
	traverseUpdateState(el, singleLeaveSelect);
}
function shouldSilent(el, e$1) {
	return el.__highDownSilentOnTouch && e$1.zrByTouch;
}
function allLeaveBlur(api) {
	var model = api.getModel();
	var leaveBlurredSeries = [];
	var allComponentViews = [];
	model.eachComponent(function(componentType, componentModel) {
		var componentStates = getComponentStates(componentModel);
		var isSeries$1 = componentType === "series";
		var view = isSeries$1 ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
		!isSeries$1 && allComponentViews.push(view);
		if (componentStates.isBlured) {
			view.group.traverse(function(child) {
				singleLeaveBlur(child);
			});
			isSeries$1 && leaveBlurredSeries.push(componentModel);
		}
		componentStates.isBlured = false;
	});
	each(allComponentViews, function(view) {
		if (view && view.toggleBlurSeries) view.toggleBlurSeries(leaveBlurredSeries, false, model);
	});
}
function blurSeries(targetSeriesIndex, focus, blurScope, api) {
	var ecModel = api.getModel();
	blurScope = blurScope || "coordinateSystem";
	function leaveBlurOfIndices(data, dataIndices) {
		for (var i = 0; i < dataIndices.length; i++) {
			var itemEl = data.getItemGraphicEl(dataIndices[i]);
			itemEl && leaveBlur(itemEl);
		}
	}
	if (targetSeriesIndex == null) return;
	if (!focus || focus === "none") return;
	var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
	var targetCoordSys = targetSeriesModel.coordinateSystem;
	if (targetCoordSys && targetCoordSys.master) targetCoordSys = targetCoordSys.master;
	var blurredSeries = [];
	ecModel.eachSeries(function(seriesModel) {
		var sameSeries = targetSeriesModel === seriesModel;
		var coordSys = seriesModel.coordinateSystem;
		if (coordSys && coordSys.master) coordSys = coordSys.master;
		if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !(coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries) || focus === "series" && sameSeries)) {
			api.getViewOfSeriesModel(seriesModel).group.traverse(function(child) {
				if (child.__highByOuter && sameSeries && focus === "self") return;
				singleEnterBlur(child);
			});
			if (isArrayLike(focus)) leaveBlurOfIndices(seriesModel.getData(), focus);
			else if (isObject$1(focus)) {
				var dataTypes = keys(focus);
				for (var d = 0; d < dataTypes.length; d++) leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
			}
			blurredSeries.push(seriesModel);
			getComponentStates(seriesModel).isBlured = true;
		}
	});
	ecModel.eachComponent(function(componentType, componentModel) {
		if (componentType === "series") return;
		var view = api.getViewOfComponentModel(componentModel);
		if (view && view.toggleBlurSeries) view.toggleBlurSeries(blurredSeries, true, ecModel);
	});
}
function blurComponent(componentMainType, componentIndex, api) {
	if (componentMainType == null || componentIndex == null) return;
	var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
	if (!componentModel) return;
	getComponentStates(componentModel).isBlured = true;
	var view = api.getViewOfComponentModel(componentModel);
	if (!view || !view.focusBlurEnabled) return;
	view.group.traverse(function(child) {
		singleEnterBlur(child);
	});
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
	var seriesIndex = seriesModel.seriesIndex;
	var data = seriesModel.getData(payload.dataType);
	if (!data) {
		error("Unknown dataType " + payload.dataType);
		return;
	}
	var dataIndex = queryDataIndex(data, payload);
	dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;
	var el = data.getItemGraphicEl(dataIndex);
	if (!el) {
		var count = data.count();
		var current = 0;
		while (!el && current < count) el = data.getItemGraphicEl(current++);
	}
	if (el) {
		var ecData = getECData(el);
		blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
	} else {
		var focus_1 = seriesModel.get(["emphasis", "focus"]);
		var blurScope = seriesModel.get(["emphasis", "blurScope"]);
		if (focus_1 != null) blurSeries(seriesIndex, focus_1, blurScope, api);
	}
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {
	var ret = {
		focusSelf: false,
		dispatchers: null
	};
	if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) return ret;
	var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
	if (!componentModel) return ret;
	var view = api.getViewOfComponentModel(componentModel);
	if (!view || !view.findHighDownDispatchers) return ret;
	var dispatchers = view.findHighDownDispatchers(name);
	var focusSelf;
	for (var i = 0; i < dispatchers.length; i++) {
		if (!isHighDownDispatcher(dispatchers[i])) error("param should be highDownDispatcher");
		if (getECData(dispatchers[i]).focus === "self") {
			focusSelf = true;
			break;
		}
	}
	return {
		focusSelf,
		dispatchers
	};
}
function handleGlobalMouseOverForHighDown(dispatcher, e$1, api) {
	if (!isHighDownDispatcher(dispatcher)) error("param should be highDownDispatcher");
	var ecData = getECData(dispatcher);
	var _a$1 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a$1.dispatchers, focusSelf = _a$1.focusSelf;
	if (dispatchers) {
		if (focusSelf) blurComponent(ecData.componentMainType, ecData.componentIndex, api);
		each(dispatchers, function(dispatcher$1) {
			return enterEmphasisWhenMouseOver(dispatcher$1, e$1);
		});
	} else {
		blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
		if (ecData.focus === "self") blurComponent(ecData.componentMainType, ecData.componentIndex, api);
		enterEmphasisWhenMouseOver(dispatcher, e$1);
	}
}
function handleGlobalMouseOutForHighDown(dispatcher, e$1, api) {
	if (!isHighDownDispatcher(dispatcher)) error("param should be highDownDispatcher");
	allLeaveBlur(api);
	var ecData = getECData(dispatcher);
	var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
	if (dispatchers) each(dispatchers, function(dispatcher$1) {
		return leaveEmphasisWhenMouseOut(dispatcher$1, e$1);
	});
	else leaveEmphasisWhenMouseOut(dispatcher, e$1);
}
function toggleSelectionFromPayload(seriesModel, payload, api) {
	if (!isSelectChangePayload(payload)) return;
	var dataType = payload.dataType;
	var dataIndex = queryDataIndex(seriesModel.getData(dataType), payload);
	if (!isArray(dataIndex)) dataIndex = [dataIndex];
	seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
	each(seriesModel.getAllData(), function(_a$1) {
		var data = _a$1.data, type = _a$1.type;
		data.eachItemGraphicEl(function(el, idx) {
			seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
		});
	});
}
function getAllSelectedIndices(ecModel) {
	var ret = [];
	ecModel.eachSeries(function(seriesModel) {
		each(seriesModel.getAllData(), function(_a$1) {
			_a$1.data;
			var type = _a$1.type;
			var dataIndices = seriesModel.getSelectedDataIndices();
			if (dataIndices.length > 0) {
				var item = {
					dataIndex: dataIndices,
					seriesIndex: seriesModel.seriesIndex
				};
				if (type != null) item.dataType = type;
				ret.push(item);
			}
		});
	});
	return ret;
}
/**
* Enable the function that mouseover will trigger the emphasis state.
*
* NOTE:
* This function should be used on the element with dataIndex, seriesIndex.
*
*/
function enableHoverEmphasis(el, focus, blurScope) {
	setAsHighDownDispatcher(el, true);
	traverseUpdateState(el, setDefaultStateProxy);
	enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
	setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
	isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
	var ecData = getECData(el);
	if (focus != null) {
		ecData.focus = focus;
		ecData.blurScope = blurScope;
	} else if (ecData.focus) ecData.focus = null;
}
var OTHER_STATES = [
	"emphasis",
	"blur",
	"select"
];
var defaultStyleGetterMap = {
	itemStyle: "getItemStyle",
	lineStyle: "getLineStyle",
	areaStyle: "getAreaStyle"
};
/**
* Set emphasis/blur/selected states of element.
*/
function setStatesStylesFromModel(el, itemModel, styleType, getter) {
	styleType = styleType || "itemStyle";
	for (var i = 0; i < OTHER_STATES.length; i++) {
		var stateName = OTHER_STATES[i];
		var model = itemModel.getModel([stateName, styleType]);
		var state = el.ensureState(stateName);
		state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
	}
}
/**
*
* Set element as highlight / downplay dispatcher.
* It will be checked when element received mouseover event or from highlight action.
* It's in change of all highlight/downplay behavior of it's children.
*
* @param el
* @param el.highDownSilentOnTouch
*        In touch device, mouseover event will be trigger on touchstart event
*        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
*        conveniently use hoverStyle when tap on touch screen without additional
*        code for compatibility.
*        But if the chart/component has select feature, which usually also use
*        hoverStyle, there might be conflict between 'select-highlight' and
*        'hover-highlight' especially when roam is enabled (see geo for example).
*        In this case, `highDownSilentOnTouch` should be used to disable
*        hover-highlight on touch device.
* @param asDispatcher If `false`, do not set as "highDownDispatcher".
*/
function setAsHighDownDispatcher(el, asDispatcher) {
	var disable = asDispatcher === false;
	var extendedEl = el;
	if (el.highDownSilentOnTouch) extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
	if (!disable || extendedEl.__highDownDispatcher) {
		extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
		extendedEl.__highDownDispatcher = !disable;
	}
}
function isHighDownDispatcher(el) {
	return !!(el && el.__highDownDispatcher);
}
/**
* Enable component highlight/downplay features:
* + hover link (within the same name)
* + focus blur in component
*/
function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
	var ecData = getECData(el);
	ecData.componentMainType = componentModel.mainType;
	ecData.componentIndex = componentModel.componentIndex;
	ecData.componentHighDownName = componentHighDownName;
}
/**
* Support highlight/downplay record on each elements.
* For the case: hover highlight/downplay (legend, visualMap, ...) and
* user triggered highlight/downplay should not conflict.
* Only all of the highlightDigit cleared, return to normal.
* @param {string} highlightKey
* @return {number} highlightDigit
*/
function getHighlightDigit(highlightKey) {
	var highlightDigit = _highlightKeyMap[highlightKey];
	if (highlightDigit == null && _highlightNextDigit <= 32) highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
	return highlightDigit;
}
function isSelectChangePayload(payload) {
	var payloadType = payload.type;
	return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
	var payloadType = payload.type;
	return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
	var store = getSavedStates(el);
	store.normalFill = el.style.fill;
	store.normalStroke = el.style.stroke;
	var selectState = el.states.select || {};
	store.selectFill = selectState.style && selectState.style.fill || null;
	store.selectStroke = selectState.style && selectState.style.stroke || null;
}

//#endregion
//#region node_modules/zrender/lib/tool/transformPath.js
var CMD = PathProxy_default.CMD;
var points = [
	[],
	[],
	[]
];
var mathSqrt$2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m$1) {
	if (!m$1) return;
	var data = path.data;
	var len = path.len();
	var cmd;
	var nPoint;
	var i;
	var j;
	var k;
	var p;
	var M = CMD.M;
	var C = CMD.C;
	var L = CMD.L;
	var R = CMD.R;
	var A = CMD.A;
	var Q = CMD.Q;
	for (i = 0, j = 0; i < len;) {
		cmd = data[i++];
		j = i;
		nPoint = 0;
		switch (cmd) {
			case M:
				nPoint = 1;
				break;
			case L:
				nPoint = 1;
				break;
			case C:
				nPoint = 3;
				break;
			case Q:
				nPoint = 2;
				break;
			case A:
				var x = m$1[4];
				var y = m$1[5];
				var sx = mathSqrt$2(m$1[0] * m$1[0] + m$1[1] * m$1[1]);
				var sy = mathSqrt$2(m$1[2] * m$1[2] + m$1[3] * m$1[3]);
				var angle = mathAtan2(-m$1[1] / sy, m$1[0] / sx);
				data[i] *= sx;
				data[i++] += x;
				data[i] *= sy;
				data[i++] += y;
				data[i++] *= sx;
				data[i++] *= sy;
				data[i++] += angle;
				data[i++] += angle;
				i += 2;
				j = i;
				break;
			case R:
				p[0] = data[i++];
				p[1] = data[i++];
				applyTransform$1(p, p, m$1);
				data[j++] = p[0];
				data[j++] = p[1];
				p[0] += data[i++];
				p[1] += data[i++];
				applyTransform$1(p, p, m$1);
				data[j++] = p[0];
				data[j++] = p[1];
		}
		for (k = 0; k < nPoint; k++) {
			var p_1 = points[k];
			p_1[0] = data[i++];
			p_1[1] = data[i++];
			applyTransform$1(p_1, p_1, m$1);
			data[j++] = p_1[0];
			data[j++] = p_1[1];
		}
	}
	path.increaseVersion();
}

//#endregion
//#region node_modules/zrender/lib/tool/path.js
init_tslib_es6();
var mathSqrt$1 = Math.sqrt;
var mathSin$1 = Math.sin;
var mathCos$1 = Math.cos;
var PI$2 = Math.PI;
function vMag(v) {
	return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
	return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
}
function vAngle(u, v) {
	return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	var psi = psiDeg * (PI$2 / 180);
	var xp = mathCos$1(psi) * (x1 - x2) / 2 + mathSin$1(psi) * (y1 - y2) / 2;
	var yp = -1 * mathSin$1(psi) * (x1 - x2) / 2 + mathCos$1(psi) * (y1 - y2) / 2;
	var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
	if (lambda > 1) {
		rx *= mathSqrt$1(lambda);
		ry *= mathSqrt$1(lambda);
	}
	var f = (fa === fs ? -1 : 1) * mathSqrt$1((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
	var cxp = f * rx * yp / ry;
	var cyp = f * -ry * xp / rx;
	var cx = (x1 + x2) / 2 + mathCos$1(psi) * cxp - mathSin$1(psi) * cyp;
	var cy = (y1 + y2) / 2 + mathSin$1(psi) * cxp + mathCos$1(psi) * cyp;
	var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	var dTheta = vAngle(u, v);
	if (vRatio(u, v) <= -1) dTheta = PI$2;
	if (vRatio(u, v) >= 1) dTheta = 0;
	if (dTheta < 0) {
		var n = Math.round(dTheta / PI$2 * 1e6) / 1e6;
		dTheta = PI$2 * 2 + n % 2 * PI$2;
	}
	path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi;
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
	var path = new PathProxy_default();
	if (!data) return path;
	var cpx = 0;
	var cpy = 0;
	var subpathX = cpx;
	var subpathY = cpy;
	var prevCmd;
	var CMD$1 = PathProxy_default.CMD;
	var cmdList = data.match(commandReg);
	if (!cmdList) return path;
	for (var l = 0; l < cmdList.length; l++) {
		var cmdText = cmdList[l];
		var cmdStr = cmdText.charAt(0);
		var cmd = void 0;
		var p = cmdText.match(numberReg) || [];
		var pLen = p.length;
		for (var i = 0; i < pLen; i++) p[i] = parseFloat(p[i]);
		var off = 0;
		while (off < pLen) {
			var ctlPtx = void 0;
			var ctlPty = void 0;
			var rx = void 0;
			var ry = void 0;
			var psi = void 0;
			var fa = void 0;
			var fs = void 0;
			var x1 = cpx;
			var y1 = cpy;
			var len = void 0;
			var pathData = void 0;
			switch (cmdStr) {
				case "l":
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$1.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "L":
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$1.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "m":
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$1.M;
					path.addData(cmd, cpx, cpy);
					subpathX = cpx;
					subpathY = cpy;
					cmdStr = "l";
					break;
				case "M":
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$1.M;
					path.addData(cmd, cpx, cpy);
					subpathX = cpx;
					subpathY = cpy;
					cmdStr = "L";
					break;
				case "h":
					cpx += p[off++];
					cmd = CMD$1.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "H":
					cpx = p[off++];
					cmd = CMD$1.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "v":
					cpy += p[off++];
					cmd = CMD$1.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "V":
					cpy = p[off++];
					cmd = CMD$1.L;
					path.addData(cmd, cpx, cpy);
					break;
				case "C":
					cmd = CMD$1.C;
					path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
					cpx = p[off - 2];
					cpy = p[off - 1];
					break;
				case "c":
					cmd = CMD$1.C;
					path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
					cpx += p[off - 2];
					cpy += p[off - 1];
					break;
				case "S":
					ctlPtx = cpx;
					ctlPty = cpy;
					len = path.len();
					pathData = path.data;
					if (prevCmd === CMD$1.C) {
						ctlPtx += cpx - pathData[len - 4];
						ctlPty += cpy - pathData[len - 3];
					}
					cmd = CMD$1.C;
					x1 = p[off++];
					y1 = p[off++];
					cpx = p[off++];
					cpy = p[off++];
					path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
					break;
				case "s":
					ctlPtx = cpx;
					ctlPty = cpy;
					len = path.len();
					pathData = path.data;
					if (prevCmd === CMD$1.C) {
						ctlPtx += cpx - pathData[len - 4];
						ctlPty += cpy - pathData[len - 3];
					}
					cmd = CMD$1.C;
					x1 = cpx + p[off++];
					y1 = cpy + p[off++];
					cpx += p[off++];
					cpy += p[off++];
					path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
					break;
				case "Q":
					x1 = p[off++];
					y1 = p[off++];
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$1.Q;
					path.addData(cmd, x1, y1, cpx, cpy);
					break;
				case "q":
					x1 = p[off++] + cpx;
					y1 = p[off++] + cpy;
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$1.Q;
					path.addData(cmd, x1, y1, cpx, cpy);
					break;
				case "T":
					ctlPtx = cpx;
					ctlPty = cpy;
					len = path.len();
					pathData = path.data;
					if (prevCmd === CMD$1.Q) {
						ctlPtx += cpx - pathData[len - 4];
						ctlPty += cpy - pathData[len - 3];
					}
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$1.Q;
					path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
					break;
				case "t":
					ctlPtx = cpx;
					ctlPty = cpy;
					len = path.len();
					pathData = path.data;
					if (prevCmd === CMD$1.Q) {
						ctlPtx += cpx - pathData[len - 4];
						ctlPty += cpy - pathData[len - 3];
					}
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$1.Q;
					path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
					break;
				case "A":
					rx = p[off++];
					ry = p[off++];
					psi = p[off++];
					fa = p[off++];
					fs = p[off++];
					x1 = cpx, y1 = cpy;
					cpx = p[off++];
					cpy = p[off++];
					cmd = CMD$1.A;
					processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
					break;
				case "a":
					rx = p[off++];
					ry = p[off++];
					psi = p[off++];
					fa = p[off++];
					fs = p[off++];
					x1 = cpx, y1 = cpy;
					cpx += p[off++];
					cpy += p[off++];
					cmd = CMD$1.A;
					processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
					break;
			}
		}
		if (cmdStr === "z" || cmdStr === "Z") {
			cmd = CMD$1.Z;
			path.addData(cmd);
			cpx = subpathX;
			cpy = subpathY;
		}
		prevCmd = cmd;
	}
	path.toStatic();
	return path;
}
var SVGPath = function(_super) {
	__extends(SVGPath$1, _super);
	function SVGPath$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	SVGPath$1.prototype.applyTransform = function(m$1) {};
	return SVGPath$1;
}(Path_default);
function isPathProxy(path) {
	return path.setData != null;
}
function createPathOptions(str, opts) {
	var pathProxy = createPathProxyFromString(str);
	var innerOpts = extend({}, opts);
	innerOpts.buildPath = function(path) {
		var beProxy = isPathProxy(path);
		if (beProxy && path.canSave()) {
			path.appendPath(pathProxy);
			var ctx = path.getContext();
			if (ctx) path.rebuildPath(ctx, 1);
		} else {
			var ctx = beProxy ? path.getContext() : path;
			if (ctx) pathProxy.rebuildPath(ctx, 1);
		}
	};
	innerOpts.applyTransform = function(m$1) {
		transformPath(pathProxy, m$1);
		this.dirtyShape();
	};
	return innerOpts;
}
function createFromString(str, opts) {
	return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
	var innerOpts = createPathOptions(str, defaultOpts);
	return function(_super) {
		__extends(Sub, _super);
		function Sub(opts) {
			var _this = _super.call(this, opts) || this;
			_this.applyTransform = innerOpts.applyTransform;
			_this.buildPath = innerOpts.buildPath;
			return _this;
		}
		return Sub;
	}(SVGPath);
}
function mergePath$1(pathEls, opts) {
	var pathList = [];
	var len = pathEls.length;
	for (var i = 0; i < len; i++) {
		var pathEl = pathEls[i];
		pathList.push(pathEl.getUpdatedPathProxy(true));
	}
	var pathBundle = new Path_default(opts);
	pathBundle.createPathProxy();
	pathBundle.buildPath = function(path) {
		if (isPathProxy(path)) {
			path.appendPath(pathList);
			var ctx = path.getContext();
			if (ctx) path.rebuildPath(ctx, 1);
		}
	};
	return pathBundle;
}

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Circle.js
init_tslib_es6();
var CircleShape = function() {
	function CircleShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r = 0;
	}
	return CircleShape$1;
}();
var Circle = function(_super) {
	__extends(Circle$1, _super);
	function Circle$1(opts) {
		return _super.call(this, opts) || this;
	}
	Circle$1.prototype.getDefaultShape = function() {
		return new CircleShape();
	};
	Circle$1.prototype.buildPath = function(ctx, shape) {
		ctx.moveTo(shape.cx + shape.r, shape.cy);
		ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
	};
	return Circle$1;
}(Path_default);
Circle.prototype.type = "circle";
var Circle_default = Circle;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Ellipse.js
init_tslib_es6();
var EllipseShape = function() {
	function EllipseShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.rx = 0;
		this.ry = 0;
	}
	return EllipseShape$1;
}();
var Ellipse = function(_super) {
	__extends(Ellipse$1, _super);
	function Ellipse$1(opts) {
		return _super.call(this, opts) || this;
	}
	Ellipse$1.prototype.getDefaultShape = function() {
		return new EllipseShape();
	};
	Ellipse$1.prototype.buildPath = function(ctx, shape) {
		var k = .5522848;
		var x = shape.cx;
		var y = shape.cy;
		var a = shape.rx;
		var b = shape.ry;
		var ox = a * k;
		var oy = b * k;
		ctx.moveTo(x - a, y);
		ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
		ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
		ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
		ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
		ctx.closePath();
	};
	return Ellipse$1;
}(Path_default);
Ellipse.prototype.type = "ellipse";
var Ellipse_default = Ellipse;

//#endregion
//#region node_modules/zrender/lib/graphic/helper/roundSector.js
var PI$1 = Math.PI;
var PI2 = PI$1 * 2;
var mathSin = Math.sin;
var mathCos = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs$2 = Math.abs;
var mathSqrt = Math.sqrt;
var mathMax$2 = Math.max;
var mathMin$2 = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	var dx10 = x1 - x0;
	var dy10 = y1 - y0;
	var dx32 = x3 - x2;
	var dy32 = y3 - y2;
	var t = dy32 * dx10 - dx32 * dy10;
	if (t * t < e) return;
	t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
	return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
	var x01 = x0 - x1;
	var y01 = y0 - y1;
	var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
	var ox = lo * y01;
	var oy = -lo * x01;
	var x11 = x0 + ox;
	var y11 = y0 + oy;
	var x10 = x1 + ox;
	var y10 = y1 + oy;
	var x00 = (x11 + x10) / 2;
	var y00 = (y11 + y10) / 2;
	var dx = x10 - x11;
	var dy = y10 - y11;
	var d2 = dx * dx + dy * dy;
	var r = radius - cr;
	var s = x11 * y10 - x10 * y11;
	var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$2(0, r * r * d2 - s * s));
	var cx0 = (s * dy - dx * d) / d2;
	var cy0 = (-s * dx - dy * d) / d2;
	var cx1 = (s * dy + dx * d) / d2;
	var cy1 = (-s * dx + dy * d) / d2;
	var dx0 = cx0 - x00;
	var dy0 = cy0 - y00;
	var dx1 = cx1 - x00;
	var dy1 = cy1 - y00;
	if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
		cx0 = cx1;
		cy0 = cy1;
	}
	return {
		cx: cx0,
		cy: cy0,
		x0: -ox,
		y0: -oy,
		x1: cx0 * (radius / r - 1),
		y1: cy0 * (radius / r - 1)
	};
}
function normalizeCornerRadius(cr) {
	var arr;
	if (isArray(cr)) {
		var len = cr.length;
		if (!len) return cr;
		if (len === 1) arr = [
			cr[0],
			cr[0],
			0,
			0
		];
		else if (len === 2) arr = [
			cr[0],
			cr[0],
			cr[1],
			cr[1]
		];
		else if (len === 3) arr = cr.concat(cr[2]);
		else arr = cr;
	} else arr = [
		cr,
		cr,
		cr,
		cr
	];
	return arr;
}
function buildPath$1(ctx, shape) {
	var _a$1;
	var radius = mathMax$2(shape.r, 0);
	var innerRadius = mathMax$2(shape.r0 || 0, 0);
	var hasRadius = radius > 0;
	if (!hasRadius && !(innerRadius > 0)) return;
	if (!hasRadius) {
		radius = innerRadius;
		innerRadius = 0;
	}
	if (innerRadius > radius) {
		var tmp = radius;
		radius = innerRadius;
		innerRadius = tmp;
	}
	var startAngle = shape.startAngle, endAngle = shape.endAngle;
	if (isNaN(startAngle) || isNaN(endAngle)) return;
	var cx = shape.cx, cy = shape.cy;
	var clockwise = !!shape.clockwise;
	var arc = mathAbs$2(endAngle - startAngle);
	var mod = arc > PI2 && arc % PI2;
	mod > e && (arc = mod);
	if (!(radius > e)) ctx.moveTo(cx, cy);
	else if (arc > PI2 - e) {
		ctx.moveTo(cx + radius * mathCos(startAngle), cy + radius * mathSin(startAngle));
		ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
		if (innerRadius > e) {
			ctx.moveTo(cx + innerRadius * mathCos(endAngle), cy + innerRadius * mathSin(endAngle));
			ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
		}
	} else {
		var icrStart = void 0;
		var icrEnd = void 0;
		var ocrStart = void 0;
		var ocrEnd = void 0;
		var ocrs = void 0;
		var ocre = void 0;
		var icrs = void 0;
		var icre = void 0;
		var ocrMax = void 0;
		var icrMax = void 0;
		var limitedOcrMax = void 0;
		var limitedIcrMax = void 0;
		var xre = void 0;
		var yre = void 0;
		var xirs = void 0;
		var yirs = void 0;
		var xrs = radius * mathCos(startAngle);
		var yrs = radius * mathSin(startAngle);
		var xire = innerRadius * mathCos(endAngle);
		var yire = innerRadius * mathSin(endAngle);
		var hasArc = arc > e;
		if (hasArc) {
			var cornerRadius = shape.cornerRadius;
			if (cornerRadius) _a$1 = normalizeCornerRadius(cornerRadius), icrStart = _a$1[0], icrEnd = _a$1[1], ocrStart = _a$1[2], ocrEnd = _a$1[3];
			var halfRd = mathAbs$2(radius - innerRadius) / 2;
			ocrs = mathMin$2(halfRd, ocrStart);
			ocre = mathMin$2(halfRd, ocrEnd);
			icrs = mathMin$2(halfRd, icrStart);
			icre = mathMin$2(halfRd, icrEnd);
			limitedOcrMax = ocrMax = mathMax$2(ocrs, ocre);
			limitedIcrMax = icrMax = mathMax$2(icrs, icre);
			if (ocrMax > e || icrMax > e) {
				xre = radius * mathCos(endAngle);
				yre = radius * mathSin(endAngle);
				xirs = innerRadius * mathCos(startAngle);
				yirs = innerRadius * mathSin(startAngle);
				if (arc < PI$1) {
					var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
					if (it_1) {
						var x0 = xrs - it_1[0];
						var y0 = yrs - it_1[1];
						var x1 = xre - it_1[0];
						var y1 = yre - it_1[1];
						var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
						var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
						limitedOcrMax = mathMin$2(ocrMax, (radius - b) / (a + 1));
						limitedIcrMax = mathMin$2(icrMax, (innerRadius - b) / (a - 1));
					}
				}
			}
		}
		if (!hasArc) ctx.moveTo(cx + xrs, cy + yrs);
		else if (limitedOcrMax > e) {
			var crStart = mathMin$2(ocrStart, limitedOcrMax);
			var crEnd = mathMin$2(ocrEnd, limitedOcrMax);
			var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
			var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
			ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
			if (limitedOcrMax < ocrMax && crStart === crEnd) ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
			else {
				crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
				ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
				crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
			}
		} else {
			ctx.moveTo(cx + xrs, cy + yrs);
			ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
		}
		if (!(innerRadius > e) || !hasArc) ctx.lineTo(cx + xire, cy + yire);
		else if (limitedIcrMax > e) {
			var crStart = mathMin$2(icrStart, limitedIcrMax);
			var crEnd = mathMin$2(icrEnd, limitedIcrMax);
			var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
			var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
			ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
			if (limitedIcrMax < icrMax && crStart === crEnd) ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
			else {
				crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
				ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
				crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
			}
		} else {
			ctx.lineTo(cx + xire, cy + yire);
			ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
		}
	}
	ctx.closePath();
}

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Sector.js
init_tslib_es6();
var SectorShape = function() {
	function SectorShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r0 = 0;
		this.r = 0;
		this.startAngle = 0;
		this.endAngle = Math.PI * 2;
		this.clockwise = true;
		this.cornerRadius = 0;
	}
	return SectorShape$1;
}();
var Sector = function(_super) {
	__extends(Sector$1, _super);
	function Sector$1(opts) {
		return _super.call(this, opts) || this;
	}
	Sector$1.prototype.getDefaultShape = function() {
		return new SectorShape();
	};
	Sector$1.prototype.buildPath = function(ctx, shape) {
		buildPath$1(ctx, shape);
	};
	Sector$1.prototype.isZeroArea = function() {
		return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
	};
	return Sector$1;
}(Path_default);
Sector.prototype.type = "sector";
var Sector_default = Sector;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Ring.js
init_tslib_es6();
var RingShape = function() {
	function RingShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r = 0;
		this.r0 = 0;
	}
	return RingShape$1;
}();
var Ring = function(_super) {
	__extends(Ring$1, _super);
	function Ring$1(opts) {
		return _super.call(this, opts) || this;
	}
	Ring$1.prototype.getDefaultShape = function() {
		return new RingShape();
	};
	Ring$1.prototype.buildPath = function(ctx, shape) {
		var x = shape.cx;
		var y = shape.cy;
		var PI2$1 = Math.PI * 2;
		ctx.moveTo(x + shape.r, y);
		ctx.arc(x, y, shape.r, 0, PI2$1, false);
		ctx.moveTo(x + shape.r0, y);
		ctx.arc(x, y, shape.r0, 0, PI2$1, true);
	};
	return Ring$1;
}(Path_default);
Ring.prototype.type = "ring";
var Ring_default = Ring;

//#endregion
//#region node_modules/zrender/lib/graphic/helper/smoothBezier.js
function smoothBezier(points$1, smooth, isLoop, constraint) {
	var cps = [];
	var v = [];
	var v1 = [];
	var v2 = [];
	var prevPoint;
	var nextPoint;
	var min$1;
	var max$1;
	if (constraint) {
		min$1 = [Infinity, Infinity];
		max$1 = [-Infinity, -Infinity];
		for (var i = 0, len = points$1.length; i < len; i++) {
			min(min$1, min$1, points$1[i]);
			max(max$1, max$1, points$1[i]);
		}
		min(min$1, min$1, constraint[0]);
		max(max$1, max$1, constraint[1]);
	}
	for (var i = 0, len = points$1.length; i < len; i++) {
		var point = points$1[i];
		if (isLoop) {
			prevPoint = points$1[i ? i - 1 : len - 1];
			nextPoint = points$1[(i + 1) % len];
		} else if (i === 0 || i === len - 1) {
			cps.push(clone$1(points$1[i]));
			continue;
		} else {
			prevPoint = points$1[i - 1];
			nextPoint = points$1[i + 1];
		}
		sub(v, nextPoint, prevPoint);
		scale$1(v, v, smooth);
		var d0 = distance(point, prevPoint);
		var d1 = distance(point, nextPoint);
		var sum = d0 + d1;
		if (sum !== 0) {
			d0 /= sum;
			d1 /= sum;
		}
		scale$1(v1, v, -d0);
		scale$1(v2, v, d1);
		var cp0 = add([], point, v1);
		var cp1 = add([], point, v2);
		if (constraint) {
			max(cp0, cp0, min$1);
			min(cp0, cp0, max$1);
			max(cp1, cp1, min$1);
			min(cp1, cp1, max$1);
		}
		cps.push(cp0);
		cps.push(cp1);
	}
	if (isLoop) cps.push(cps.shift());
	return cps;
}

//#endregion
//#region node_modules/zrender/lib/graphic/helper/poly.js
function buildPath(ctx, shape, closePath) {
	var smooth = shape.smooth;
	var points$1 = shape.points;
	if (points$1 && points$1.length >= 2) {
		if (smooth) {
			var controlPoints = smoothBezier(points$1, smooth, closePath, shape.smoothConstraint);
			ctx.moveTo(points$1[0][0], points$1[0][1]);
			var len = points$1.length;
			for (var i = 0; i < (closePath ? len : len - 1); i++) {
				var cp1 = controlPoints[i * 2];
				var cp2 = controlPoints[i * 2 + 1];
				var p = points$1[(i + 1) % len];
				ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
			}
		} else {
			ctx.moveTo(points$1[0][0], points$1[0][1]);
			for (var i = 1, l = points$1.length; i < l; i++) ctx.lineTo(points$1[i][0], points$1[i][1]);
		}
		closePath && ctx.closePath();
	}
}

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Polygon.js
init_tslib_es6();
var PolygonShape = function() {
	function PolygonShape$1() {
		this.points = null;
		this.smooth = 0;
		this.smoothConstraint = null;
	}
	return PolygonShape$1;
}();
var Polygon = function(_super) {
	__extends(Polygon$1, _super);
	function Polygon$1(opts) {
		return _super.call(this, opts) || this;
	}
	Polygon$1.prototype.getDefaultShape = function() {
		return new PolygonShape();
	};
	Polygon$1.prototype.buildPath = function(ctx, shape) {
		buildPath(ctx, shape, true);
	};
	return Polygon$1;
}(Path_default);
Polygon.prototype.type = "polygon";
var Polygon_default = Polygon;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Polyline.js
init_tslib_es6();
var PolylineShape = function() {
	function PolylineShape$1() {
		this.points = null;
		this.percent = 1;
		this.smooth = 0;
		this.smoothConstraint = null;
	}
	return PolylineShape$1;
}();
var Polyline = function(_super) {
	__extends(Polyline$1, _super);
	function Polyline$1(opts) {
		return _super.call(this, opts) || this;
	}
	Polyline$1.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	};
	Polyline$1.prototype.getDefaultShape = function() {
		return new PolylineShape();
	};
	Polyline$1.prototype.buildPath = function(ctx, shape) {
		buildPath(ctx, shape, false);
	};
	return Polyline$1;
}(Path_default);
Polyline.prototype.type = "polyline";
var Polyline_default = Polyline;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Line.js
init_tslib_es6();
var subPixelOptimizeOutputShape = {};
var LineShape = function() {
	function LineShape$1() {
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
		this.percent = 1;
	}
	return LineShape$1;
}();
var Line = function(_super) {
	__extends(Line$1, _super);
	function Line$1(opts) {
		return _super.call(this, opts) || this;
	}
	Line$1.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	};
	Line$1.prototype.getDefaultShape = function() {
		return new LineShape();
	};
	Line$1.prototype.buildPath = function(ctx, shape) {
		var x1;
		var y1;
		var x2;
		var y2;
		if (this.subPixelOptimize) {
			var optimizedShape = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
			x1 = optimizedShape.x1;
			y1 = optimizedShape.y1;
			x2 = optimizedShape.x2;
			y2 = optimizedShape.y2;
		} else {
			x1 = shape.x1;
			y1 = shape.y1;
			x2 = shape.x2;
			y2 = shape.y2;
		}
		var percent = shape.percent;
		if (percent === 0) return;
		ctx.moveTo(x1, y1);
		if (percent < 1) {
			x2 = x1 * (1 - percent) + x2 * percent;
			y2 = y1 * (1 - percent) + y2 * percent;
		}
		ctx.lineTo(x2, y2);
	};
	Line$1.prototype.pointAt = function(p) {
		var shape = this.shape;
		return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
	};
	return Line$1;
}(Path_default);
Line.prototype.type = "line";
var Line_default = Line;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/BezierCurve.js
init_tslib_es6();
var out = [];
var BezierCurveShape = function() {
	function BezierCurveShape$1() {
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
		this.cpx1 = 0;
		this.cpy1 = 0;
		this.percent = 1;
	}
	return BezierCurveShape$1;
}();
function someVectorAt(shape, t, isTangent) {
	var cpx2 = shape.cpx2;
	var cpy2 = shape.cpy2;
	if (cpx2 != null || cpy2 != null) return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
	else return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
}
var BezierCurve = function(_super) {
	__extends(BezierCurve$1, _super);
	function BezierCurve$1(opts) {
		return _super.call(this, opts) || this;
	}
	BezierCurve$1.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	};
	BezierCurve$1.prototype.getDefaultShape = function() {
		return new BezierCurveShape();
	};
	BezierCurve$1.prototype.buildPath = function(ctx, shape) {
		var x1 = shape.x1;
		var y1 = shape.y1;
		var x2 = shape.x2;
		var y2 = shape.y2;
		var cpx1 = shape.cpx1;
		var cpy1 = shape.cpy1;
		var cpx2 = shape.cpx2;
		var cpy2 = shape.cpy2;
		var percent = shape.percent;
		if (percent === 0) return;
		ctx.moveTo(x1, y1);
		if (cpx2 == null || cpy2 == null) {
			if (percent < 1) {
				quadraticSubdivide(x1, cpx1, x2, percent, out);
				cpx1 = out[1];
				x2 = out[2];
				quadraticSubdivide(y1, cpy1, y2, percent, out);
				cpy1 = out[1];
				y2 = out[2];
			}
			ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
		} else {
			if (percent < 1) {
				cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
				cpx1 = out[1];
				cpx2 = out[2];
				x2 = out[3];
				cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
				cpy1 = out[1];
				cpy2 = out[2];
				y2 = out[3];
			}
			ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
		}
	};
	BezierCurve$1.prototype.pointAt = function(t) {
		return someVectorAt(this.shape, t, false);
	};
	BezierCurve$1.prototype.tangentAt = function(t) {
		var p = someVectorAt(this.shape, t, true);
		return normalize$1(p, p);
	};
	return BezierCurve$1;
}(Path_default);
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve_default = BezierCurve;

//#endregion
//#region node_modules/zrender/lib/graphic/shape/Arc.js
init_tslib_es6();
var ArcShape = function() {
	function ArcShape$1() {
		this.cx = 0;
		this.cy = 0;
		this.r = 0;
		this.startAngle = 0;
		this.endAngle = Math.PI * 2;
		this.clockwise = true;
	}
	return ArcShape$1;
}();
var Arc = function(_super) {
	__extends(Arc$1, _super);
	function Arc$1(opts) {
		return _super.call(this, opts) || this;
	}
	Arc$1.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		};
	};
	Arc$1.prototype.getDefaultShape = function() {
		return new ArcShape();
	};
	Arc$1.prototype.buildPath = function(ctx, shape) {
		var x = shape.cx;
		var y = shape.cy;
		var r = Math.max(shape.r, 0);
		var startAngle = shape.startAngle;
		var endAngle = shape.endAngle;
		var clockwise = shape.clockwise;
		var unitX = Math.cos(startAngle);
		var unitY = Math.sin(startAngle);
		ctx.moveTo(unitX * r + x, unitY * r + y);
		ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	};
	return Arc$1;
}(Path_default);
Arc.prototype.type = "arc";
var Arc_default = Arc;

//#endregion
//#region node_modules/zrender/lib/graphic/Gradient.js
var Gradient = function() {
	function Gradient$1(colorStops) {
		this.colorStops = colorStops || [];
	}
	Gradient$1.prototype.addColorStop = function(offset, color$2) {
		this.colorStops.push({
			offset,
			color: color$2
		});
	};
	return Gradient$1;
}();
var Gradient_default = Gradient;

//#endregion
//#region node_modules/zrender/lib/graphic/LinearGradient.js
init_tslib_es6();
var LinearGradient = function(_super) {
	__extends(LinearGradient$1, _super);
	function LinearGradient$1(x, y, x2, y2, colorStops, globalCoord) {
		var _this = _super.call(this, colorStops) || this;
		_this.x = x == null ? 0 : x;
		_this.y = y == null ? 0 : y;
		_this.x2 = x2 == null ? 1 : x2;
		_this.y2 = y2 == null ? 0 : y2;
		_this.type = "linear";
		_this.global = globalCoord || false;
		return _this;
	}
	return LinearGradient$1;
}(Gradient_default);
var LinearGradient_default = LinearGradient;

//#endregion
//#region node_modules/zrender/lib/graphic/RadialGradient.js
init_tslib_es6();
var RadialGradient = function(_super) {
	__extends(RadialGradient$1, _super);
	function RadialGradient$1(x, y, r, colorStops, globalCoord) {
		var _this = _super.call(this, colorStops) || this;
		_this.x = x == null ? .5 : x;
		_this.y = y == null ? .5 : y;
		_this.r = r == null ? .5 : r;
		_this.type = "radial";
		_this.global = globalCoord || false;
		return _this;
	}
	return RadialGradient$1;
}(Gradient_default);
var RadialGradient_default = RadialGradient;

//#endregion
//#region node_modules/zrender/lib/core/OrientedBoundingRect.js
var mathMin$1 = Math.min;
var mathMax$1 = Math.max;
var mathAbs$1 = Math.abs;
var _extent = [0, 0];
var _extent2 = [0, 0];
var _intersectCtx = createIntersectContext();
var _minTv = _intersectCtx.minTv;
var _maxTv = _intersectCtx.maxTv;
var OrientedBoundingRect = function() {
	function OrientedBoundingRect$1(rect, transform) {
		this._corners = [];
		this._axes = [];
		this._origin = [0, 0];
		for (var i = 0; i < 4; i++) this._corners[i] = new Point_default();
		for (var i = 0; i < 2; i++) this._axes[i] = new Point_default();
		if (rect) this.fromBoundingRect(rect, transform);
	}
	OrientedBoundingRect$1.prototype.fromBoundingRect = function(rect, transform) {
		var corners = this._corners;
		var axes = this._axes;
		var x = rect.x;
		var y = rect.y;
		var x2 = x + rect.width;
		var y2 = y + rect.height;
		corners[0].set(x, y);
		corners[1].set(x2, y);
		corners[2].set(x2, y2);
		corners[3].set(x, y2);
		if (transform) for (var i = 0; i < 4; i++) corners[i].transform(transform);
		Point_default.sub(axes[0], corners[1], corners[0]);
		Point_default.sub(axes[1], corners[3], corners[0]);
		axes[0].normalize();
		axes[1].normalize();
		for (var i = 0; i < 2; i++) this._origin[i] = axes[i].dot(corners[0]);
	};
	OrientedBoundingRect$1.prototype.intersect = function(other, mtv, opt) {
		var overlapped = true;
		var noMtv = !mtv;
		if (mtv) Point_default.set(mtv, 0, 0);
		_intersectCtx.reset(opt, !noMtv);
		if (!this._intersectCheckOneSide(this, other, noMtv, 1)) {
			overlapped = false;
			if (noMtv) return overlapped;
		}
		if (!this._intersectCheckOneSide(other, this, noMtv, -1)) {
			overlapped = false;
			if (noMtv) return overlapped;
		}
		if (!noMtv && !_intersectCtx.negativeSize) Point_default.copy(mtv, overlapped ? _intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv : _maxTv);
		return overlapped;
	};
	OrientedBoundingRect$1.prototype._intersectCheckOneSide = function(self, other, noMtv, inverse) {
		var overlapped = true;
		for (var i = 0; i < 2; i++) {
			var axis = self._axes[i];
			self._getProjMinMaxOnAxis(i, self._corners, _extent);
			self._getProjMinMaxOnAxis(i, other._corners, _extent2);
			if (_intersectCtx.negativeSize || _extent[1] < _extent2[0] || _extent[0] > _extent2[1]) {
				overlapped = false;
				if (_intersectCtx.negativeSize || noMtv) return overlapped;
				var dist0 = mathAbs$1(_extent2[0] - _extent[1]);
				var dist1 = mathAbs$1(_extent[0] - _extent2[1]);
				if (mathMin$1(dist0, dist1) > _maxTv.len()) if (dist0 < dist1) Point_default.scale(_maxTv, axis, -dist0 * inverse);
				else Point_default.scale(_maxTv, axis, dist1 * inverse);
			} else if (!noMtv) {
				var dist0 = mathAbs$1(_extent2[0] - _extent[1]);
				var dist1 = mathAbs$1(_extent[0] - _extent2[1]);
				if (_intersectCtx.useDir || mathMin$1(dist0, dist1) < _minTv.len()) {
					if (dist0 < dist1 || !_intersectCtx.bidirectional) {
						Point_default.scale(_minTv, axis, dist0 * inverse);
						if (_intersectCtx.useDir) _intersectCtx.calcDirMTV();
					}
					if (dist0 >= dist1 || !_intersectCtx.bidirectional) {
						Point_default.scale(_minTv, axis, -dist1 * inverse);
						if (_intersectCtx.useDir) _intersectCtx.calcDirMTV();
					}
				}
			}
		}
		return overlapped;
	};
	OrientedBoundingRect$1.prototype._getProjMinMaxOnAxis = function(dim, corners, out$1) {
		var axis = this._axes[dim];
		var origin = this._origin;
		var proj = corners[0].dot(axis) + origin[dim];
		var min$1 = proj;
		var max$1 = proj;
		for (var i = 1; i < corners.length; i++) {
			var proj_1 = corners[i].dot(axis) + origin[dim];
			min$1 = mathMin$1(proj_1, min$1);
			max$1 = mathMax$1(proj_1, max$1);
		}
		out$1[0] = min$1 + _intersectCtx.touchThreshold;
		out$1[1] = max$1 - _intersectCtx.touchThreshold;
		_intersectCtx.negativeSize = out$1[1] < out$1[0];
	};
	return OrientedBoundingRect$1;
}();
var OrientedBoundingRect_default = OrientedBoundingRect;

//#endregion
//#region node_modules/zrender/lib/graphic/IncrementalDisplayable.js
init_tslib_es6();
var m = [];
var IncrementalDisplayable = function(_super) {
	__extends(IncrementalDisplayable$1, _super);
	function IncrementalDisplayable$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.notClear = true;
		_this.incremental = true;
		_this._displayables = [];
		_this._temporaryDisplayables = [];
		_this._cursor = 0;
		return _this;
	}
	IncrementalDisplayable$1.prototype.traverse = function(cb, context) {
		cb.call(context, this);
	};
	IncrementalDisplayable$1.prototype.useStyle = function() {
		this.style = {};
	};
	IncrementalDisplayable$1.prototype.getCursor = function() {
		return this._cursor;
	};
	IncrementalDisplayable$1.prototype.innerAfterBrush = function() {
		this._cursor = this._displayables.length;
	};
	IncrementalDisplayable$1.prototype.clearDisplaybles = function() {
		this._displayables = [];
		this._temporaryDisplayables = [];
		this._cursor = 0;
		this.markRedraw();
		this.notClear = false;
	};
	IncrementalDisplayable$1.prototype.clearTemporalDisplayables = function() {
		this._temporaryDisplayables = [];
	};
	IncrementalDisplayable$1.prototype.addDisplayable = function(displayable, notPersistent) {
		if (notPersistent) this._temporaryDisplayables.push(displayable);
		else this._displayables.push(displayable);
		this.markRedraw();
	};
	IncrementalDisplayable$1.prototype.addDisplayables = function(displayables, notPersistent) {
		notPersistent = notPersistent || false;
		for (var i = 0; i < displayables.length; i++) this.addDisplayable(displayables[i], notPersistent);
	};
	IncrementalDisplayable$1.prototype.getDisplayables = function() {
		return this._displayables;
	};
	IncrementalDisplayable$1.prototype.getTemporalDisplayables = function() {
		return this._temporaryDisplayables;
	};
	IncrementalDisplayable$1.prototype.eachPendingDisplayable = function(cb) {
		for (var i = this._cursor; i < this._displayables.length; i++) cb && cb(this._displayables[i]);
		for (var i = 0; i < this._temporaryDisplayables.length; i++) cb && cb(this._temporaryDisplayables[i]);
	};
	IncrementalDisplayable$1.prototype.update = function() {
		this.updateTransform();
		for (var i = this._cursor; i < this._displayables.length; i++) {
			var displayable = this._displayables[i];
			displayable.parent = this;
			displayable.update();
			displayable.parent = null;
		}
		for (var i = 0; i < this._temporaryDisplayables.length; i++) {
			var displayable = this._temporaryDisplayables[i];
			displayable.parent = this;
			displayable.update();
			displayable.parent = null;
		}
	};
	IncrementalDisplayable$1.prototype.getBoundingRect = function() {
		if (!this._rect) {
			var rect = new BoundingRect_default(Infinity, Infinity, -Infinity, -Infinity);
			for (var i = 0; i < this._displayables.length; i++) {
				var displayable = this._displayables[i];
				var childRect = displayable.getBoundingRect().clone();
				if (displayable.needLocalTransform()) childRect.applyTransform(displayable.getLocalTransform(m));
				rect.union(childRect);
			}
			this._rect = rect;
		}
		return this._rect;
	};
	IncrementalDisplayable$1.prototype.contain = function(x, y) {
		var localPos = this.transformCoordToLocal(x, y);
		if (this.getBoundingRect().contain(localPos[0], localPos[1])) {
			for (var i = 0; i < this._displayables.length; i++) if (this._displayables[i].contain(x, y)) return true;
		}
		return false;
	};
	return IncrementalDisplayable$1;
}(Displayable_default);
var IncrementalDisplayable_default = IncrementalDisplayable;

//#endregion
//#region node_modules/echarts/lib/animation/basicTransition.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var transitionStore = makeInner();
/**
* Return null if animation is disabled.
*/
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
	var animationPayload;
	if (animatableModel && animatableModel.ecModel) {
		var updatePayload = animatableModel.ecModel.getUpdatePayload();
		animationPayload = updatePayload && updatePayload.animation;
	}
	var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
	var isUpdate = animationType === "update";
	if (animationEnabled) {
		var duration = void 0;
		var easing = void 0;
		var delay = void 0;
		if (extraOpts) {
			duration = retrieve2(extraOpts.duration, 200);
			easing = retrieve2(extraOpts.easing, "cubicOut");
			delay = 0;
		} else {
			duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
			easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
			delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
		}
		if (animationPayload) {
			animationPayload.duration != null && (duration = animationPayload.duration);
			animationPayload.easing != null && (easing = animationPayload.easing);
			animationPayload.delay != null && (delay = animationPayload.delay);
		}
		if (isFunction(delay)) delay = delay(dataIndex, extraDelayParams);
		if (isFunction(duration)) duration = duration(dataIndex);
		return {
			duration: duration || 0,
			delay,
			easing
		};
	} else return null;
}
function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
	var isFrom = false;
	var removeOpt;
	if (isFunction(dataIndex)) {
		during = cb;
		cb = dataIndex;
		dataIndex = null;
	} else if (isObject$1(dataIndex)) {
		cb = dataIndex.cb;
		during = dataIndex.during;
		isFrom = dataIndex.isFrom;
		removeOpt = dataIndex.removeOpt;
		dataIndex = dataIndex.dataIndex;
	}
	var isRemove = animationType === "leave";
	if (!isRemove) el.stopAnimation("leave");
	var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
	if (animationConfig && animationConfig.duration > 0) {
		var duration = animationConfig.duration;
		var animationDelay = animationConfig.delay;
		var animationEasing = animationConfig.easing;
		var animateConfig = {
			duration,
			delay: animationDelay || 0,
			easing: animationEasing,
			done: cb,
			force: !!cb || !!during,
			setToFinal: !isRemove,
			scope: animationType,
			during
		};
		isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
	} else {
		el.stopAnimation();
		!isFrom && el.attr(props);
		during && during(1);
		cb && cb();
	}
}
/**
* Update graphic element properties with or without animation according to the
* configuration in series.
*
* Caution: this method will stop previous animation.
* So do not use this method to one element twice before
* animation starts, unless you know what you are doing.
* @example
*     graphic.updateProps(el, {
*         position: [100, 100]
*     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
*     // Or
*     graphic.updateProps(el, {
*         position: [100, 100]
*     }, seriesModel, function () { console.log('Animation done!'); });
*/
function updateProps(el, props, animatableModel, dataIndex, cb, during) {
	animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
}
/**
* Init graphic element properties with or without animation according to the
* configuration in series.
*
* Caution: this method will stop previous animation.
* So do not use this method to one element twice before
* animation starts, unless you know what you are doing.
*/
function initProps(el, props, animatableModel, dataIndex, cb, during) {
	animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
}
/**
* If element is removed.
* It can determine if element is having remove animation.
*/
function isElementRemoved(el) {
	if (!el.__zr) return true;
	for (var i = 0; i < el.animators.length; i++) if (el.animators[i].scope === "leave") return true;
	return false;
}
/**
* Remove graphic element
*/
function removeElement(el, props, animatableModel, dataIndex, cb, during) {
	if (isElementRemoved(el)) return;
	animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
	el.removeTextContent();
	el.removeTextGuideLine();
	removeElement(el, { style: { opacity: 0 } }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el, animatableModel, dataIndex) {
	function doRemove() {
		el.parent && el.parent.remove(el);
	}
	if (!el.isGroup) fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
	else el.traverse(function(disp) {
		if (!disp.isGroup) fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
	});
}
/**
* Save old style for style transition in universalTransition module.
* It's used when element will be reused in each render.
* For chart like map, heatmap, which will always create new element.
* We don't need to save this because universalTransition can get old style from the old element
*/
function saveOldStyle(el) {
	transitionStore(el).oldStyle = el.style;
}

//#endregion
//#region node_modules/echarts/lib/util/graphic.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var graphic_exports = /* @__PURE__ */ __export({
	Arc: () => Arc_default,
	BezierCurve: () => BezierCurve_default,
	BoundingRect: () => BoundingRect_default,
	Circle: () => Circle_default,
	CompoundPath: () => CompoundPath_default,
	Ellipse: () => Ellipse_default,
	Group: () => Group_default,
	Image: () => Image_default,
	IncrementalDisplayable: () => IncrementalDisplayable_default,
	Line: () => Line_default,
	LinearGradient: () => LinearGradient_default,
	OrientedBoundingRect: () => OrientedBoundingRect_default,
	Path: () => Path_default,
	Point: () => Point_default,
	Polygon: () => Polygon_default,
	Polyline: () => Polyline_default,
	RadialGradient: () => RadialGradient_default,
	Rect: () => Rect_default,
	Ring: () => Ring_default,
	Sector: () => Sector_default,
	Text: () => Text_default,
	WH: () => WH,
	XY: () => XY,
	applyTransform: () => applyTransform,
	calcZ2Range: () => calcZ2Range,
	clipPointsByRect: () => clipPointsByRect,
	clipRectByRect: () => clipRectByRect,
	createIcon: () => createIcon,
	ensureCopyRect: () => ensureCopyRect,
	ensureCopyTransform: () => ensureCopyTransform,
	expandOrShrinkRect: () => expandOrShrinkRect,
	extendPath: () => extendPath,
	extendShape: () => extendShape,
	getShapeClass: () => getShapeClass,
	getTransform: () => getTransform,
	groupTransition: () => groupTransition,
	initProps: () => initProps,
	isBoundingRectAxisAligned: () => isBoundingRectAxisAligned,
	isElementRemoved: () => isElementRemoved,
	lineLineIntersect: () => lineLineIntersect,
	linePolygonIntersect: () => linePolygonIntersect,
	makeImage: () => makeImage,
	makePath: () => makePath,
	mergePath: () => mergePath,
	registerShape: () => registerShape,
	removeElement: () => removeElement,
	removeElementWithFadeOut: () => removeElementWithFadeOut,
	resizePath: () => resizePath,
	retrieveZInfo: () => retrieveZInfo,
	setTooltipConfig: () => setTooltipConfig,
	subPixelOptimize: () => subPixelOptimize,
	subPixelOptimizeLine: () => subPixelOptimizeLine,
	subPixelOptimizeRect: () => subPixelOptimizeRect,
	transformDirection: () => transformDirection,
	traverseElements: () => traverseElements,
	traverseUpdateZ: () => traverseUpdateZ,
	updateProps: () => updateProps
});
var _customShapeMap = {};
var XY = ["x", "y"];
var WH = ["width", "height"];
/**
* Extend shape with parameters
*/
function extendShape(opts) {
	return Path_default.extend(opts);
}
var extendPathFromString = extendFromString;
/**
* Extend path
*/
function extendPath(pathData, opts) {
	return extendPathFromString(pathData, opts);
}
/**
* Register a user defined shape.
* The shape class can be fetched by `getShapeClass`
* This method will overwrite the registered shapes, including
* the registered built-in shapes, if using the same `name`.
* The shape can be used in `custom series` and
* `graphic component` by declaring `{type: name}`.
*
* @param name
* @param ShapeClass Can be generated by `extendShape`.
*/
function registerShape(name, ShapeClass) {
	_customShapeMap[name] = ShapeClass;
}
/**
* Find shape class registered by `registerShape`. Usually used in
* fetching user defined shape.
*
* [Caution]:
* (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared
* to use user registered shapes.
* Because the built-in shape (see `getBuiltInShape`) will be registered by
* `registerShape` by default. That enables users to get both built-in
* shapes as well as the shapes belonging to themsleves. But users can overwrite
* the built-in shapes by using names like 'circle', 'rect' via calling
* `registerShape`. So the echarts inner featrues should not fetch shapes from here
* in case that it is overwritten by users, except that some features, like
* `custom series`, `graphic component`, do it deliberately.
*
* (2) In the features like `custom series`, `graphic component`, the user input
* `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic
* elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names
* are reserved names, that is, if some user registers a shape named `'image'`,
* the shape will not be used. If we intending to add some more reserved names
* in feature, that might bring break changes (disable some existing user shape
* names). But that case probably rarely happens. So we don't make more mechanism
* to resolve this issue here.
*
* @param name
* @return The shape class. If not found, return nothing.
*/
function getShapeClass(name) {
	if (_customShapeMap.hasOwnProperty(name)) return _customShapeMap[name];
}
/**
* Create a path element from path data string
* @param pathData
* @param opts
* @param rect
* @param layout 'center' or 'cover' default to be cover
*/
function makePath(pathData, opts, rect, layout$1) {
	var path = createFromString(pathData, opts);
	if (rect) {
		if (layout$1 === "center") rect = centerGraphic(rect, path.getBoundingRect());
		resizePath(path, rect);
	}
	return path;
}
/**
* Create a image element from image url
* @param imageUrl image url
* @param opts options
* @param rect constrain rect
* @param layout 'center' or 'cover'. Default to be 'cover'
*/
function makeImage(imageUrl, rect, layout$1) {
	var zrImg = new Image_default({
		style: {
			image: imageUrl,
			x: rect.x,
			y: rect.y,
			width: rect.width,
			height: rect.height
		},
		onload: function(img) {
			if (layout$1 === "center") {
				var boundingRect = {
					width: img.width,
					height: img.height
				};
				zrImg.setStyle(centerGraphic(rect, boundingRect));
			}
		}
	});
	return zrImg;
}
/**
* Get position of centered element in bounding box.
*
* @param  rect         element local bounding box
* @param  boundingRect constraint bounding box
* @return element position containing x, y, width, and height
*/
function centerGraphic(rect, boundingRect) {
	var aspect = boundingRect.width / boundingRect.height;
	var width = rect.height * aspect;
	var height;
	if (width <= rect.width) height = rect.height;
	else {
		width = rect.width;
		height = width / aspect;
	}
	var cx = rect.x + rect.width / 2;
	var cy = rect.y + rect.height / 2;
	return {
		x: cx - width / 2,
		y: cy - height / 2,
		width,
		height
	};
}
var mergePath = mergePath$1;
/**
* Resize a path to fit the rect
* @param path
* @param rect
*/
function resizePath(path, rect) {
	if (!path.applyTransform) return;
	var m$1 = path.getBoundingRect().calculateTransform(rect);
	path.applyTransform(m$1);
}
/**
* Sub pixel optimize line for canvas
*/
function subPixelOptimizeLine(shape, lineWidth) {
	subPixelOptimizeLine$1(shape, shape, { lineWidth });
	return shape;
}
/**
* Sub pixel optimize rect for canvas
*/
function subPixelOptimizeRect(shape, style) {
	subPixelOptimizeRect$1(shape, shape, style);
	return shape;
}
/**
* Sub pixel optimize for canvas
*
* @param position Coordinate, such as x, y
* @param lineWidth Should be nonnegative integer.
* @param positiveOrNegative Default false (negative).
* @return Optimized position.
*/
var subPixelOptimize = subPixelOptimize$1;
/**
* Get transform matrix of target (param target),
* in coordinate of its ancestor (param ancestor)
*
* @param target
* @param [ancestor]
*/
function getTransform(target, ancestor) {
	var mat = identity([]);
	while (target && target !== ancestor) {
		mul(mat, target.getLocalTransform(), mat);
		target = target.parent;
	}
	return mat;
}
/**
* Apply transform to an vertex.
* @param target [x, y]
* @param transform Can be:
*      + Transform matrix: like [1, 0, 0, 1, 0, 0]
*      + {position, rotation, scale}, the same as `zrender/Transformable`.
* @param invert Whether use invert matrix.
* @return [x, y]
*/
function applyTransform(target, transform, invert$1) {
	if (transform && !isArrayLike(transform)) transform = Transformable_default.getLocalTransform(transform);
	if (invert$1) transform = invert([], transform);
	return applyTransform$1([], target, transform);
}
/**
* @param direction 'left' 'right' 'top' 'bottom'
* @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]
* @param invert Whether use invert matrix.
* @return Transformed direction. 'left' 'right' 'top' 'bottom'
*/
function transformDirection(direction, transform, invert$1) {
	var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : mathAbs(2 * transform[4] / transform[0]);
	var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : mathAbs(2 * transform[4] / transform[2]);
	var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
	vertex = applyTransform(vertex, transform, invert$1);
	return mathAbs(vertex[0]) > mathAbs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el) {
	return !el.isGroup;
}
function isPath(el) {
	return el.shape != null;
}
/**
* Apply group transition animation from g1 to g2.
* If no animatableModel, no animation.
*/
function groupTransition(g1, g2, animatableModel) {
	if (!g1 || !g2) return;
	function getElMap(g) {
		var elMap = {};
		g.traverse(function(el) {
			if (isNotGroup(el) && el.anid) elMap[el.anid] = el;
		});
		return elMap;
	}
	function getAnimatableProps(el) {
		var obj = {
			x: el.x,
			y: el.y,
			rotation: el.rotation
		};
		if (isPath(el)) obj.shape = clone(el.shape);
		return obj;
	}
	var elMap1 = getElMap(g1);
	g2.traverse(function(el) {
		if (isNotGroup(el) && el.anid) {
			var oldEl = elMap1[el.anid];
			if (oldEl) {
				var newProp = getAnimatableProps(el);
				el.attr(getAnimatableProps(oldEl));
				updateProps(el, newProp, animatableModel, getECData(el).dataIndex);
			}
		}
	});
}
function clipPointsByRect(points$1, rect) {
	return map$1(points$1, function(point) {
		var x = point[0];
		x = mathMax(x, rect.x);
		x = mathMin(x, rect.x + rect.width);
		var y = point[1];
		y = mathMax(y, rect.y);
		y = mathMin(y, rect.y + rect.height);
		return [x, y];
	});
}
/**
* Return a new clipped rect. If rect size are negative, return undefined.
*/
function clipRectByRect(targetRect, rect) {
	var x = mathMax(targetRect.x, rect.x);
	var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
	var y = mathMax(targetRect.y, rect.y);
	var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);
	if (x2 >= x && y2 >= y) return {
		x,
		y,
		width: x2 - x,
		height: y2 - y
	};
}
function createIcon(iconStr, opt, rect) {
	var innerOpts = extend({ rectHover: true }, opt);
	var style = innerOpts.style = { strokeNoScale: true };
	rect = rect || {
		x: -1,
		y: -1,
		width: 2,
		height: 2
	};
	if (iconStr) return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new Image_default(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
}
/**
* Return `true` if the given line (line `a`) and the given polygon
* are intersect.
* Note that we do not count colinear as intersect here because no
* requirement for that. We could do that if required in future.
*/
function linePolygonIntersect(a1x, a1y, a2x, a2y, points$1) {
	for (var i = 0, p2 = points$1[points$1.length - 1]; i < points$1.length; i++) {
		var p = points$1[i];
		if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) return true;
		p2 = p;
	}
}
/**
* Return `true` if the given two lines (line `a` and line `b`)
* are intersect.
* Note that we do not count colinear as intersect here because no
* requirement for that. We could do that if required in future.
*/
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
	var mx = a2x - a1x;
	var my = a2y - a1y;
	var nx = b2x - b1x;
	var ny = b2y - b1y;
	var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
	if (nearZero(nmCrossProduct)) return false;
	var b1a1x = a1x - b1x;
	var b1a1y = a1y - b1y;
	var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
	if (q < 0 || q > 1) return false;
	var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
	if (p < 0 || p > 1) return false;
	return true;
}
/**
* Cross product of 2-dimension vector.
*/
function crossProduct2d(x1, y1, x2, y2) {
	return x1 * y2 - x2 * y1;
}
function nearZero(val) {
	return val <= 1e-6 && val >= -1e-6;
}
/**
* NOTE:
*  A negative-width/height rect (due to negative margins) is not supported;
*  it will be clampped to zero width/height.
*  Although negative-width/height rects can be defined reasonably following the
*  similar sense in CSS, but they are rarely used, hard to understand and complicated.
*
* @param rect Assume its width/height >= 0 if existing.
*  x/y/width/height is allowed to be NaN,
*  for the case that only x/width or y/height is intended to be computed.
* @param delta
*  If be `number[]`, should be `[top, right, bottom, left]`,
*      which can be used in padding or margin case.
*      @see `normalizeCssArray` in `util/format.ts`
*  If be `number`, it means [delta, delta, delta, delta],
*      which can be used in lineWidth (borderWith) case,
*      [NOTICE]: commonly pass lineWidth / 2, following the convention that border is
*      half inside half outside of the rect.
* @param shrinkOrExpand
*  `true` - shrink if `delta[i]` is positive, commmonly used in `padding` case.
*  `false` - expand if `delta[i]` is positive, commmonly used in `margin` case. (default)
* @param noNegative
*  `true` - negative `delta[i]` will be clampped to 0.
*  `false` - No clamp to `delta`. (default).
* @return The input `rect`.
*/
function expandOrShrinkRect(rect, delta, shrinkOrExpand, noNegative, minSize) {
	if (delta == null) return rect;
	else if (isNumber(delta)) _tmpExpandRectDelta[0] = _tmpExpandRectDelta[1] = _tmpExpandRectDelta[2] = _tmpExpandRectDelta[3] = delta;
	else {
		assert(delta.length === 4);
		_tmpExpandRectDelta[0] = delta[0];
		_tmpExpandRectDelta[1] = delta[1];
		_tmpExpandRectDelta[2] = delta[2];
		_tmpExpandRectDelta[3] = delta[3];
	}
	if (noNegative) {
		_tmpExpandRectDelta[0] = mathMax(0, _tmpExpandRectDelta[0]);
		_tmpExpandRectDelta[1] = mathMax(0, _tmpExpandRectDelta[1]);
		_tmpExpandRectDelta[2] = mathMax(0, _tmpExpandRectDelta[2]);
		_tmpExpandRectDelta[3] = mathMax(0, _tmpExpandRectDelta[3]);
	}
	if (shrinkOrExpand) {
		_tmpExpandRectDelta[0] = -_tmpExpandRectDelta[0];
		_tmpExpandRectDelta[1] = -_tmpExpandRectDelta[1];
		_tmpExpandRectDelta[2] = -_tmpExpandRectDelta[2];
		_tmpExpandRectDelta[3] = -_tmpExpandRectDelta[3];
	}
	expandRectOnOneDimension(rect, _tmpExpandRectDelta, "x", "width", 3, 1, minSize && minSize[0] || 0);
	expandRectOnOneDimension(rect, _tmpExpandRectDelta, "y", "height", 0, 2, minSize && minSize[1] || 0);
	return rect;
}
var _tmpExpandRectDelta = [
	0,
	0,
	0,
	0
];
function expandRectOnOneDimension(rect, delta, xy, wh, ltIdx, rbIdx, minSize) {
	var deltaSum = delta[rbIdx] + delta[ltIdx];
	var oldSize = rect[wh];
	rect[wh] += deltaSum;
	minSize = mathMax(0, mathMin(minSize, oldSize));
	if (rect[wh] < minSize) {
		rect[wh] = minSize;
		rect[xy] += delta[ltIdx] >= 0 ? -delta[ltIdx] : delta[rbIdx] >= 0 ? oldSize + delta[rbIdx] : mathAbs(deltaSum) > 1e-8 ? (oldSize - minSize) * delta[ltIdx] / deltaSum : 0;
	} else rect[xy] -= delta[ltIdx];
}
function setTooltipConfig(opt) {
	var itemTooltipOption = opt.itemTooltipOption;
	var componentModel = opt.componentModel;
	var itemName = opt.itemName;
	var itemTooltipOptionObj = isString(itemTooltipOption) ? { formatter: itemTooltipOption } : itemTooltipOption;
	var mainType = componentModel.mainType;
	var componentIndex = componentModel.componentIndex;
	var formatterParams = {
		componentType: mainType,
		name: itemName,
		$vars: ["name"]
	};
	formatterParams[mainType + "Index"] = componentIndex;
	var formatterParamsExtra = opt.formatterParamsExtra;
	if (formatterParamsExtra) each(keys(formatterParamsExtra), function(key$1) {
		if (!hasOwn(formatterParams, key$1)) {
			formatterParams[key$1] = formatterParamsExtra[key$1];
			formatterParams.$vars.push(key$1);
		}
	});
	var ecData = getECData(opt.el);
	ecData.componentMainType = mainType;
	ecData.componentIndex = componentIndex;
	ecData.tooltipConfig = {
		name: itemName,
		option: defaults({
			content: itemName,
			encodeHTMLContent: true,
			formatterParams
		}, itemTooltipOptionObj)
	};
}
function traverseElement(el, cb) {
	var stopped;
	if (el.isGroup) stopped = cb(el);
	if (!stopped) el.traverse(cb);
}
function traverseElements(els, cb) {
	if (els) if (isArray(els)) for (var i = 0; i < els.length; i++) traverseElement(els[i], cb);
	else traverseElement(els, cb);
}
/**
* After a boundingRect applying a `transform`, whether to be still parallel screen X and Y.
*/
function isBoundingRectAxisAligned(transform) {
	return !transform || mathAbs(transform[1]) < AXIS_ALIGN_EPSILON && mathAbs(transform[2]) < AXIS_ALIGN_EPSILON || mathAbs(transform[0]) < AXIS_ALIGN_EPSILON && mathAbs(transform[3]) < AXIS_ALIGN_EPSILON;
}
var AXIS_ALIGN_EPSILON = 1e-5;
/**
* Create or copy to the existing bounding rect to avoid modifying `source`.
*
* @usage
*  out.rect = ensureCopyRect(out.rect, sourceRect);
*/
function ensureCopyRect(target, source) {
	return target ? BoundingRect_default.copy(target, source) : source.clone();
}
/**
* Create or copy to the existing transform to avoid modifying `source`.
*
* [CAUTION]: transform is `NullUndefined` if no transform, following convention of zrender,
*  and enable to bypass some unnecessary calculation, since in most cases there is no transform.
*
* @usage
*  out.transform = ensureCopyTransform(out.transform, sourceTransform);
*/
function ensureCopyTransform(target, source) {
	return source ? copy(target || create(), source) : void 0;
}
function retrieveZInfo(model) {
	return {
		z: model.get("z") || 0,
		zlevel: model.get("zlevel") || 0
	};
}
/**
* Assume all of the elements has the same `z` and `zlevel`.
*/
function calcZ2Range(el) {
	var max$1 = -Infinity;
	var min$1 = Infinity;
	traverseElement(el, function(el$1) {
		visitEl(el$1);
		visitEl(el$1.getTextContent());
		visitEl(el$1.getTextGuideLine());
	});
	function visitEl(el$1) {
		if (!el$1 || el$1.isGroup) return;
		var currentStates = el$1.currentStates;
		if (currentStates.length) for (var idx = 0; idx < currentStates.length; idx++) calcZ2(el$1.states[currentStates[idx]]);
		calcZ2(el$1);
	}
	function calcZ2(entity) {
		if (entity) {
			var z2 = entity.z2;
			if (z2 > max$1) max$1 = z2;
			if (z2 < min$1) min$1 = z2;
		}
	}
	if (min$1 > max$1) min$1 = max$1 = 0;
	return {
		min: min$1,
		max: max$1
	};
}
function traverseUpdateZ(el, z, zlevel) {
	doUpdateZ(el, z, zlevel, -Infinity);
}
function doUpdateZ(el, z, zlevel, maxZ2) {
	if (el.ignoreModelZ) return maxZ2;
	var label = el.getTextContent();
	var labelLine = el.getTextGuideLine();
	if (el.isGroup) {
		var children = el.childrenRef();
		for (var i = 0; i < children.length; i++) maxZ2 = mathMax(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);
	} else {
		el.z = z;
		el.zlevel = zlevel;
		maxZ2 = mathMax(el.z2 || 0, maxZ2);
	}
	if (label) {
		label.z = z;
		label.zlevel = zlevel;
		isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
	}
	if (labelLine) {
		var textGuideLineConfig = el.textGuideLineConfig;
		labelLine.z = z;
		labelLine.zlevel = zlevel;
		isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
	}
	return maxZ2;
}
registerShape("circle", Circle_default);
registerShape("ellipse", Ellipse_default);
registerShape("sector", Sector_default);
registerShape("ring", Ring_default);
registerShape("polygon", Polygon_default);
registerShape("polyline", Polyline_default);
registerShape("rect", Rect_default);
registerShape("line", Line_default);
registerShape("bezierCurve", BezierCurve_default);
registerShape("arc", Arc_default);

//#endregion
//#region node_modules/echarts/lib/label/labelStyle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
	for (var i = 0; i < SPECIAL_STATES.length; i++) {
		var stateName = SPECIAL_STATES[i];
		var text = labelTexts[stateName];
		var state = label.ensureState(stateName);
		state.style = state.style || {};
		state.style.text = text;
	}
	var oldStates = label.currentStates.slice();
	label.clearStates(true);
	label.setStyle({ text: labelTexts.normal });
	label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
	var labelFetcher = opt.labelFetcher;
	var labelDataIndex = opt.labelDataIndex;
	var labelDimIndex = opt.labelDimIndex;
	var normalModel = stateModels.normal;
	var baseText;
	if (labelFetcher) baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? { interpolatedValue } : null);
	if (baseText == null) baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
	var statesText = { normal: baseText };
	for (var i = 0; i < SPECIAL_STATES.length; i++) {
		var stateName = SPECIAL_STATES[i];
		var stateModel = stateModels[stateName];
		statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
	}
	return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
	opt = opt || EMPTY_OBJ;
	var isSetOnText = targetEl instanceof Text_default;
	var needsCreateText = false;
	for (var i = 0; i < DISPLAY_STATES.length; i++) {
		var stateModel = labelStatesModels[DISPLAY_STATES[i]];
		if (stateModel && stateModel.getShallow("show")) {
			needsCreateText = true;
			break;
		}
	}
	var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
	if (needsCreateText) {
		if (!isSetOnText) {
			if (!textContent) {
				textContent = new Text_default();
				targetEl.setTextContent(textContent);
			}
			if (targetEl.stateProxy) textContent.stateProxy = targetEl.stateProxy;
		}
		var labelStatesTexts = getLabelText(opt, labelStatesModels);
		var normalModel = labelStatesModels.normal;
		var showNormal = !!normalModel.getShallow("show");
		var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
		normalStyle.text = labelStatesTexts.normal;
		if (!isSetOnText) targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
		for (var i = 0; i < SPECIAL_STATES.length; i++) {
			var stateName = SPECIAL_STATES[i];
			var stateModel = labelStatesModels[stateName];
			if (stateModel) {
				var stateObj = textContent.ensureState(stateName);
				var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
				if (stateShow !== showNormal) stateObj.ignore = !stateShow;
				stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
				stateObj.style.text = labelStatesTexts[stateName];
				if (!isSetOnText) {
					var targetElEmphasisState = targetEl.ensureState(stateName);
					targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
				}
			}
		}
		textContent.silent = !!normalModel.getShallow("silent");
		if (textContent.style.x != null) normalStyle.x = textContent.style.x;
		if (textContent.style.y != null) normalStyle.y = textContent.style.y;
		textContent.ignore = !showNormal;
		textContent.useStyle(normalStyle);
		textContent.dirty();
		if (opt.enableTextSetter) labelInner(textContent).setLabelText = function(interpolatedValue) {
			var labelStatesTexts$1 = getLabelText(opt, labelStatesModels, interpolatedValue);
			setLabelText(textContent, labelStatesTexts$1);
		};
	} else if (textContent) textContent.ignore = true;
	targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
	labelName = labelName || "label";
	var statesModels = { normal: itemModel.getModel(labelName) };
	for (var i = 0; i < SPECIAL_STATES.length; i++) {
		var stateName = SPECIAL_STATES[i];
		statesModels[stateName] = itemModel.getModel([stateName, labelName]);
	}
	return statesModels;
}
/**
* Set basic textStyle properties.
*/
function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
	var textStyle = {};
	setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
	specifiedTextStyle && extend(textStyle, specifiedTextStyle);
	return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
	opt = opt || {};
	var textConfig = {};
	var labelPosition;
	var labelRotate = textStyleModel.getShallow("rotate");
	var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
	var labelOffset = textStyleModel.getShallow("offset");
	labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
	labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
	if (labelPosition != null) textConfig.position = labelPosition;
	if (labelOffset != null) textConfig.offset = labelOffset;
	if (labelRotate != null) {
		labelRotate *= Math.PI / 180;
		textConfig.rotation = labelRotate;
	}
	if (labelDistance != null) textConfig.distance = labelDistance;
	textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
	if (opt.autoOverflowArea != null) textConfig.autoOverflowArea = opt.autoOverflowArea;
	if (opt.layoutRect != null) textConfig.layoutRect = opt.layoutRect;
	return textConfig;
}
/**
* The uniform entry of set text style, that is, retrieve style definitions
* from `model` and set to `textStyle` object.
*
* Never in merge mode, but in overwrite mode, that is, all of the text style
* properties will be set. (Consider the states of normal and emphasis and
* default value can be adopted, merge would make the logic too complicated
* to manage.)
*/
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
	opt = opt || EMPTY_OBJ;
	var ecModel = textStyleModel.ecModel;
	var globalTextStyle = ecModel && ecModel.option.textStyle;
	var richItemNames = getRichItemNames(textStyleModel);
	var richResult;
	if (richItemNames) {
		richResult = {};
		var richInheritPlainLabelOptionName = "richInheritPlainLabel";
		var richInheritPlainLabel = retrieve2(textStyleModel.get(richInheritPlainLabelOptionName), ecModel ? ecModel.get(richInheritPlainLabelOptionName) : void 0);
		for (var name_1 in richItemNames) if (richItemNames.hasOwnProperty(name_1)) {
			var richTextStyle = textStyleModel.getModel(["rich", name_1]);
			setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, textStyleModel, richInheritPlainLabel, opt, isNotNormal, isAttached, false, true);
		}
	}
	if (richResult) textStyle.rich = richResult;
	var overflow = textStyleModel.get("overflow");
	if (overflow) textStyle.overflow = overflow;
	var lineOverflow = textStyleModel.get("lineOverflow");
	if (lineOverflow) textStyle.lineOverflow = lineOverflow;
	var labelTextStyle = textStyle;
	var minMargin = textStyleModel.get("minMargin");
	if (minMargin != null) {
		minMargin = !isNumber(minMargin) ? 0 : minMargin / 2;
		labelTextStyle.margin = [
			minMargin,
			minMargin,
			minMargin,
			minMargin
		];
		labelTextStyle.__marginType = LabelMarginType.minMargin;
	} else {
		var textMargin = textStyleModel.get("textMargin");
		if (textMargin != null) {
			labelTextStyle.margin = normalizeCssArray$1(textMargin);
			labelTextStyle.__marginType = LabelMarginType.textMargin;
		}
	}
	setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, null, null, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
	var richItemNameMap;
	while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
		var rich = (textStyleModel.option || EMPTY_OBJ).rich;
		if (rich) {
			richItemNameMap = richItemNameMap || {};
			var richKeys = keys(rich);
			for (var i = 0; i < richKeys.length; i++) {
				var richKey = richKeys[i];
				richItemNameMap[richKey] = 1;
			}
		}
		textStyleModel = textStyleModel.parentModel;
	}
	return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily",
	"textShadowColor",
	"textShadowBlur",
	"textShadowOffsetX",
	"textShadowOffsetY"
];
var TEXT_PROPS_SELF = [
	"align",
	"lineHeight",
	"width",
	"height",
	"tag",
	"verticalAlign",
	"ellipsis"
];
var TEXT_PROPS_BOX = [
	"padding",
	"borderWidth",
	"borderRadius",
	"borderDashOffset",
	"backgroundColor",
	"borderColor",
	"shadowColor",
	"shadowBlur",
	"shadowOffsetX",
	"shadowOffsetY"
];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, plainTextModel, richInheritPlainLabel, opt, isNotNormal, isAttached, isBlock, inRich) {
	globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
	var inheritColor = opt && opt.inheritColor;
	var fillColor = textStyleModel.getShallow("color");
	var strokeColor = textStyleModel.getShallow("textBorderColor");
	var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
	if (fillColor === "inherit" || fillColor === "auto") {
		if (fillColor === "auto") deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
		if (inheritColor) fillColor = inheritColor;
		else fillColor = null;
	}
	if (strokeColor === "inherit" || strokeColor === "auto") {
		if (strokeColor === "auto") deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
		if (inheritColor) strokeColor = inheritColor;
		else strokeColor = null;
	}
	if (!isAttached) {
		fillColor = fillColor || globalTextStyle.color;
		strokeColor = strokeColor || globalTextStyle.textBorderColor;
	}
	if (fillColor != null) textStyle.fill = fillColor;
	if (strokeColor != null) textStyle.stroke = strokeColor;
	var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
	if (textBorderWidth != null) textStyle.lineWidth = textBorderWidth;
	var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
	if (textBorderType != null) textStyle.lineDash = textBorderType;
	var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
	if (textBorderDashOffset != null) textStyle.lineDashOffset = textBorderDashOffset;
	if (!isNotNormal && opacity == null && !inRich) opacity = opt && opt.defaultOpacity;
	if (opacity != null) textStyle.opacity = opacity;
	if (!isNotNormal && !isAttached) {
		if (textStyle.fill == null && opt.inheritColor) textStyle.fill = opt.inheritColor;
	}
	for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
		var key$1 = TEXT_PROPS_WITH_GLOBAL[i];
		var val = richInheritPlainLabel !== false && plainTextModel ? retrieve3(textStyleModel.getShallow(key$1), plainTextModel.getShallow(key$1), globalTextStyle[key$1]) : retrieve2(textStyleModel.getShallow(key$1), globalTextStyle[key$1]);
		if (val != null) textStyle[key$1] = val;
	}
	for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
		var key$1 = TEXT_PROPS_SELF[i];
		var val = textStyleModel.getShallow(key$1);
		if (val != null) textStyle[key$1] = val;
	}
	if (textStyle.verticalAlign == null) {
		var baseline = textStyleModel.getShallow("baseline");
		if (baseline != null) textStyle.verticalAlign = baseline;
	}
	if (!isBlock || !opt.disableBox) {
		for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
			var key$1 = TEXT_PROPS_BOX[i];
			var val = textStyleModel.getShallow(key$1);
			if (val != null) textStyle[key$1] = val;
		}
		var borderType = textStyleModel.getShallow("borderType");
		if (borderType != null) textStyle.borderDash = borderType;
		if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
			if (textStyle.backgroundColor === "auto") deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'");
			textStyle.backgroundColor = inheritColor;
		}
		if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
			if (textStyle.borderColor === "auto") deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'");
			textStyle.borderColor = inheritColor;
		}
	}
}
function getFont(opt, ecModel) {
	var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
	return trim([
		opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
		opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
		(opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
		opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
	].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
	if (!label) return;
	var obj = labelInner(label);
	obj.prevValue = obj.value;
	obj.value = value;
	var normalLabelModel = labelStatesModels.normal;
	obj.valueAnimation = normalLabelModel.get("valueAnimation");
	if (obj.valueAnimation) {
		obj.precision = normalLabelModel.get("precision");
		obj.defaultInterpolatedText = getDefaultText;
		obj.statesModels = labelStatesModels;
	}
}
function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
	var labelInnerStore = labelInner(textEl);
	if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) return;
	var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
	var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
	var targetValue = labelInnerStore.value;
	function during(percent) {
		var interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
		labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
		setLabelText(textEl, getLabelText({
			labelDataIndex: dataIndex,
			labelFetcher,
			defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
		}, labelInnerStore.statesModels, interpolated));
	}
	textEl.percent = 0;
	(labelInnerStore.prevValue == null ? initProps : updateProps)(textEl, { percent: 1 }, animatableModel, dataIndex, null, during);
}
/**
* PENDING: Temporary impl. unify them?
* @see {LabelCommonOption['textMargin']}
* @see {LabelCommonOption['minMargin']}
*/
var LabelMarginType = {
	minMargin: 1,
	textMargin: 2
};

//#endregion
//#region node_modules/echarts/lib/model/mixin/textStyle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = [
	"fontStyle",
	"fontWeight",
	"fontSize",
	"fontFamily",
	"padding",
	"lineHeight",
	"rich",
	"width",
	"height",
	"overflow"
];
var tmpText = new Text_default();
var TextStyleMixin = function() {
	function TextStyleMixin$1() {}
	/**
	* Get color property or get color from option.textStyle.color
	*/
	TextStyleMixin$1.prototype.getTextColor = function(isEmphasis) {
		var ecModel = this.ecModel;
		return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
	};
	/**
	* Create font string from fontStyle, fontWeight, fontSize, fontFamily
	* @return {string}
	*/
	TextStyleMixin$1.prototype.getFont = function() {
		return getFont({
			fontStyle: this.getShallow("fontStyle"),
			fontWeight: this.getShallow("fontWeight"),
			fontSize: this.getShallow("fontSize"),
			fontFamily: this.getShallow("fontFamily")
		}, this.ecModel);
	};
	TextStyleMixin$1.prototype.getTextRect = function(text) {
		var style = {
			text,
			verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
		};
		for (var i = 0; i < textStyleParams.length; i++) style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
		tmpText.useStyle(style);
		tmpText.update();
		return tmpText.getBoundingRect();
	};
	return TextStyleMixin$1;
}();
var textStyle_default = TextStyleMixin;

//#endregion
//#region node_modules/echarts/lib/model/mixin/lineStyle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var LINE_STYLE_KEY_MAP = [
	["lineWidth", "width"],
	["stroke", "color"],
	["opacity"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["shadowColor"],
	["lineDash", "type"],
	["lineDashOffset", "dashOffset"],
	["lineCap", "cap"],
	["lineJoin", "join"],
	["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = function() {
	function LineStyleMixin$1() {}
	LineStyleMixin$1.prototype.getLineStyle = function(excludes) {
		return getLineStyle(this, excludes);
	};
	return LineStyleMixin$1;
}();

//#endregion
//#region node_modules/echarts/lib/model/mixin/itemStyle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var ITEM_STYLE_KEY_MAP = [
	["fill", "color"],
	["stroke", "borderColor"],
	["lineWidth", "borderWidth"],
	["opacity"],
	["shadowBlur"],
	["shadowOffsetX"],
	["shadowOffsetY"],
	["shadowColor"],
	["lineDash", "borderType"],
	["lineDashOffset", "borderDashOffset"],
	["lineCap", "borderCap"],
	["lineJoin", "borderJoin"],
	["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = function() {
	function ItemStyleMixin$1() {}
	ItemStyleMixin$1.prototype.getItemStyle = function(excludes, includes) {
		return getItemStyle(this, excludes, includes);
	};
	return ItemStyleMixin$1;
}();

//#endregion
//#region node_modules/echarts/lib/model/Model.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var Model = function() {
	function Model$1(option, parentModel, ecModel) {
		this.parentModel = parentModel;
		this.ecModel = ecModel;
		this.option = option;
	}
	Model$1.prototype.init = function(option, parentModel, ecModel) {
		var rest = [];
		for (var _i = 3; _i < arguments.length; _i++) rest[_i - 3] = arguments[_i];
	};
	/**
	* Merge the input option to me.
	*/
	Model$1.prototype.mergeOption = function(option, ecModel) {
		merge(this.option, option, true);
	};
	Model$1.prototype.get = function(path, ignoreParent) {
		if (path == null) return this.option;
		return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
	};
	Model$1.prototype.getShallow = function(key$1, ignoreParent) {
		var option = this.option;
		var val = option == null ? option : option[key$1];
		if (val == null && !ignoreParent) {
			var parentModel = this.parentModel;
			if (parentModel) val = parentModel.getShallow(key$1);
		}
		return val;
	};
	Model$1.prototype.getModel = function(path, parentModel) {
		var hasPath = path != null;
		var pathFinal = hasPath ? this.parsePath(path) : null;
		var obj = hasPath ? this._doGet(pathFinal) : this.option;
		parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
		return new Model$1(obj, parentModel, this.ecModel);
	};
	/**
	* If model has option
	*/
	Model$1.prototype.isEmpty = function() {
		return this.option == null;
	};
	Model$1.prototype.restoreData = function() {};
	Model$1.prototype.clone = function() {
		var Ctor = this.constructor;
		return new Ctor(clone(this.option));
	};
	Model$1.prototype.parsePath = function(path) {
		if (typeof path === "string") return path.split(".");
		return path;
	};
	Model$1.prototype.resolveParentPath = function(path) {
		return path;
	};
	Model$1.prototype.isAnimationEnabled = function() {
		if (!env_default.node && this.option) {
			if (this.option.animation != null) return !!this.option.animation;
			else if (this.parentModel) return this.parentModel.isAnimationEnabled();
		}
	};
	Model$1.prototype._doGet = function(pathArr, parentModel) {
		var obj = this.option;
		if (!pathArr) return obj;
		for (var i = 0; i < pathArr.length; i++) {
			if (!pathArr[i]) continue;
			obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
			if (obj == null) break;
		}
		if (obj == null && parentModel) obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
		return obj;
	};
	return Model$1;
}();
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, textStyle_default);
var Model_default = Model;

//#endregion
//#region node_modules/echarts/lib/i18n/langEN.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Language: English.
*/
var langEN_default = {
	time: {
		month: [
			"January",
			"February",
			"March",
			"April",
			"May",
			"June",
			"July",
			"August",
			"September",
			"October",
			"November",
			"December"
		],
		monthAbbr: [
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		],
		dayOfWeek: [
			"Sunday",
			"Monday",
			"Tuesday",
			"Wednesday",
			"Thursday",
			"Friday",
			"Saturday"
		],
		dayOfWeekAbbr: [
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		]
	},
	legend: { selector: {
		all: "All",
		inverse: "Inv"
	} },
	toolbox: {
		brush: { title: {
			rect: "Box Select",
			polygon: "Lasso Select",
			lineX: "Horizontally Select",
			lineY: "Vertically Select",
			keep: "Keep Selections",
			clear: "Clear Selections"
		} },
		dataView: {
			title: "Data View",
			lang: [
				"Data View",
				"Close",
				"Refresh"
			]
		},
		dataZoom: { title: {
			zoom: "Zoom",
			back: "Zoom Reset"
		} },
		magicType: { title: {
			line: "Switch to Line Chart",
			bar: "Switch to Bar Chart",
			stack: "Stack",
			tiled: "Tile"
		} },
		restore: { title: "Restore" },
		saveAsImage: {
			title: "Save as Image",
			lang: ["Right Click to Save Image"]
		}
	},
	series: { typeNames: {
		pie: "Pie chart",
		bar: "Bar chart",
		line: "Line chart",
		scatter: "Scatter plot",
		effectScatter: "Ripple scatter plot",
		radar: "Radar chart",
		tree: "Tree",
		treemap: "Treemap",
		boxplot: "Boxplot",
		candlestick: "Candlestick",
		k: "K line chart",
		heatmap: "Heat map",
		map: "Map",
		parallel: "Parallel coordinate map",
		lines: "Line graph",
		graph: "Relationship graph",
		sankey: "Sankey diagram",
		funnel: "Funnel chart",
		gauge: "Gauge",
		pictorialBar: "Pictorial bar",
		themeRiver: "Theme River Map",
		sunburst: "Sunburst",
		custom: "Custom chart",
		chart: "Chart"
	} },
	aria: {
		general: {
			withTitle: "This is a chart about \"{title}\"",
			withoutTitle: "This is a chart"
		},
		series: {
			single: {
				prefix: "",
				withName: " with type {seriesType} named {seriesName}.",
				withoutName: " with type {seriesType}."
			},
			multiple: {
				prefix: ". It consists of {seriesCount} series count.",
				withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
				withoutName: " The {seriesId} series is a {seriesType}.",
				separator: {
					middle: "",
					end: ""
				}
			}
		},
		data: {
			allData: "The data is as follows: ",
			partialData: "The first {displayCnt} items are: ",
			withName: "the data for {name} is {value}",
			withoutName: "{value}",
			separator: {
				middle: ", ",
				end: ". "
			}
		}
	}
};

//#endregion
//#region node_modules/echarts/lib/i18n/langZH.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var langZH_default = {
	time: {
		month: [
			"一月",
			"二月",
			"三月",
			"四月",
			"五月",
			"六月",
			"七月",
			"八月",
			"九月",
			"十月",
			"十一月",
			"十二月"
		],
		monthAbbr: [
			"1月",
			"2月",
			"3月",
			"4月",
			"5月",
			"6月",
			"7月",
			"8月",
			"9月",
			"10月",
			"11月",
			"12月"
		],
		dayOfWeek: [
			"星期日",
			"星期一",
			"星期二",
			"星期三",
			"星期四",
			"星期五",
			"星期六"
		],
		dayOfWeekAbbr: [
			"日",
			"一",
			"二",
			"三",
			"四",
			"五",
			"六"
		]
	},
	legend: { selector: {
		all: "全选",
		inverse: "反选"
	} },
	toolbox: {
		brush: { title: {
			rect: "矩形选择",
			polygon: "圈选",
			lineX: "横向选择",
			lineY: "纵向选择",
			keep: "保持选择",
			clear: "清除选择"
		} },
		dataView: {
			title: "数据视图",
			lang: [
				"数据视图",
				"关闭",
				"刷新"
			]
		},
		dataZoom: { title: {
			zoom: "区域缩放",
			back: "区域缩放还原"
		} },
		magicType: { title: {
			line: "切换为折线图",
			bar: "切换为柱状图",
			stack: "切换为堆叠",
			tiled: "切换为平铺"
		} },
		restore: { title: "还原" },
		saveAsImage: {
			title: "保存为图片",
			lang: ["右键另存为图片"]
		}
	},
	series: { typeNames: {
		pie: "饼图",
		bar: "柱状图",
		line: "折线图",
		scatter: "散点图",
		effectScatter: "涟漪散点图",
		radar: "雷达图",
		tree: "树图",
		treemap: "矩形树图",
		boxplot: "箱型图",
		candlestick: "K线图",
		k: "K线图",
		heatmap: "热力图",
		map: "地图",
		parallel: "平行坐标图",
		lines: "线图",
		graph: "关系图",
		sankey: "桑基图",
		funnel: "漏斗图",
		gauge: "仪表盘图",
		pictorialBar: "象形柱图",
		themeRiver: "主题河流图",
		sunburst: "旭日图",
		custom: "自定义图表",
		chart: "图表"
	} },
	aria: {
		general: {
			withTitle: "这是一个关于“{title}”的图表。",
			withoutTitle: "这是一个图表，"
		},
		series: {
			single: {
				prefix: "",
				withName: "图表类型是{seriesType}，表示{seriesName}。",
				withoutName: "图表类型是{seriesType}。"
			},
			multiple: {
				prefix: "它由{seriesCount}个图表系列组成。",
				withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
				withoutName: "第{seriesId}个系列是一个{seriesType}，",
				separator: {
					middle: "；",
					end: "。"
				}
			}
		},
		data: {
			allData: "其数据是——",
			partialData: "其中，前{displayCnt}项是——",
			withName: "{name}的数据是{value}",
			withoutName: "{value}",
			separator: {
				middle: "，",
				end: ""
			}
		}
	}
};

//#endregion
//#region node_modules/echarts/lib/core/locale.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env_default.domSupported ? DEFAULT_LOCALE : function() {
	return (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase().indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
	locale = locale.toUpperCase();
	localeModels[locale] = new Model_default(localeObj);
	localeStorage[locale] = localeObj;
}
function createLocaleObject(locale) {
	if (isString(locale)) {
		var localeObj = localeStorage[locale.toUpperCase()] || {};
		if (locale === LOCALE_ZH || locale === LOCALE_EN) return clone(localeObj);
		else return merge(clone(localeObj), clone(localeStorage[DEFAULT_LOCALE]), false);
	} else return merge(clone(locale), clone(localeStorage[DEFAULT_LOCALE]), false);
}
function getLocaleModel(lang) {
	return localeModels[lang];
}
function getDefaultLocaleModel() {
	return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN_default);
registerLocale(LOCALE_ZH, langZH_default);

//#endregion
//#region node_modules/echarts/lib/scale/break.js
var _impl = null;
function getScaleBreakHelper() {
	return _impl;
}

//#endregion
//#region node_modules/echarts/lib/util/time.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var ONE_SECOND = 1e3;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var primaryTimeUnitFormatterMatchers = {
	year: /({yyyy}|{yy})/,
	month: /({MMMM}|{MMM}|{MM}|{M})/,
	day: /({dd}|{d})/,
	hour: /({HH}|{H}|{hh}|{h})/,
	minute: /({mm}|{m})/,
	second: /({ss}|{s})/,
	millisecond: /({SSS}|{S})/
};
var defaultFormatterSeed = {
	year: "{yyyy}",
	month: "{MMM}",
	day: "{d}",
	hour: "{HH}:{mm}",
	minute: "{HH}:{mm}",
	second: "{HH}:{mm}:{ss}",
	millisecond: "{HH}:{mm}:{ss} {SSS}"
};
var defaultFullFormatter = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}";
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
	year: "{yyyy}",
	month: "{yyyy}-{MM}",
	day: fullDayFormatter,
	hour: fullDayFormatter + " " + defaultFormatterSeed.hour,
	minute: fullDayFormatter + " " + defaultFormatterSeed.minute,
	second: fullDayFormatter + " " + defaultFormatterSeed.second,
	millisecond: defaultFullFormatter
};
var primaryTimeUnits = [
	"year",
	"month",
	"day",
	"hour",
	"minute",
	"second",
	"millisecond"
];
var timeUnits = [
	"year",
	"half-year",
	"quarter",
	"month",
	"week",
	"half-week",
	"day",
	"half-day",
	"quarter-day",
	"hour",
	"minute",
	"second",
	"millisecond"
];
function parseTimeAxisLabelFormatter(formatter) {
	return !isString(formatter) && !isFunction(formatter) ? parseTimeAxisLabelFormatterDictionary(formatter) : formatter;
}
/**
* The final generated dictionary is like:
*  generated_dict = {
*      year: {
*          year: ['{yyyy}', ...<higher_levels_if_any>]
*      },
*      month: {
*          year: ['{yyyy} {MMM}', ...<higher_levels_if_any>],
*          month: ['{MMM}', ...<higher_levels_if_any>]
*      },
*      day: {
*          year: ['{yyyy} {MMM} {d}', ...<higher_levels_if_any>],
*          month: ['{MMM} {d}', ...<higher_levels_if_any>],
*          day: ['{d}', ...<higher_levels_if_any>]
*      },
*      ...
*  }
*
* In echarts option, users can specify the entire dictionary or typically just:
*  {formatter: {
*      year: '{yyyy}', // Or an array of leveled templates: `['{yyyy}', '{bold1|{yyyy}}', ...]`,
*                      // corresponding to `[level0, level1, level2, ...]`.
*      month: '{MMM}',
*      day: '{d}',
*      hour: '{HH}:{mm}',
*      second: '{HH}:{mm}',
*      ...
*  }}
*  If any time unit is not specified in echarts option, the default template is used,
*  such as `['{yyyy}', {primary|{yyyy}']`.
*
* The `tick.level` is only used to read string from each array, meaning the style type.
*
* Let `lowerUnit = getUnitFromValue(tick.value)`.
* The non-break axis ticks only use `generated_dict[lowerUnit][lowerUnit][level]`.
* The break axis ticks may use `generated_dict[lowerUnit][upperUnit][level]`, because:
*  Consider the case: the non-break ticks are `16th, 23th, Feb, 7th, ...`, where `Feb` is in the break
*  range and pruned by breaks, and the break ends might be in lower time unit than day. e.g., break start
*  is `Jan 25th 18:00`(in unit `hour`) and break end is `Feb 6th 18:30` (in unit `minute`). Thus the break
*  label prefers `Jan 25th 18:00` and `Feb 6th 18:30` rather than only `18:00` and `18:30`, otherwise it
*  causes misleading.
*  In this case, the tick of the break start and end will both be:
*      `{level: 1, lowerTimeUnit: 'minute', upperTimeUnit: 'month'}`
*  And get the final template by `generated_dict[lowerTimeUnit][upperTimeUnit][level]`.
*  Note that the time unit can not be calculated directly by a single tick value, since the two breaks have
*  to be at the same time unit to avoid awkward appearance. i.e., `Jan 25th 18:00` is in the time unit "hour"
*  but we need it to be "minute", following `Feb 6th 18:30`.
*/
function parseTimeAxisLabelFormatterDictionary(dictOption) {
	dictOption = dictOption || {};
	var dict = {};
	var canAddHighlight = true;
	each(primaryTimeUnits, function(lowestUnit) {
		canAddHighlight && (canAddHighlight = dictOption[lowestUnit] == null);
	});
	each(primaryTimeUnits, function(lowestUnit, lowestUnitIdx) {
		var upperDictOption = dictOption[lowestUnit];
		dict[lowestUnit] = {};
		var lowerTpl = null;
		for (var upperUnitIdx = lowestUnitIdx; upperUnitIdx >= 0; upperUnitIdx--) {
			var upperUnit = primaryTimeUnits[upperUnitIdx];
			var upperDictItemOption = isObject$1(upperDictOption) && !isArray(upperDictOption) ? upperDictOption[upperUnit] : upperDictOption;
			var tplArr = void 0;
			if (isArray(upperDictItemOption)) {
				tplArr = upperDictItemOption.slice();
				lowerTpl = tplArr[0] || "";
			} else if (isString(upperDictItemOption)) {
				lowerTpl = upperDictItemOption;
				tplArr = [lowerTpl];
			} else {
				if (lowerTpl == null) lowerTpl = defaultFormatterSeed[lowestUnit];
				else if (!primaryTimeUnitFormatterMatchers[upperUnit].test(lowerTpl)) lowerTpl = dict[upperUnit][upperUnit][0] + " " + lowerTpl;
				tplArr = [lowerTpl];
				if (canAddHighlight) tplArr[1] = "{primary|" + lowerTpl + "}";
			}
			dict[lowestUnit][upperUnit] = tplArr;
		}
	});
	return dict;
}
function pad(str, len) {
	str += "";
	return "0000".substr(0, len - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
	switch (timeUnit) {
		case "half-year":
		case "quarter": return "month";
		case "week":
		case "half-week": return "day";
		case "half-day":
		case "quarter-day": return "hour";
		default: return timeUnit;
	}
}
function isPrimaryTimeUnit(timeUnit) {
	return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
	switch (timeUnit) {
		case "year":
		case "month": return "day";
		case "millisecond": return "millisecond";
		default: return "second";
	}
}
function format(time, template, isUTC, lang) {
	var date = parseDate(time);
	var y = date[fullYearGetterName(isUTC)]();
	var M = date[monthGetterName(isUTC)]() + 1;
	var q = Math.floor((M - 1) / 3) + 1;
	var d = date[dateGetterName(isUTC)]();
	var e$1 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
	var H = date[hoursGetterName(isUTC)]();
	var h = (H - 1) % 12 + 1;
	var m$1 = date[minutesGetterName(isUTC)]();
	var s = date[secondsGetterName(isUTC)]();
	var S = date[millisecondsGetterName(isUTC)]();
	var a = H >= 12 ? "pm" : "am";
	var A = a.toUpperCase();
	var timeModel = (lang instanceof Model_default ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel()).getModel("time");
	var month = timeModel.get("month");
	var monthAbbr = timeModel.get("monthAbbr");
	var dayOfWeek = timeModel.get("dayOfWeek");
	var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
	return (template || "").replace(/{a}/g, a + "").replace(/{A}/g, A + "").replace(/{yyyy}/g, y + "").replace(/{yy}/g, pad(y % 100 + "", 2)).replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + "").replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + "").replace(/{eeee}/g, dayOfWeek[e$1]).replace(/{ee}/g, dayOfWeekAbbr[e$1]).replace(/{e}/g, e$1 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, pad(m$1, 2)).replace(/{m}/g, m$1 + "").replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + "").replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + "");
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
	var template = null;
	if (isString(formatter)) template = formatter;
	else if (isFunction(formatter)) {
		var extra = {
			time: tick.time,
			level: tick.time.level
		};
		var scaleBreakHelper = getScaleBreakHelper();
		if (scaleBreakHelper) scaleBreakHelper.makeAxisLabelFormatterParamBreak(extra, tick["break"]);
		template = formatter(tick.value, idx, extra);
	} else {
		var tickTime = tick.time;
		if (tickTime) {
			var leveledTplArr = formatter[tickTime.lowerTimeUnit][tickTime.upperTimeUnit];
			template = leveledTplArr[Math.min(tickTime.level, leveledTplArr.length - 1)] || "";
		} else {
			var unit = getUnitFromValue(tick.value, isUTC);
			template = formatter[unit][unit][0];
		}
	}
	return format(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
	var date = parseDate(value);
	var M = date[monthGetterName(isUTC)]() + 1;
	var d = date[dateGetterName(isUTC)]();
	var h = date[hoursGetterName(isUTC)]();
	var m$1 = date[minutesGetterName(isUTC)]();
	var s = date[secondsGetterName(isUTC)]();
	var isSecond = date[millisecondsGetterName(isUTC)]() === 0;
	var isMinute = isSecond && s === 0;
	var isHour = isMinute && m$1 === 0;
	var isDay = isHour && h === 0;
	var isMonth = isDay && d === 1;
	if (isMonth && M === 1) return "year";
	else if (isMonth) return "month";
	else if (isDay) return "day";
	else if (isHour) return "hour";
	else if (isMinute) return "minute";
	else if (isSecond) return "second";
	else return "millisecond";
}
/**
* e.g.,
* If timeUnit is 'year', return the Jan 1st 00:00:00 000 of that year.
* If timeUnit is 'day', return the 00:00:00 000 of that day.
*
* @return The input date.
*/
function roundTime(date, timeUnit, isUTC) {
	switch (timeUnit) {
		case "year": date[monthSetterName(isUTC)](0);
		case "month": date[dateSetterName(isUTC)](1);
		case "day": date[hoursSetterName(isUTC)](0);
		case "hour": date[minutesSetterName(isUTC)](0);
		case "minute": date[secondsSetterName(isUTC)](0);
		case "second": date[millisecondsSetterName(isUTC)](0);
	}
	return date;
}
function fullYearGetterName(isUTC) {
	return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
	return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
	return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
	return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
	return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
	return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
	return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
	return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
	return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
	return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
	return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
	return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
	return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
	return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}

//#endregion
//#region node_modules/echarts/lib/legacy/getTextRect.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
	return new Text_default({ style: {
		text,
		font,
		align,
		verticalAlign,
		padding,
		rich,
		overflow: truncate ? "truncate" : null,
		lineHeight
	} }).getBoundingRect();
}

//#endregion
//#region node_modules/echarts/lib/util/format.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Add a comma each three digit.
*/
function addCommas(x) {
	if (!isNumeric(x)) return isString(x) ? x : "-";
	var parts = (x + "").split(".");
	return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
}
function toCamelCase(str, upperCaseFirst) {
	str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
		return group1.toUpperCase();
	});
	if (upperCaseFirst && str) str = str.charAt(0).toUpperCase() + str.slice(1);
	return str;
}
var normalizeCssArray = normalizeCssArray$1;
/**
* Make value user readable for tooltip and label.
* "User readable":
*     Try to not print programmer-specific text like NaN, Infinity, null, undefined.
*     Avoid to display an empty string, which users can not recognize there is
*     a value and it might look like a bug.
*/
function makeValueReadable(value, valueType, useUTC) {
	var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
	function stringToUserReadable(str) {
		return str && trim(str) ? str : "-";
	}
	function isNumberUserReadable(num) {
		return !!(num != null && !isNaN(num) && isFinite(num));
	}
	var isTypeTime = valueType === "time";
	var isValueDate = value instanceof Date;
	if (isTypeTime || isValueDate) {
		var date = isTypeTime ? parseDate(value) : value;
		if (!isNaN(+date)) return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
		else if (isValueDate) return "-";
	}
	if (valueType === "ordinal") return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
	var numericResult = numericToNumber(value);
	return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
}
var TPL_VAR_ALIAS = [
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g"
];
var wrapVar = function(varName, seriesIdx) {
	return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
/**
* Template formatter
* @param {Array.<Object>|Object} paramsList
*/
function formatTpl(tpl, paramsList, encode) {
	if (!isArray(paramsList)) paramsList = [paramsList];
	var seriesLen = paramsList.length;
	if (!seriesLen) return "";
	var $vars = paramsList[0].$vars || [];
	for (var i = 0; i < $vars.length; i++) {
		var alias = TPL_VAR_ALIAS[i];
		tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
	}
	for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) for (var k = 0; k < $vars.length; k++) {
		var val = paramsList[seriesIdx][$vars[k]];
		tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
	}
	return tpl;
}
/**
* simple Template formatter
*/
function formatTplSimple(tpl, param, encode) {
	each(param, function(value, key$1) {
		tpl = tpl.replace("{" + key$1 + "}", encode ? encodeHTML(value) : value);
	});
	return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
	var opt = isString(inOpt) ? {
		color: inOpt,
		extraCssText
	} : inOpt || {};
	var color$2 = opt.color;
	var type = opt.type;
	extraCssText = opt.extraCssText;
	var renderMode = opt.renderMode || "html";
	if (!color$2) return "";
	if (renderMode === "html") return type === "subItem" ? "<span style=\"display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:" + encodeHTML(color$2) + ";" + (extraCssText || "") + "\"></span>" : "<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:" + encodeHTML(color$2) + ";" + (extraCssText || "") + "\"></span>";
	else return {
		renderMode,
		content: "{" + (opt.markerId || "markerX") + "|}  ",
		style: type === "subItem" ? {
			width: 4,
			height: 4,
			borderRadius: 2,
			backgroundColor: color$2
		} : {
			width: 10,
			height: 10,
			borderRadius: 5,
			backgroundColor: color$2
		}
	};
}
/**
* @deprecated Use `time/format` instead.
* ISO Date format
* @param {string} tpl
* @param {number} value
* @param {boolean} [isUTC=false] Default in local time.
*           see `module:echarts/scale/Time`
*           and `module:echarts/util/number#parseDate`.
* @inner
*/
function formatTime(tpl, value, isUTC) {
	deprecateReplaceLog("echarts.format.formatTime", "echarts.time.format");
	if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") tpl = "MM-dd\nyyyy";
	var date = parseDate(value);
	var getUTC = isUTC ? "getUTC" : "get";
	var y = date[getUTC + "FullYear"]();
	var M = date[getUTC + "Month"]() + 1;
	var d = date[getUTC + "Date"]();
	var h = date[getUTC + "Hours"]();
	var m$1 = date[getUTC + "Minutes"]();
	var s = date[getUTC + "Seconds"]();
	var S = date[getUTC + "Milliseconds"]();
	tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", pad(y % 100 + "", 2)).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m$1, 2)).replace("m", m$1).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
	return tpl;
}
/**
* Capital first
* @param {string} str
* @return {string}
*/
function capitalFirst(str) {
	return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}
/**
* @return Never be null/undefined.
*/
function convertToColorString(color$2, defaultColor) {
	defaultColor = defaultColor || "transparent";
	return isString(color$2) ? color$2 : isObject$1(color$2) ? color$2.colorStops && (color$2.colorStops[0] || {}).color || defaultColor : defaultColor;
}
/**
* open new tab
* @param link url
* @param target blank or self
*/
function windowOpen(link, target) {
	if (target === "_blank" || target === "blank") {
		var blank = window.open();
		blank.opener = null;
		blank.location.href = link;
	} else window.open(link, target);
}

//#endregion
//#region node_modules/echarts/lib/core/CoordinateSystem.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* FIXME:
* `nonSeriesBoxCoordSysCreators` and `_nonSeriesBoxMasterList` are hardcoded implementations.
* Regarding "coord sys layout based on another coord sys", currently we only exprimentally support one level
* dpendency, such as, "grid(cartesian)s can be laid out based on matrix/calendar coord sys."
* But a comprehensive implementation may need to support:
*  - Recursive dependencies. e.g., a matrix coord sys lays out based on another matrix coord sys.
*    That requires in the implementation `create` and `update` of coord sys are called by a dependency graph.
*    (@see enableTopologicalTravel in `util/component.ts`)
*/
var nonSeriesBoxCoordSysCreators = {};
var normalCoordSysCreators = {};
var CoordinateSystemManager = function() {
	function CoordinateSystemManager$1() {
		this._normalMasterList = [];
		this._nonSeriesBoxMasterList = [];
	}
	/**
	* Typically,
	*  - in `create`, a coord sys lays out based on a given rect;
	*  - in `update`, update the pixel and data extent of there axes (if any) based on processed `series.data`.
	* After that, a coord sys can serve (typically by `dataToPoint`/`dataToLayout`/`pointToData`).
	* If the coordinate system do not lay out based on `series.data`, `update` is not needed.
	*/
	CoordinateSystemManager$1.prototype.create = function(ecModel, api) {
		this._nonSeriesBoxMasterList = dealCreate(nonSeriesBoxCoordSysCreators, true);
		this._normalMasterList = dealCreate(normalCoordSysCreators, false);
		function dealCreate(creatorMap, canBeNonSeriesBox) {
			var coordinateSystems = [];
			each(creatorMap, function(creator, type) {
				var list = creator.create(ecModel, api);
				coordinateSystems = coordinateSystems.concat(list || []);
				if (canBeNonSeriesBox) each(list, function(master) {
					return assert(!master.update);
				});
			});
			return coordinateSystems;
		}
	};
	/**
	* @see CoordinateSystem['create']
	*/
	CoordinateSystemManager$1.prototype.update = function(ecModel, api) {
		each(this._normalMasterList, function(coordSys) {
			coordSys.update && coordSys.update(ecModel, api);
		});
	};
	CoordinateSystemManager$1.prototype.getCoordinateSystems = function() {
		return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
	};
	CoordinateSystemManager$1.register = function(type, creator) {
		if (type === "matrix" || type === "calendar") {
			nonSeriesBoxCoordSysCreators[type] = creator;
			return;
		}
		normalCoordSysCreators[type] = creator;
	};
	CoordinateSystemManager$1.get = function(type) {
		return normalCoordSysCreators[type] || nonSeriesBoxCoordSysCreators[type];
	};
	return CoordinateSystemManager$1;
}();
function canBeNonSeriesBoxCoordSys(coordSysType) {
	return !!nonSeriesBoxCoordSysCreators[coordSysType];
}
var BoxCoordinateSystemCoordFrom = {
	coord: 1,
	coord2: 2
};
/**
* @see_also `createBoxLayoutReference`
* @see_also `injectCoordSysByOption`
*/
function registerLayOutOnCoordSysUsage(opt) {
	assert(!coordSysUseMap.get(opt.fullType));
	coordSysUseMap.set(opt.fullType, { getCoord2: void 0 }).getCoord2 = opt.getCoord2;
}
var coordSysUseMap = createHashMap();
/**
* @return Be an object, but never be NullUndefined.
*/
function getCoordForBoxCoordSys(model) {
	var coord = model.getShallow("coord", true);
	var from = BoxCoordinateSystemCoordFrom.coord;
	if (coord == null) {
		var store = coordSysUseMap.get(model.type);
		if (store && store.getCoord2) {
			from = BoxCoordinateSystemCoordFrom.coord2;
			coord = store.getCoord2(model);
		}
	}
	return {
		coord,
		from
	};
}
/**
* - "dataCoordSys": each data item is laid out based on a coord sys.
* - "boxCoordSys": the overall bounding rect or anchor point is calculated based on a coord sys.
*   e.g.,
*      grid rect (cartesian rect) is calculate based on matrix/calendar coord sys;
*      pie center is calculated based on calendar/cartesian;
*
* The default value (if not declared in option `coordinateSystemUsage`):
*  For series, use `dataCoordSys`, since this is the most case and backward compatible.
*  For non-series components, use `boxCoordSys`, since `dataCoordSys` is not applicable.
*/
var CoordinateSystemUsageKind = {
	none: 0,
	dataCoordSys: 1,
	boxCoordSys: 2
};
function decideCoordSysUsageKind(model, printError) {
	var coordSysType = model.getShallow("coordinateSystem");
	var coordSysUsageOption = model.getShallow("coordinateSystemUsage", true);
	var isDeclaredExplicitly = coordSysUsageOption != null;
	var kind = CoordinateSystemUsageKind.none;
	if (coordSysType) {
		var isSeries$1 = model.mainType === "series";
		if (coordSysUsageOption == null) coordSysUsageOption = isSeries$1 ? "data" : "box";
		if (coordSysUsageOption === "data") {
			kind = CoordinateSystemUsageKind.dataCoordSys;
			if (!isSeries$1) {
				if (isDeclaredExplicitly && printError) error("coordinateSystemUsage \"data\" is not supported in non-series components.");
				kind = CoordinateSystemUsageKind.none;
			}
		} else if (coordSysUsageOption === "box") {
			kind = CoordinateSystemUsageKind.boxCoordSys;
			if (!isSeries$1 && !canBeNonSeriesBoxCoordSys(coordSysType)) {
				if (isDeclaredExplicitly && printError) error("coordinateSystem \"" + coordSysType + "\" cannot be used" + (" as coordinateSystemUsage \"box\" for \"" + model.type + "\" yet."));
				kind = CoordinateSystemUsageKind.none;
			}
		}
	}
	return {
		coordSysType,
		kind
	};
}
/**
* These cases are considered:
*  (A) Most series can use only "dataCoordSys", but "boxCoordSys" is not applicable:
*    - e.g., series.heatmap, series.line, series.bar, series.scatter, ...
*  (B) Some series and most components can use only "boxCoordSys", but "dataCoordSys" is not applicable:
*    - e.g., series.pie, series.funnel, ...
*    - e.g., grid, polar, geo, title, ...
*  (C) Several series can use both "boxCoordSys" and "dataCoordSys", even at the same time:
*    - e.g., series.graph, series.map
*      - If graph or map series use a "boxCoordSys", it creates a internal "dataCoordSys" to lay out its data.
*      - Graph series can use matrix coord sys as either the "dataCoordSys" (each item layout on one cell)
*        or "boxCoordSys" (the entire series are layout within one cell).
*    - To achieve this effect,
*      `series.coordinateSystemUsage: 'box'` needs to be specified explicitly.
*
* Check these echarts option settings:
*  - If `series: {type: 'bar'}`:
*      dataCoordSys: "cartesian2d", boxCoordSys: "none".
*      (since `coordinateSystem: 'cartesian2d'` is the default option in bar.)
*  - If `grid: {coordinateSystem: 'matrix'}`
*      dataCoordSys: "none", boxCoordSys: "matrix".
*  - If `series: {type: 'pie', coordinateSystem: 'matrix'}`:
*      dataCoordSys: "none", boxCoordSys: "matrix".
*      (since `coordinateSystemUsage: 'box'` is the default option in pie.)
*  - If `series: {type: 'graph', coordinateSystem: 'matrix'}`:
*      dataCoordSys: "matrix", boxCoordSys: "none"
*  - If `series: {type: 'graph', coordinateSystem: 'matrix', coordinateSystemUsage: 'box'}`:
*      dataCoordSys: "an internal view", boxCoordSys: "the internal view is laid out on a matrix"
*  - If `series: {type: 'map'}`:
*      dataCoordSys: "a internal geo", boxCoordSys: "none"
*  - If `series: {type: 'map', coordinateSystem: 'geo', geoIndex: 0}`:
*      dataCoordSys: "a geo", boxCoordSys: "none"
*  - If `series: {type: 'map', coordinateSystem: 'matrix'}`:
*      not_applicable
*  - If `series: {type: 'map', coordinateSystem: 'matrix', coordinateSystemUsage: 'box'}`:
*      dataCoordSys: "an internal geo", boxCoordSys: "the internal geo is laid out on a matrix"
*
* @usage
* For case (A) & (B),
*  call `injectCoordSysByOption({coordSysType: 'aaa', ...})` once for each series/components.
* For case (C),
*  call `injectCoordSysByOption({coordSysType: 'aaa', ...})` once for each series/components,
*  and then call `injectCoordSysByOption({coordSysType: 'bbb', ..., isDefaultDataCoordSys: true})`
*  once for each series/components.
*
* @return Whether injected.
*/
function injectCoordSysByOption(opt) {
	var targetModel = opt.targetModel, coordSysType = opt.coordSysType, coordSysProvider = opt.coordSysProvider, isDefaultDataCoordSys = opt.isDefaultDataCoordSys, allowNotFound = opt.allowNotFound;
	assert(!!coordSysType);
	var _a$1 = decideCoordSysUsageKind(targetModel, true), kind = _a$1.kind, declaredType = _a$1.coordSysType;
	if (isDefaultDataCoordSys && kind !== CoordinateSystemUsageKind.dataCoordSys) {
		kind = CoordinateSystemUsageKind.dataCoordSys;
		declaredType = coordSysType;
	}
	if (kind === CoordinateSystemUsageKind.none || declaredType !== coordSysType) return false;
	var coordSys = coordSysProvider(coordSysType, targetModel);
	if (!coordSys) {
		if (!allowNotFound) error(coordSysType + " cannot be found for" + (" " + targetModel.type + " (index: " + targetModel.componentIndex + ")."));
		return false;
	}
	if (kind === CoordinateSystemUsageKind.dataCoordSys) {
		assert(targetModel.mainType === "series");
		targetModel.coordinateSystem = coordSys;
	} else targetModel.boxCoordinateSystem = coordSys;
	return true;
}
var simpleCoordSysInjectionProvider = function(coordSysType, injectTargetModel) {
	var coordSysModel = injectTargetModel.getReferringComponents(coordSysType, SINGLE_REFERRING).models[0];
	return coordSysModel && coordSysModel.coordinateSystem;
};
var CoordinateSystem_default = CoordinateSystemManager;

//#endregion
//#region node_modules/echarts/lib/util/layout.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var each$2 = each;
/**
* @public
*/
var LOCATION_PARAMS = [
	"left",
	"right",
	"top",
	"bottom",
	"width",
	"height"
];
/**
* @public
*/
var HV_NAMES = [[
	"width",
	"left",
	"right"
], [
	"height",
	"top",
	"bottom"
]];
function boxLayout(orient, group, gap, maxWidth, maxHeight) {
	var x = 0;
	var y = 0;
	if (maxWidth == null) maxWidth = Infinity;
	if (maxHeight == null) maxHeight = Infinity;
	var currentLineMaxSize = 0;
	group.eachChild(function(child, idx) {
		var rect = child.getBoundingRect();
		var nextChild = group.childAt(idx + 1);
		var nextChildRect = nextChild && nextChild.getBoundingRect();
		var nextX;
		var nextY;
		if (orient === "horizontal") {
			var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
			nextX = x + moveX;
			if (nextX > maxWidth || child.newline) {
				x = 0;
				nextX = moveX;
				y += currentLineMaxSize + gap;
				currentLineMaxSize = rect.height;
			} else currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
		} else {
			var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
			nextY = y + moveY;
			if (nextY > maxHeight || child.newline) {
				x += currentLineMaxSize + gap;
				y = 0;
				nextY = moveY;
				currentLineMaxSize = rect.width;
			} else currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
		}
		if (child.newline) return;
		child.x = x;
		child.y = y;
		child.markRedraw();
		orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
	});
}
/**
* VBox or HBox layouting
* @param {string} orient
* @param {module:zrender/graphic/Group} group
* @param {number} gap
* @param {number} [width=Infinity]
* @param {number} [height=Infinity]
*/
var box = boxLayout;
/**
* VBox layouting
* @param {module:zrender/graphic/Group} group
* @param {number} gap
* @param {number} [width=Infinity]
* @param {number} [height=Infinity]
*/
var vbox = curry(boxLayout, "vertical");
/**
* HBox layouting
* @param {module:zrender/graphic/Group} group
* @param {number} gap
* @param {number} [width=Infinity]
* @param {number} [height=Infinity]
*/
var hbox = curry(boxLayout, "horizontal");
function getBoxLayoutParams(boxLayoutModel, ignoreParent) {
	return {
		left: boxLayoutModel.getShallow("left", ignoreParent),
		top: boxLayoutModel.getShallow("top", ignoreParent),
		right: boxLayoutModel.getShallow("right", ignoreParent),
		bottom: boxLayoutModel.getShallow("bottom", ignoreParent),
		width: boxLayoutModel.getShallow("width", ignoreParent),
		height: boxLayoutModel.getShallow("height", ignoreParent)
	};
}
function getViewRectAndCenterForCircleLayout(seriesModel, api) {
	var layoutRef = createBoxLayoutReference(seriesModel, api, { enableLayoutOnlyByCenter: true });
	var boxLayoutParams = seriesModel.getBoxLayoutParams();
	var viewRect;
	var center;
	if (layoutRef.type === BoxLayoutReferenceType.point) {
		center = layoutRef.refPoint;
		viewRect = getLayoutRect(boxLayoutParams, {
			width: api.getWidth(),
			height: api.getHeight()
		});
	} else {
		var centerOption = seriesModel.get("center");
		var centerOptionArr = isArray(centerOption) ? centerOption : [centerOption, centerOption];
		viewRect = getLayoutRect(boxLayoutParams, layoutRef.refContainer);
		center = layoutRef.boxCoordFrom === BoxCoordinateSystemCoordFrom.coord2 ? layoutRef.refPoint : [parsePercent(centerOptionArr[0], viewRect.width) + viewRect.x, parsePercent(centerOptionArr[1], viewRect.height) + viewRect.y];
	}
	return {
		viewRect,
		center
	};
}
function getCircleLayout(seriesModel, api) {
	var _a$1 = getViewRectAndCenterForCircleLayout(seriesModel, api), viewRect = _a$1.viewRect, center = _a$1.center;
	var radius = seriesModel.get("radius");
	if (!isArray(radius)) radius = [0, radius];
	var width = parsePercent(viewRect.width, api.getWidth());
	var height = parsePercent(viewRect.height, api.getHeight());
	var size = Math.min(width, height);
	var r0 = parsePercent(radius[0], size / 2);
	var r = parsePercent(radius[1], size / 2);
	return {
		cx: center[0],
		cy: center[1],
		r0,
		r,
		viewRect
	};
}
/**
* Parse position info.
*/
function getLayoutRect(positionInfo, containerRect, margin) {
	margin = normalizeCssArray(margin || 0);
	var containerWidth = containerRect.width;
	var containerHeight = containerRect.height;
	var left = parsePercent(positionInfo.left, containerWidth);
	var top = parsePercent(positionInfo.top, containerHeight);
	var right = parsePercent(positionInfo.right, containerWidth);
	var bottom = parsePercent(positionInfo.bottom, containerHeight);
	var width = parsePercent(positionInfo.width, containerWidth);
	var height = parsePercent(positionInfo.height, containerHeight);
	var verticalMargin = margin[2] + margin[0];
	var horizontalMargin = margin[1] + margin[3];
	var aspect = positionInfo.aspect;
	if (isNaN(width)) width = containerWidth - right - horizontalMargin - left;
	if (isNaN(height)) height = containerHeight - bottom - verticalMargin - top;
	if (aspect != null) {
		if (isNaN(width) && isNaN(height)) if (aspect > containerWidth / containerHeight) width = containerWidth * .8;
		else height = containerHeight * .8;
		if (isNaN(width)) width = aspect * height;
		if (isNaN(height)) height = width / aspect;
	}
	if (isNaN(left)) left = containerWidth - right - width - horizontalMargin;
	if (isNaN(top)) top = containerHeight - bottom - height - verticalMargin;
	switch (positionInfo.left || positionInfo.right) {
		case "center":
			left = containerWidth / 2 - width / 2 - margin[3];
			break;
		case "right":
			left = containerWidth - width - horizontalMargin;
			break;
	}
	switch (positionInfo.top || positionInfo.bottom) {
		case "middle":
		case "center":
			top = containerHeight / 2 - height / 2 - margin[0];
			break;
		case "bottom":
			top = containerHeight - height - verticalMargin;
			break;
	}
	left = left || 0;
	top = top || 0;
	if (isNaN(width)) width = containerWidth - horizontalMargin - left - (right || 0);
	if (isNaN(height)) height = containerHeight - verticalMargin - top - (bottom || 0);
	var rect = new BoundingRect_default((containerRect.x || 0) + left + margin[3], (containerRect.y || 0) + top + margin[0], width, height);
	rect.margin = margin;
	return rect;
}
/**
* PENDING:
*  when preserveAspect: 'cover' and aspect is near Infinity
*  or when preserveAspect: 'contain' and aspect is near 0,
*  the result width or height is near Inifity. It's logically correct,
*  Therefore currently we do not handle it, until bad cases arise.
*/
function applyPreserveAspect(component, layoutRect, aspect) {
	var preserveAspect = component.getShallow("preserveAspect", true);
	if (!preserveAspect) return layoutRect;
	var actualAspect = layoutRect.width / layoutRect.height;
	if (Math.abs(Math.atan(aspect) - Math.atan(actualAspect)) < 1e-9) return layoutRect;
	var preserveAspectAlign = component.getShallow("preserveAspectAlign", true);
	var preserveAspectVerticalAlign = component.getShallow("preserveAspectVerticalAlign", true);
	var layoutOptInner = {
		width: layoutRect.width,
		height: layoutRect.height
	};
	var isCover = preserveAspect === "cover";
	if (actualAspect > aspect && !isCover || actualAspect < aspect && isCover) {
		layoutOptInner.width = layoutRect.height * aspect;
		preserveAspectAlign === "left" ? layoutOptInner.left = 0 : preserveAspectAlign === "right" ? layoutOptInner.right = 0 : layoutOptInner.left = "center";
	} else {
		layoutOptInner.height = layoutRect.width / aspect;
		preserveAspectVerticalAlign === "top" ? layoutOptInner.top = 0 : preserveAspectVerticalAlign === "bottom" ? layoutOptInner.bottom = 0 : layoutOptInner.top = "middle";
	}
	return getLayoutRect(layoutOptInner, layoutRect);
}
var BoxLayoutReferenceType = {
	rect: 1,
	point: 2
};
/**
* Uniformly calculate layout reference (rect or center) based on either:
*  - viewport:
*      - Get `refContainer` as `{x: 0, y: 0, width: api.getWidth(), height: api.getHeight()}`
*  - coordinate system, which can serve in several ways:
*      - Use `dataToPoint` to get the `refPoint`, such as, in cartesian2d coord sys.
*      - Use `dataToLayout` to get the `refContainer`, such as, in matrix coord sys.
*/
function createBoxLayoutReference(model, api, opt) {
	var refContainer;
	var refPoint;
	var layoutRefType;
	var boxCoordSys = model.boxCoordinateSystem;
	var boxCoordFrom;
	if (boxCoordSys) {
		var _a$1 = getCoordForBoxCoordSys(model), coord = _a$1.coord, from = _a$1.from;
		if (boxCoordSys.dataToLayout) {
			layoutRefType = BoxLayoutReferenceType.rect;
			boxCoordFrom = from;
			var result = boxCoordSys.dataToLayout(coord);
			refContainer = result.contentRect || result.rect;
		} else if (opt && opt.enableLayoutOnlyByCenter && boxCoordSys.dataToPoint) {
			layoutRefType = BoxLayoutReferenceType.point;
			boxCoordFrom = from;
			refPoint = boxCoordSys.dataToPoint(coord);
		} else error(model.type + "[" + model.componentIndex + "]" + (" layout based on " + boxCoordSys.type + " is not supported."));
	}
	if (layoutRefType == null) layoutRefType = BoxLayoutReferenceType.rect;
	if (layoutRefType === BoxLayoutReferenceType.rect) {
		if (!refContainer) refContainer = {
			x: 0,
			y: 0,
			width: api.getWidth(),
			height: api.getHeight()
		};
		refPoint = [refContainer.x + refContainer.width / 2, refContainer.y + refContainer.height / 2];
	}
	return {
		type: layoutRefType,
		refContainer,
		refPoint,
		boxCoordFrom
	};
}
/**
* Position a zr element in viewport
*  Group position is specified by either
*  {left, top}, {right, bottom}
*  If all properties exists, right and bottom will be igonred.
*
* Logic:
*     1. Scale (against origin point in parent coord)
*     2. Rotate (against origin point in parent coord)
*     3. Translate (with el.position by this method)
* So this method only fixes the last step 'Translate', which does not affect
* scaling and rotating.
*
* If be called repeatedly with the same input el, the same result will be gotten.
*
* Return true if the layout happened.
*
* @param el Should have `getBoundingRect` method.
* @param positionInfo
* @param positionInfo.left
* @param positionInfo.top
* @param positionInfo.right
* @param positionInfo.bottom
* @param positionInfo.width Only for opt.boundingModel: 'raw'
* @param positionInfo.height Only for opt.boundingModel: 'raw'
* @param containerRect
* @param margin
* @param opt
* @param opt.hv Only horizontal or only vertical. Default to be [1, 1]
* @param opt.boundingMode
*        Specify how to calculate boundingRect when locating.
*        'all': Position the boundingRect that is transformed and uioned
*               both itself and its descendants.
*               This mode simplies confine the elements in the bounding
*               of their container (e.g., using 'right: 0').
*        'raw': Position the boundingRect that is not transformed and only itself.
*               This mode is useful when you want a element can overflow its
*               container. (Consider a rotated circle needs to be located in a corner.)
*               In this mode positionInfo.width/height can only be number.
*/
function positionElement(el, positionInfo, containerRect, margin, opt, out$1) {
	var h = !opt || !opt.hv || opt.hv[0];
	var v = !opt || !opt.hv || opt.hv[1];
	var boundingMode = opt && opt.boundingMode || "all";
	out$1 = out$1 || el;
	out$1.x = el.x;
	out$1.y = el.y;
	if (!h && !v) return false;
	var rect;
	if (boundingMode === "raw") rect = el.type === "group" ? new BoundingRect_default(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
	else {
		rect = el.getBoundingRect();
		if (el.needLocalTransform()) {
			var transform = el.getLocalTransform();
			rect = rect.clone();
			rect.applyTransform(transform);
		}
	}
	var layoutRect = getLayoutRect(defaults({
		width: rect.width,
		height: rect.height
	}, positionInfo), containerRect, margin);
	var dx = h ? layoutRect.x - rect.x : 0;
	var dy = v ? layoutRect.y - rect.y : 0;
	if (boundingMode === "raw") {
		out$1.x = dx;
		out$1.y = dy;
	} else {
		out$1.x += dx;
		out$1.y += dy;
	}
	if (out$1 === el) el.markRedraw();
	return true;
}
/**
* @param option Contains some of the properties in HV_NAMES.
* @param hvIdx 0: horizontal; 1: vertical.
*/
function sizeCalculable(option, hvIdx) {
	return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
function fetchLayoutMode(ins) {
	var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
	return isObject$1(layoutMode) ? layoutMode : layoutMode ? { type: layoutMode } : null;
}
/**
* Consider Case:
* When default option has {left: 0, width: 100}, and we set {right: 0}
* through setOption or media query, using normal zrUtil.merge will cause
* {right: 0} does not take effect.
*
* @example
* ComponentModel.extend({
*     init: function () {
*         ...
*         let inputPositionParams = layout.getLayoutParams(option);
*         this.mergeOption(inputPositionParams);
*     },
*     mergeOption: function (newOption) {
*         newOption && zrUtil.merge(thisOption, newOption, true);
*         layout.mergeLayoutParam(thisOption, newOption);
*     }
* });
*
* @param targetOption
* @param newOption
* @param opt
*/
function mergeLayoutParam(targetOption, newOption, opt) {
	var ignoreSize = opt && opt.ignoreSize;
	!isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
	var hResult = merge$1(HV_NAMES[0], 0);
	var vResult = merge$1(HV_NAMES[1], 1);
	copy$1(HV_NAMES[0], targetOption, hResult);
	copy$1(HV_NAMES[1], targetOption, vResult);
	function merge$1(names, hvIdx) {
		var newParams = {};
		var newValueCount = 0;
		var merged = {};
		var mergedValueCount = 0;
		var enoughParamNumber = 2;
		each$2(names, function(name) {
			merged[name] = targetOption[name];
		});
		each$2(names, function(name) {
			hasOwn(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
			hasValue(newParams, name) && newValueCount++;
			hasValue(merged, name) && mergedValueCount++;
		});
		if (ignoreSize[hvIdx]) {
			if (hasValue(newOption, names[1])) merged[names[2]] = null;
			else if (hasValue(newOption, names[2])) merged[names[1]] = null;
			return merged;
		}
		if (mergedValueCount === enoughParamNumber || !newValueCount) return merged;
		else if (newValueCount >= enoughParamNumber) return newParams;
		else {
			for (var i = 0; i < names.length; i++) {
				var name_1 = names[i];
				if (!hasOwn(newParams, name_1) && hasOwn(targetOption, name_1)) {
					newParams[name_1] = targetOption[name_1];
					break;
				}
			}
			return newParams;
		}
	}
	function hasValue(obj, name) {
		return obj[name] != null && obj[name] !== "auto";
	}
	function copy$1(names, target, source) {
		each$2(names, function(name) {
			target[name] = source[name];
		});
	}
}
/**
* Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
*/
function getLayoutParams(source) {
	return copyLayoutParams({}, source);
}
/**
* Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
* @param {Object} source
* @return {Object} Result contains those props.
*/
function copyLayoutParams(target, source) {
	source && target && each$2(LOCATION_PARAMS, function(name) {
		hasOwn(source, name) && (target[name] = source[name]);
	});
	return target;
}

//#endregion
//#region node_modules/echarts/lib/model/Component.js
init_tslib_es6();
var inner$4 = makeInner();
var ComponentModel = function(_super) {
	__extends(ComponentModel$1, _super);
	function ComponentModel$1(option, parentModel, ecModel) {
		var _this = _super.call(this, option, parentModel, ecModel) || this;
		_this.uid = getUID("ec_cpt_model");
		return _this;
	}
	ComponentModel$1.prototype.init = function(option, parentModel, ecModel) {
		this.mergeDefaultAndTheme(option, ecModel);
	};
	ComponentModel$1.prototype.mergeDefaultAndTheme = function(option, ecModel) {
		var layoutMode = fetchLayoutMode(this);
		var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
		var themeModel = ecModel.getTheme();
		merge(option, themeModel.get(this.mainType));
		merge(option, this.getDefaultOption());
		if (layoutMode) mergeLayoutParam(option, inputPositionParams, layoutMode);
	};
	ComponentModel$1.prototype.mergeOption = function(option, ecModel) {
		merge(this.option, option, true);
		var layoutMode = fetchLayoutMode(this);
		if (layoutMode) mergeLayoutParam(this.option, option, layoutMode);
	};
	/**
	* Called immediately after `init` or `mergeOption` of this instance called.
	*/
	ComponentModel$1.prototype.optionUpdated = function(newCptOption, isInit) {};
	/**
	* [How to declare defaultOption]:
	*
	* (A) If using class declaration in typescript (since echarts 5):
	* ```ts
	* import {ComponentOption} from '../model/option.js';
	* export interface XxxOption extends ComponentOption {
	*     aaa: number
	* }
	* export class XxxModel extends Component {
	*     static type = 'xxx';
	*     static defaultOption: XxxOption = {
	*         aaa: 123
	*     }
	* }
	* Component.registerClass(XxxModel);
	* ```
	* ```ts
	* import {inheritDefaultOption} from '../util/component.js';
	* import {XxxModel, XxxOption} from './XxxModel.js';
	* export interface XxxSubOption extends XxxOption {
	*     bbb: number
	* }
	* class XxxSubModel extends XxxModel {
	*     static defaultOption: XxxSubOption = inheritDefaultOption(XxxModel.defaultOption, {
	*         bbb: 456
	*     })
	*     fn() {
	*         let opt = this.getDefaultOption();
	*         // opt is {aaa: 123, bbb: 456}
	*     }
	* }
	* ```
	*
	* (B) If using class extend (previous approach in echarts 3 & 4):
	* ```js
	* let XxxComponent = Component.extend({
	*     defaultOption: {
	*         xx: 123
	*     }
	* })
	* ```
	* ```js
	* let XxxSubComponent = XxxComponent.extend({
	*     defaultOption: {
	*         yy: 456
	*     },
	*     fn: function () {
	*         let opt = this.getDefaultOption();
	*         // opt is {xx: 123, yy: 456}
	*     }
	* })
	* ```
	*/
	ComponentModel$1.prototype.getDefaultOption = function() {
		var ctor = this.constructor;
		if (!isExtendedClass(ctor)) return ctor.defaultOption;
		var fields = inner$4(this);
		if (!fields.defaultOption) {
			var optList = [];
			var clz = ctor;
			while (clz) {
				var opt = clz.prototype.defaultOption;
				opt && optList.push(opt);
				clz = clz.superClass;
			}
			var defaultOption = {};
			for (var i = optList.length - 1; i >= 0; i--) defaultOption = merge(defaultOption, optList[i], true);
			fields.defaultOption = defaultOption;
		}
		return fields.defaultOption;
	};
	/**
	* Notice: always force to input param `useDefault` in case that forget to consider it.
	* The same behavior as `modelUtil.parseFinder`.
	*
	* @param useDefault In many cases like series refer axis and axis refer grid,
	*        If axis index / axis id not specified, use the first target as default.
	*        In other cases like dataZoom refer axis, if not specified, measn no refer.
	*/
	ComponentModel$1.prototype.getReferringComponents = function(mainType, opt) {
		var indexKey = mainType + "Index";
		var idKey = mainType + "Id";
		return queryReferringComponents(this.ecModel, mainType, {
			index: this.get(indexKey, true),
			id: this.get(idKey, true)
		}, opt);
	};
	ComponentModel$1.prototype.getBoxLayoutParams = function() {
		return getBoxLayoutParams(this, false);
	};
	/**
	* Get key for zlevel.
	* If developers don't configure zlevel. We will assign zlevel to series based on the key.
	* For example, lines with trail effect and progressive series will in an individual zlevel.
	*/
	ComponentModel$1.prototype.getZLevelKey = function() {
		return "";
	};
	ComponentModel$1.prototype.setZLevel = function(zlevel) {
		this.option.zlevel = zlevel;
	};
	ComponentModel$1.protoInitialize = function() {
		var proto = ComponentModel$1.prototype;
		proto.type = "component";
		proto.id = "";
		proto.name = "";
		proto.mainType = "";
		proto.subType = "";
		proto.componentIndex = 0;
	}();
	return ComponentModel$1;
}(Model_default);
mountExtend(ComponentModel, Model_default);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
	var deps = [];
	each(ComponentModel.getClassesByMainType(componentType), function(clz) {
		deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
	});
	deps = map$1(deps, function(type) {
		return parseClassType(type).main;
	});
	if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) deps.unshift("dataset");
	return deps;
}
var Component_default$1 = ComponentModel;

//#endregion
//#region node_modules/echarts/lib/visual/tokens.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var tokens = {
	color: {},
	darkColor: {},
	size: {}
};
var color$1 = tokens.color = {
	theme: [
		"#5070dd",
		"#b6d634",
		"#505372",
		"#ff994d",
		"#0ca8df",
		"#ffd10a",
		"#fb628b",
		"#785db0",
		"#3fbe95"
	],
	neutral00: "#fff",
	neutral05: "#f4f7fd",
	neutral10: "#e8ebf0",
	neutral15: "#dbdee4",
	neutral20: "#cfd2d7",
	neutral25: "#c3c5cb",
	neutral30: "#b7b9be",
	neutral35: "#aaacb2",
	neutral40: "#9ea0a5",
	neutral45: "#929399",
	neutral50: "#86878c",
	neutral55: "#797b7f",
	neutral60: "#6d6e73",
	neutral65: "#616266",
	neutral70: "#54555a",
	neutral75: "#48494d",
	neutral80: "#3c3c41",
	neutral85: "#303034",
	neutral90: "#232328",
	neutral95: "#17171b",
	neutral99: "#000",
	accent05: "#eff1f9",
	accent10: "#e0e4f2",
	accent15: "#d0d6ec",
	accent20: "#c0c9e6",
	accent25: "#b1bbdf",
	accent30: "#a1aed9",
	accent35: "#91a0d3",
	accent40: "#8292cc",
	accent45: "#7285c6",
	accent50: "#6578ba",
	accent55: "#5c6da9",
	accent60: "#536298",
	accent65: "#4a5787",
	accent70: "#404c76",
	accent75: "#374165",
	accent80: "#2e3654",
	accent85: "#252b43",
	accent90: "#1b2032",
	accent95: "#121521",
	transparent: "rgba(0,0,0,0)",
	highlight: "rgba(255,231,130,0.8)"
};
extend(color$1, {
	primary: color$1.neutral80,
	secondary: color$1.neutral70,
	tertiary: color$1.neutral60,
	quaternary: color$1.neutral50,
	disabled: color$1.neutral20,
	border: color$1.neutral30,
	borderTint: color$1.neutral20,
	borderShade: color$1.neutral40,
	background: color$1.neutral05,
	backgroundTint: "rgba(234,237,245,0.5)",
	backgroundTransparent: "rgba(255,255,255,0)",
	backgroundShade: color$1.neutral10,
	shadow: "rgba(0,0,0,0.2)",
	shadowTint: "rgba(129,130,136,0.2)",
	axisLine: color$1.neutral70,
	axisLineTint: color$1.neutral40,
	axisTick: color$1.neutral70,
	axisTickMinor: color$1.neutral60,
	axisLabel: color$1.neutral70,
	axisSplitLine: color$1.neutral15,
	axisMinorSplitLine: color$1.neutral05
});
for (var key in color$1) if (color$1.hasOwnProperty(key)) {
	var hex = color$1[key];
	if (key === "theme") tokens.darkColor.theme = color$1.theme.slice();
	else if (key === "highlight") tokens.darkColor.highlight = "rgba(255,231,130,0.4)";
	else if (key.indexOf("accent") === 0) tokens.darkColor[key] = modifyHSL(hex, null, function(s) {
		return s * .5;
	}, function(l) {
		return Math.min(1, 1.3 - l);
	});
	else tokens.darkColor[key] = modifyHSL(hex, null, function(s) {
		return s * .9;
	}, function(l) {
		return 1 - Math.pow(l, 1.5);
	});
}
tokens.size = {
	xxs: 2,
	xs: 5,
	s: 10,
	m: 15,
	l: 20,
	xl: 30,
	xxl: 40,
	xxxl: 50
};
var tokens_default = tokens;

//#endregion
//#region node_modules/echarts/lib/coord/axisModelCommonMixin.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var AxisModelCommonMixin = function() {
	function AxisModelCommonMixin$1() {}
	AxisModelCommonMixin$1.prototype.getNeedCrossZero = function() {
		return !this.option.scale;
	};
	/**
	* Should be implemented by each axis model if necessary.
	* @return coordinate system model
	*/
	AxisModelCommonMixin$1.prototype.getCoordSysModel = function() {};
	return AxisModelCommonMixin$1;
}();

//#endregion
//#region node_modules/echarts/lib/data/OrdinalMeta.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var uidBase = 0;
var OrdinalMeta = function() {
	/**
	* PENDING - Regarding forcibly converting to string:
	*  In the early days, the underlying hash map impl used JS plain object and converted the key to
	*  string; later in https://github.com/ecomfe/zrender/pull/966 it was changed to a JS Map (in supported
	*  platforms), which does not require string keys. But consider any input that `scale/Ordinal['parse']`
	*  is involved, a number input represents an `OrdinalNumber` (i.e., an index), and affect the query
	*  behavior:
	*    - If forcbily converting to string:
	*      pros: users can use numeric string (such as, '123') to query the raw data (123), tho it's probably
	*      still confusing.
	*      cons: NaN/null/undefined in data will be equals to 'NaN'/'null'/'undefined', if simply using
	*      `val + ''` to convert them, like currently `getName` does.
	*    - Otherwise:
	*      pros: see NaN/null/undefined case above.
	*      cons: users cannot query the raw data (123) any more.
	*  There are two inconsistent behaviors in the current impl:
	*    - Force conversion is applied on the case `xAxis{data: ['aaa', 'bbb', ...]}`,
	*      but no conversion applied to the case `xAxis{data: [{value: 'aaa'}, ...]}` and
	*      the case `dataset: {source: [['aaa', 123], ['bbb', 234], ...]}`.
	*    - behaves differently according to whether JS Map is supported (the polyfill is simply using JS
	*      plain object) (tho it seems rare platform that do not support it).
	*  Since there's no sufficient good solution to offset cost of the breaking change, we preserve the
	*  current behavior, until real issues is reported.
	*/
	function OrdinalMeta$1(opt) {
		this.categories = opt.categories || [];
		this._needCollect = opt.needCollect;
		this._deduplication = opt.deduplication;
		this.uid = ++uidBase;
		this._onCollect = opt.onCollect;
	}
	OrdinalMeta$1.createByAxisModel = function(axisModel) {
		var option = axisModel.option;
		var data = option.data;
		var categories = data && map$1(data, getName);
		return new OrdinalMeta$1({
			categories,
			needCollect: !categories,
			deduplication: option.dedplication !== false
		});
	};
	OrdinalMeta$1.prototype.getOrdinal = function(category) {
		return this._getOrCreateMap().get(category);
	};
	/**
	* @return The ordinal. If not found, return NaN.
	*/
	OrdinalMeta$1.prototype.parseAndCollect = function(category) {
		var index;
		var needCollect = this._needCollect;
		if (!isString(category) && !needCollect) return category;
		if (needCollect && !this._deduplication) {
			index = this.categories.length;
			this.categories[index] = category;
			this._onCollect && this._onCollect(category, index);
			return index;
		}
		var map$2 = this._getOrCreateMap();
		index = map$2.get(category);
		if (index == null) if (needCollect) {
			index = this.categories.length;
			this.categories[index] = category;
			map$2.set(category, index);
			this._onCollect && this._onCollect(category, index);
		} else index = NaN;
		return index;
	};
	OrdinalMeta$1.prototype._getOrCreateMap = function() {
		return this._map || (this._map = createHashMap(this.categories));
	};
	return OrdinalMeta$1;
}();
function getName(obj) {
	if (isObject$1(obj) && obj.value != null) return obj.value;
	else return obj + "";
}
var OrdinalMeta_default = OrdinalMeta;

//#endregion
//#region node_modules/echarts/lib/scale/helper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function isValueNice(val) {
	var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
	var f = Math.abs(val / exp10);
	return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;
}
function isIntervalOrLogScale(scale$2) {
	return scale$2.type === "interval" || scale$2.type === "log";
}
/**
* @param extent Both extent[0] and extent[1] should be valid number.
*               Should be extent[0] < extent[1].
* @param splitNumber splitNumber should be >= 1.
*/
function intervalScaleNiceTicks(extent, spanWithBreaks, splitNumber, minInterval, maxInterval) {
	var result = {};
	var interval = result.interval = nice(spanWithBreaks / splitNumber, true);
	if (minInterval != null && interval < minInterval) interval = result.interval = minInterval;
	if (maxInterval != null && interval > maxInterval) interval = result.interval = maxInterval;
	var precision = result.intervalPrecision = getIntervalPrecision(interval);
	fixExtent(result.niceTickExtent = [round(Math.ceil(extent[0] / interval) * interval, precision), round(Math.floor(extent[1] / interval) * interval, precision)], extent);
	return result;
}
function increaseInterval(interval) {
	var exp10 = Math.pow(10, quantityExponent(interval));
	var f = interval / exp10;
	if (!f) f = 1;
	else if (f === 2) f = 3;
	else if (f === 3) f = 5;
	else f *= 2;
	return round(f * exp10);
}
/**
* @return interval precision
*/
function getIntervalPrecision(interval) {
	return getPrecision(interval) + 2;
}
function clamp(niceTickExtent, idx, extent) {
	niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
}
function fixExtent(niceTickExtent, extent) {
	!isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
	!isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
	clamp(niceTickExtent, 0, extent);
	clamp(niceTickExtent, 1, extent);
	if (niceTickExtent[0] > niceTickExtent[1]) niceTickExtent[0] = niceTickExtent[1];
}
function contain$1(val, extent) {
	return val >= extent[0] && val <= extent[1];
}
var ScaleCalculator = function() {
	function ScaleCalculator$1() {
		this.normalize = normalize;
		this.scale = scale;
	}
	ScaleCalculator$1.prototype.updateMethods = function(brkCtx) {
		if (brkCtx.hasBreaks()) {
			this.normalize = bind(brkCtx.normalize, brkCtx);
			this.scale = bind(brkCtx.scale, brkCtx);
		} else {
			this.normalize = normalize;
			this.scale = scale;
		}
	};
	return ScaleCalculator$1;
}();
function normalize(val, extent) {
	if (extent[1] === extent[0]) return .5;
	return (val - extent[0]) / (extent[1] - extent[0]);
}
function scale(val, extent) {
	return val * (extent[1] - extent[0]) + extent[0];
}
function logTransform(base$1, extent, noClampNegative) {
	var loggedBase = Math.log(base$1);
	return [Math.log(noClampNegative ? extent[0] : Math.max(0, extent[0])) / loggedBase, Math.log(noClampNegative ? extent[1] : Math.max(0, extent[1])) / loggedBase];
}

//#endregion
//#region node_modules/echarts/lib/scale/Scale.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var Scale = function() {
	function Scale$1(setting) {
		this._calculator = new ScaleCalculator();
		this._setting = setting || {};
		this._extent = [Infinity, -Infinity];
		var scaleBreakHelper = getScaleBreakHelper();
		if (scaleBreakHelper) {
			this._brkCtx = scaleBreakHelper.createScaleBreakContext();
			this._brkCtx.update(this._extent);
		}
	}
	Scale$1.prototype.getSetting = function(name) {
		return this._setting[name];
	};
	/**
	* [CAVEAT]: It should not be overridden!
	*/
	Scale$1.prototype._innerUnionExtent = function(other) {
		var extent = this._extent;
		this._innerSetExtent(other[0] < extent[0] ? other[0] : extent[0], other[1] > extent[1] ? other[1] : extent[1]);
	};
	/**
	* Set extent from data
	*/
	Scale$1.prototype.unionExtentFromData = function(data, dim) {
		this._innerUnionExtent(data.getApproximateExtent(dim));
	};
	/**
	* Get a new slice of extent.
	* Extent is always in increase order.
	*/
	Scale$1.prototype.getExtent = function() {
		return this._extent.slice();
	};
	Scale$1.prototype.setExtent = function(start, end) {
		this._innerSetExtent(start, end);
	};
	/**
	* [CAVEAT]: It should not be overridden!
	*/
	Scale$1.prototype._innerSetExtent = function(start, end) {
		var thisExtent = this._extent;
		if (!isNaN(start)) thisExtent[0] = start;
		if (!isNaN(end)) thisExtent[1] = end;
		this._brkCtx && this._brkCtx.update(thisExtent);
	};
	/**
	* Prerequisite: Scale#parse is ready.
	*/
	Scale$1.prototype.setBreaksFromOption = function(breakOptionList) {
		var scaleBreakHelper = getScaleBreakHelper();
		if (scaleBreakHelper) this._innerSetBreak(scaleBreakHelper.parseAxisBreakOption(breakOptionList, bind(this.parse, this)));
	};
	/**
	* [CAVEAT]: It should not be overridden!
	*/
	Scale$1.prototype._innerSetBreak = function(parsed) {
		if (this._brkCtx) {
			this._brkCtx.setBreaks(parsed);
			this._calculator.updateMethods(this._brkCtx);
			this._brkCtx.update(this._extent);
		}
	};
	/**
	* [CAVEAT]: It should not be overridden!
	*/
	Scale$1.prototype._innerGetBreaks = function() {
		return this._brkCtx ? this._brkCtx.breaks : [];
	};
	/**
	* Do not expose the internal `_breaks` unless necessary.
	*/
	Scale$1.prototype.hasBreaks = function() {
		return this._brkCtx ? this._brkCtx.hasBreaks() : false;
	};
	Scale$1.prototype._getExtentSpanWithBreaks = function() {
		return this._brkCtx && this._brkCtx.hasBreaks() ? this._brkCtx.getExtentSpan() : this._extent[1] - this._extent[0];
	};
	/**
	* If value is in extent range
	*/
	Scale$1.prototype.isInExtentRange = function(value) {
		return this._extent[0] <= value && this._extent[1] >= value;
	};
	/**
	* When axis extent depends on data and no data exists,
	* axis ticks should not be drawn, which is named 'blank'.
	*/
	Scale$1.prototype.isBlank = function() {
		return this._isBlank;
	};
	/**
	* When axis extent depends on data and no data exists,
	* axis ticks should not be drawn, which is named 'blank'.
	*/
	Scale$1.prototype.setBlank = function(isBlank) {
		this._isBlank = isBlank;
	};
	return Scale$1;
}();
enableClassManagement(Scale);
var Scale_default = Scale;

//#endregion
//#region node_modules/echarts/lib/scale/Ordinal.js
/**
* Linear continuous scale
* http://en.wikipedia.org/wiki/Level_of_measurement
*/
init_tslib_es6();
var OrdinalScale = function(_super) {
	__extends(OrdinalScale$1, _super);
	function OrdinalScale$1(setting) {
		var _this = _super.call(this, setting) || this;
		_this.type = "ordinal";
		var ordinalMeta = _this.getSetting("ordinalMeta");
		if (!ordinalMeta) ordinalMeta = new OrdinalMeta_default({});
		if (isArray(ordinalMeta)) ordinalMeta = new OrdinalMeta_default({ categories: map$1(ordinalMeta, function(item) {
			return isObject$1(item) ? item.value : item;
		}) });
		_this._ordinalMeta = ordinalMeta;
		_this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
		return _this;
	}
	OrdinalScale$1.prototype.parse = function(val) {
		if (val == null) return NaN;
		return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
	};
	OrdinalScale$1.prototype.contain = function(val) {
		return contain$1(val, this._extent) && val >= 0 && val < this._ordinalMeta.categories.length;
	};
	/**
	* Normalize given rank or name to linear [0, 1]
	* @param val raw ordinal number.
	* @return normalized value in [0, 1].
	*/
	OrdinalScale$1.prototype.normalize = function(val) {
		val = this._getTickNumber(val);
		return this._calculator.normalize(val, this._extent);
	};
	/**
	* @param val normalized value in [0, 1].
	* @return raw ordinal number.
	*/
	OrdinalScale$1.prototype.scale = function(val) {
		val = Math.round(this._calculator.scale(val, this._extent));
		return this.getRawOrdinalNumber(val);
	};
	OrdinalScale$1.prototype.getTicks = function() {
		var ticks = [];
		var extent = this._extent;
		var rank = extent[0];
		while (rank <= extent[1]) {
			ticks.push({ value: rank });
			rank++;
		}
		return ticks;
	};
	OrdinalScale$1.prototype.getMinorTicks = function(splitNumber) {};
	/**
	* @see `Ordinal['_ordinalNumbersByTick']`
	*/
	OrdinalScale$1.prototype.setSortInfo = function(info) {
		if (info == null) {
			this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
			return;
		}
		var infoOrdinalNumbers = info.ordinalNumbers;
		var ordinalsByTick = this._ordinalNumbersByTick = [];
		var ticksByOrdinal = this._ticksByOrdinalNumber = [];
		var tickNum = 0;
		var allCategoryLen = this._ordinalMeta.categories.length;
		for (var len = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len; ++tickNum) {
			var ordinalNumber = infoOrdinalNumbers[tickNum];
			ordinalsByTick[tickNum] = ordinalNumber;
			ticksByOrdinal[ordinalNumber] = tickNum;
		}
		var unusedOrdinal = 0;
		for (; tickNum < allCategoryLen; ++tickNum) {
			while (ticksByOrdinal[unusedOrdinal] != null) unusedOrdinal++;
			ordinalsByTick.push(unusedOrdinal);
			ticksByOrdinal[unusedOrdinal] = tickNum;
		}
	};
	OrdinalScale$1.prototype._getTickNumber = function(ordinal) {
		var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
		return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
	};
	/**
	* @usage
	* ```js
	* const ordinalNumber = ordinalScale.getRawOrdinalNumber(tickVal);
	*
	* // case0
	* const rawOrdinalValue = axisModel.getCategories()[ordinalNumber];
	* // case1
	* const rawOrdinalValue = this._ordinalMeta.categories[ordinalNumber];
	* // case2
	* const coord = axis.dataToCoord(ordinalNumber);
	* ```
	*
	* @param {OrdinalNumber} tickNumber index of display
	*/
	OrdinalScale$1.prototype.getRawOrdinalNumber = function(tickNumber) {
		var ordinalNumbersByTick = this._ordinalNumbersByTick;
		return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
	};
	/**
	* Get item on tick
	*/
	OrdinalScale$1.prototype.getLabel = function(tick) {
		if (!this.isBlank()) {
			var ordinalNumber = this.getRawOrdinalNumber(tick.value);
			var cateogry = this._ordinalMeta.categories[ordinalNumber];
			return cateogry == null ? "" : cateogry + "";
		}
	};
	OrdinalScale$1.prototype.count = function() {
		return this._extent[1] - this._extent[0] + 1;
	};
	/**
	* @override
	* If value is in extent range
	*/
	OrdinalScale$1.prototype.isInExtentRange = function(value) {
		value = this._getTickNumber(value);
		return this._extent[0] <= value && this._extent[1] >= value;
	};
	OrdinalScale$1.prototype.getOrdinalMeta = function() {
		return this._ordinalMeta;
	};
	OrdinalScale$1.prototype.calcNiceTicks = function() {};
	OrdinalScale$1.prototype.calcNiceExtent = function() {};
	OrdinalScale$1.type = "ordinal";
	return OrdinalScale$1;
}(Scale_default);
Scale_default.registerClass(OrdinalScale);
var Ordinal_default = OrdinalScale;

//#endregion
//#region node_modules/echarts/lib/scale/Interval.js
init_tslib_es6();
var roundNumber = round;
var IntervalScale = function(_super) {
	__extends(IntervalScale$1, _super);
	function IntervalScale$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "interval";
		_this._interval = 0;
		_this._intervalPrecision = 2;
		return _this;
	}
	IntervalScale$1.prototype.parse = function(val) {
		return val == null || val === "" ? NaN : Number(val);
	};
	IntervalScale$1.prototype.contain = function(val) {
		return contain$1(val, this._extent);
	};
	IntervalScale$1.prototype.normalize = function(val) {
		return this._calculator.normalize(val, this._extent);
	};
	IntervalScale$1.prototype.scale = function(val) {
		return this._calculator.scale(val, this._extent);
	};
	IntervalScale$1.prototype.getInterval = function() {
		return this._interval;
	};
	IntervalScale$1.prototype.setInterval = function(interval) {
		this._interval = interval;
		this._niceExtent = this._extent.slice();
		this._intervalPrecision = getIntervalPrecision(interval);
	};
	/**
	* @override
	*/
	IntervalScale$1.prototype.getTicks = function(opt) {
		opt = opt || {};
		var interval = this._interval;
		var extent = this._extent;
		var niceTickExtent = this._niceExtent;
		var intervalPrecision = this._intervalPrecision;
		var scaleBreakHelper = getScaleBreakHelper();
		var ticks = [];
		if (!interval) return ticks;
		if (opt.breakTicks === "only_break" && scaleBreakHelper) {
			scaleBreakHelper.addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
			return ticks;
		}
		var safeLimit = 1e4;
		if (extent[0] < niceTickExtent[0]) if (opt.expandToNicedExtent) ticks.push({ value: roundNumber(niceTickExtent[0] - interval, intervalPrecision) });
		else ticks.push({ value: extent[0] });
		var estimateNiceMultiple = function(tickVal, targetTick) {
			return Math.round((targetTick - tickVal) / interval);
		};
		var tick = niceTickExtent[0];
		while (tick <= niceTickExtent[1]) {
			ticks.push({ value: tick });
			tick = roundNumber(tick + interval, intervalPrecision);
			if (this._brkCtx) {
				var moreMultiple = this._brkCtx.calcNiceTickMultiple(tick, estimateNiceMultiple);
				if (moreMultiple >= 0) tick = roundNumber(tick + moreMultiple * interval, intervalPrecision);
			}
			if (ticks.length > 0 && tick === ticks[ticks.length - 1].value) break;
			if (ticks.length > safeLimit) return [];
		}
		var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
		if (extent[1] > lastNiceTick) if (opt.expandToNicedExtent) ticks.push({ value: roundNumber(lastNiceTick + interval, intervalPrecision) });
		else ticks.push({ value: extent[1] });
		if (scaleBreakHelper) scaleBreakHelper.pruneTicksByBreak(opt.pruneByBreak, ticks, this._brkCtx.breaks, function(item) {
			return item.value;
		}, this._interval, this._extent);
		if (opt.breakTicks !== "none" && scaleBreakHelper) scaleBreakHelper.addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
		return ticks;
	};
	IntervalScale$1.prototype.getMinorTicks = function(splitNumber) {
		var ticks = this.getTicks({ expandToNicedExtent: true });
		var minorTicks = [];
		var extent = this.getExtent();
		for (var i = 1; i < ticks.length; i++) {
			var nextTick = ticks[i];
			var prevTick = ticks[i - 1];
			if (prevTick["break"] || nextTick["break"]) continue;
			var count = 0;
			var minorTicksGroup = [];
			var minorInterval = (nextTick.value - prevTick.value) / splitNumber;
			var minorIntervalPrecision = getIntervalPrecision(minorInterval);
			while (count < splitNumber - 1) {
				var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval, minorIntervalPrecision);
				if (minorTick > extent[0] && minorTick < extent[1]) minorTicksGroup.push(minorTick);
				count++;
			}
			var scaleBreakHelper = getScaleBreakHelper();
			scaleBreakHelper && scaleBreakHelper.pruneTicksByBreak("auto", minorTicksGroup, this._getNonTransBreaks(), function(value) {
				return value;
			}, this._interval, extent);
			minorTicks.push(minorTicksGroup);
		}
		return minorTicks;
	};
	IntervalScale$1.prototype._getNonTransBreaks = function() {
		return this._brkCtx ? this._brkCtx.breaks : [];
	};
	/**
	* @param opt.precision If 'auto', use nice presision.
	* @param opt.pad returns 1.50 but not 1.5 if precision is 2.
	*/
	IntervalScale$1.prototype.getLabel = function(data, opt) {
		if (data == null) return "";
		var precision = opt && opt.precision;
		if (precision == null) precision = getPrecision(data.value) || 0;
		else if (precision === "auto") precision = this._intervalPrecision;
		var dataNum = roundNumber(data.value, precision, true);
		return addCommas(dataNum);
	};
	/**
	* FIXME: refactor - disallow override, use composition instead.
	*
	* The override of `calcNiceTicks` should ensure these members are provided:
	*  this._intervalPrecision
	*  this._interval
	*
	* @param splitNumber By default `5`.
	*/
	IntervalScale$1.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
		splitNumber = splitNumber || 5;
		var extent = this._extent.slice();
		var span = this._getExtentSpanWithBreaks();
		if (!isFinite(span)) return;
		if (span < 0) {
			span = -span;
			extent.reverse();
			this._innerSetExtent(extent[0], extent[1]);
			extent = this._extent.slice();
		}
		var result = intervalScaleNiceTicks(extent, span, splitNumber, minInterval, maxInterval);
		this._intervalPrecision = result.intervalPrecision;
		this._interval = result.interval;
		this._niceExtent = result.niceTickExtent;
	};
	IntervalScale$1.prototype.calcNiceExtent = function(opt) {
		var extent = this._extent.slice();
		if (extent[0] === extent[1]) if (extent[0] !== 0) {
			var expandSize = Math.abs(extent[0]);
			if (!opt.fixMax) {
				extent[1] += expandSize / 2;
				extent[0] -= expandSize / 2;
			} else extent[0] -= expandSize / 2;
		} else extent[1] = 1;
		var span = extent[1] - extent[0];
		if (!isFinite(span)) {
			extent[0] = 0;
			extent[1] = 1;
		}
		this._innerSetExtent(extent[0], extent[1]);
		extent = this._extent.slice();
		this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
		var interval = this._interval;
		var intervalPrecition = this._intervalPrecision;
		if (!opt.fixMin) extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval, intervalPrecition);
		if (!opt.fixMax) extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval, intervalPrecition);
		this._innerSetExtent(extent[0], extent[1]);
	};
	IntervalScale$1.prototype.setNiceExtent = function(min$1, max$1) {
		this._niceExtent = [min$1, max$1];
	};
	IntervalScale$1.type = "interval";
	return IntervalScale$1;
}(Scale_default);
Scale_default.registerClass(IntervalScale);
var Interval_default = IntervalScale;

//#endregion
//#region node_modules/echarts/lib/util/types.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var VISUAL_DIMENSIONS = createHashMap([
	"tooltip",
	"label",
	"itemName",
	"itemId",
	"itemGroupId",
	"itemChildGroupId",
	"seriesName"
]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";

//#endregion
//#region node_modules/echarts/lib/data/helper/sourceHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var BE_ORDINAL = {
	Must: 1,
	Might: 2,
	Not: 3
};
var innerGlobalModel = makeInner();
/**
* MUST be called before mergeOption of all series.
*/
function resetSourceDefaulter(ecModel) {
	innerGlobalModel(ecModel).datasetMap = createHashMap();
}
/**
* [The strategy of the arrengment of data dimensions for dataset]:
* "value way": all axes are non-category axes. So series one by one take
*     several (the number is coordSysDims.length) dimensions from dataset.
*     The result of data arrengment of data dimensions like:
*     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |
* "category way": at least one axis is category axis. So the the first data
*     dimension is always mapped to the first category axis and shared by
*     all of the series. The other data dimensions are taken by series like
*     "value way" does.
*     The result of data arrengment of data dimensions like:
*     | ser_shared_x | ser0_y | ser1_y | ser2_y |
*
* @return encode Never be `null/undefined`.
*/
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
	var encode = {};
	var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
	if (!datasetModel || !coordDimensions) return encode;
	var encodeItemName = [];
	var encodeSeriesName = [];
	var ecModel = seriesModel.ecModel;
	var datasetMap = innerGlobalModel(ecModel).datasetMap;
	var key$1 = datasetModel.uid + "_" + source.seriesLayoutBy;
	var baseCategoryDimIndex;
	var categoryWayValueDimStart;
	coordDimensions = coordDimensions.slice();
	each(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
		var coordDimInfo = isObject$1(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = { name: coordDimInfoLoose };
		if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
			baseCategoryDimIndex = coordDimIdx;
			categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
		}
		encode[coordDimInfo.name] = [];
	});
	var datasetRecord = datasetMap.get(key$1) || datasetMap.set(key$1, {
		categoryWayDim: categoryWayValueDimStart,
		valueWayDim: 0
	});
	each(coordDimensions, function(coordDimInfo, coordDimIdx) {
		var coordDimName = coordDimInfo.name;
		var count = getDataDimCountOnCoordDim(coordDimInfo);
		if (baseCategoryDimIndex == null) {
			var start = datasetRecord.valueWayDim;
			pushDim(encode[coordDimName], start, count);
			pushDim(encodeSeriesName, start, count);
			datasetRecord.valueWayDim += count;
		} else if (baseCategoryDimIndex === coordDimIdx) {
			pushDim(encode[coordDimName], 0, count);
			pushDim(encodeItemName, 0, count);
		} else {
			var start = datasetRecord.categoryWayDim;
			pushDim(encode[coordDimName], start, count);
			pushDim(encodeSeriesName, start, count);
			datasetRecord.categoryWayDim += count;
		}
	});
	function pushDim(dimIdxArr, idxFrom, idxCount) {
		for (var i = 0; i < idxCount; i++) dimIdxArr.push(idxFrom + i);
	}
	function getDataDimCountOnCoordDim(coordDimInfo) {
		var dimsDef = coordDimInfo.dimsDef;
		return dimsDef ? dimsDef.length : 1;
	}
	encodeItemName.length && (encode.itemName = encodeItemName);
	encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
	return encode;
}
/**
* Work for data like [{name: ..., value: ...}, ...].
*
* @return encode Never be `null/undefined`.
*/
function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
	var encode = {};
	if (!querySeriesUpstreamDatasetModel(seriesModel)) return encode;
	var sourceFormat = source.sourceFormat;
	var dimensionsDefine = source.dimensionsDefine;
	var potentialNameDimIndex;
	if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) each(dimensionsDefine, function(dim, idx) {
		if ((isObject$1(dim) ? dim.name : dim) === "name") potentialNameDimIndex = idx;
	});
	var idxResult = function() {
		var idxRes0 = {};
		var idxRes1 = {};
		var guessRecords = [];
		for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {
			var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
			guessRecords.push(guessResult);
			var isPureNumber = guessResult === BE_ORDINAL.Not;
			if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) idxRes0.v = i;
			if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) idxRes0.n = i;
			if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) return idxRes0;
			if (!isPureNumber) {
				if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) idxRes1.v = i;
				if (idxRes1.n == null || idxRes1.n === idxRes1.v) idxRes1.n = i;
			}
		}
		function fulfilled(idxResult$1) {
			return idxResult$1.v != null && idxResult$1.n != null;
		}
		return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
	}();
	if (idxResult) {
		encode.value = [idxResult.v];
		var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
		encode.itemName = [nameDimIndex];
		encode.seriesName = [nameDimIndex];
	}
	return encode;
}
/**
* @return If return null/undefined, indicate that should not use datasetModel.
*/
function querySeriesUpstreamDatasetModel(seriesModel) {
	if (!seriesModel.get("data", true)) return queryReferringComponents(seriesModel.ecModel, "dataset", {
		index: seriesModel.get("datasetIndex", true),
		id: seriesModel.get("datasetId", true)
	}, SINGLE_REFERRING).models[0];
}
/**
* @return Always return an array event empty.
*/
function queryDatasetUpstreamDatasetModels(datasetModel) {
	if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) return [];
	return queryReferringComponents(datasetModel.ecModel, "dataset", {
		index: datasetModel.get("fromDatasetIndex", true),
		id: datasetModel.get("fromDatasetId", true)
	}, SINGLE_REFERRING).models;
}
/**
* The rule should not be complex, otherwise user might not
* be able to known where the data is wrong.
* The code is ugly, but how to make it neat?
*/
function guessOrdinal(source, dimIndex) {
	return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
}
function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
	var result;
	var maxLoop = 5;
	if (isTypedArray(data)) return BE_ORDINAL.Not;
	var dimName;
	var dimType;
	if (dimensionsDefine) {
		var dimDefItem = dimensionsDefine[dimIndex];
		if (isObject$1(dimDefItem)) {
			dimName = dimDefItem.name;
			dimType = dimDefItem.type;
		} else if (isString(dimDefItem)) dimName = dimDefItem;
	}
	if (dimType != null) return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
	if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
		var dataArrayRows = data;
		if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
			var sample = dataArrayRows[dimIndex];
			for (var i = 0; i < (sample || []).length && i < maxLoop; i++) if ((result = detectValue(sample[startIndex + i])) != null) return result;
		} else for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
			var row = dataArrayRows[startIndex + i];
			if (row && (result = detectValue(row[dimIndex])) != null) return result;
		}
	} else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
		var dataObjectRows = data;
		if (!dimName) return BE_ORDINAL.Not;
		for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
			var item = dataObjectRows[i];
			if (item && (result = detectValue(item[dimName])) != null) return result;
		}
	} else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
		var dataKeyedColumns = data;
		if (!dimName) return BE_ORDINAL.Not;
		var sample = dataKeyedColumns[dimName];
		if (!sample || isTypedArray(sample)) return BE_ORDINAL.Not;
		for (var i = 0; i < sample.length && i < maxLoop; i++) if ((result = detectValue(sample[i])) != null) return result;
	} else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
		var dataOriginal = data;
		for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
			var item = dataOriginal[i];
			var val = getDataItemValue(item);
			if (!isArray(val)) return BE_ORDINAL.Not;
			if ((result = detectValue(val[dimIndex])) != null) return result;
		}
	}
	function detectValue(val$1) {
		var beStr = isString(val$1);
		if (val$1 != null && Number.isFinite(Number(val$1)) && val$1 !== "") return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
		else if (beStr && val$1 !== "-") return BE_ORDINAL.Must;
	}
	return BE_ORDINAL.Not;
}

//#endregion
//#region node_modules/echarts/lib/data/Source.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var SourceImpl = function() {
	function SourceImpl$1(fields) {
		this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
		this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
		this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
		this.startIndex = fields.startIndex || 0;
		this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
		this.metaRawOption = fields.metaRawOption;
		var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
		if (dimensionsDefine) for (var i = 0; i < dimensionsDefine.length; i++) {
			var dim = dimensionsDefine[i];
			if (dim.type == null) {
				if (guessOrdinal(this, i) === BE_ORDINAL.Must) dim.type = "ordinal";
			}
		}
	}
	return SourceImpl$1;
}();
function isSourceInstance(val) {
	return val instanceof SourceImpl;
}
/**
* Create a source from option.
* NOTE: Created source is immutable. Don't change any properties in it.
*/
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
	sourceFormat = sourceFormat || detectSourceFormat(sourceData);
	var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
	var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
	return new SourceImpl({
		data: sourceData,
		sourceFormat,
		seriesLayoutBy,
		dimensionsDefine: determined.dimensionsDefine,
		startIndex: determined.startIndex,
		dimensionsDetectedCount: determined.dimensionsDetectedCount,
		metaRawOption: clone(thisMetaRawOption)
	});
}
/**
* Wrap original series data for some compatibility cases.
*/
function createSourceFromSeriesDataOption(data) {
	return new SourceImpl({
		data,
		sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
	});
}
/**
* Clone source but excludes source data.
*/
function cloneSourceShallow(source) {
	return new SourceImpl({
		data: source.data,
		sourceFormat: source.sourceFormat,
		seriesLayoutBy: source.seriesLayoutBy,
		dimensionsDefine: clone(source.dimensionsDefine),
		startIndex: source.startIndex,
		dimensionsDetectedCount: source.dimensionsDetectedCount
	});
}
/**
* Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.
*/
function detectSourceFormat(data) {
	var sourceFormat = SOURCE_FORMAT_UNKNOWN;
	if (isTypedArray(data)) sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
	else if (isArray(data)) {
		if (data.length === 0) sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
		for (var i = 0, len = data.length; i < len; i++) {
			var item = data[i];
			if (item == null) continue;
			else if (isArray(item) || isTypedArray(item)) {
				sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
				break;
			} else if (isObject$1(item)) {
				sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
				break;
			}
		}
	} else if (isObject$1(data)) {
		for (var key$1 in data) if (hasOwn(data, key$1) && isArrayLike(data[key$1])) {
			sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
			break;
		}
	}
	return sourceFormat;
}
/**
* Determine the source definitions from data standalone dimensions definitions
* are not specified.
*/
function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
	var dimensionsDetectedCount;
	var startIndex;
	if (!data) return {
		dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
		startIndex,
		dimensionsDetectedCount
	};
	if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
		var dataArrayRows = data;
		if (sourceHeader === "auto" || sourceHeader == null) arrayRowsTravelFirst(function(val) {
			if (val != null && val !== "-") if (isString(val)) startIndex ??= 1;
			else startIndex = 0;
		}, seriesLayoutBy, dataArrayRows, 10);
		else startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
		if (!dimensionsDefine && startIndex === 1) {
			dimensionsDefine = [];
			arrayRowsTravelFirst(function(val, index) {
				dimensionsDefine[index] = val != null ? val + "" : "";
			}, seriesLayoutBy, dataArrayRows, Infinity);
		}
		dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
	} else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
		if (!dimensionsDefine) dimensionsDefine = objectRowsCollectDimensions(data);
	} else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
		if (!dimensionsDefine) {
			dimensionsDefine = [];
			each(data, function(colArr, key$1) {
				dimensionsDefine.push(key$1);
			});
		}
	} else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
		var value0 = getDataItemValue(data[0]);
		dimensionsDetectedCount = isArray(value0) && value0.length || 1;
	} else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) assert(!!dimensionsDefine, "dimensions must be given if data is TypedArray.");
	return {
		startIndex,
		dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
		dimensionsDetectedCount
	};
}
function objectRowsCollectDimensions(data) {
	var firstIndex = 0;
	var obj;
	while (firstIndex < data.length && !(obj = data[firstIndex++]));
	if (obj) return keys(obj);
}
function normalizeDimensionsOption(dimensionsDefine) {
	if (!dimensionsDefine) return;
	var nameMap = createHashMap();
	return map$1(dimensionsDefine, function(rawItem, index) {
		rawItem = isObject$1(rawItem) ? rawItem : { name: rawItem };
		var item = {
			name: rawItem.name,
			displayName: rawItem.displayName,
			type: rawItem.type
		};
		if (item.name == null) return item;
		item.name += "";
		if (item.displayName == null) item.displayName = item.name;
		var exist = nameMap.get(item.name);
		if (!exist) nameMap.set(item.name, { count: 1 });
		else item.name += "-" + exist.count++;
		return item;
	});
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
	if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) for (var i = 0; i < data.length && i < maxLoop; i++) cb(data[i] ? data[i][0] : null, i);
	else {
		var value0 = data[0] || [];
		for (var i = 0; i < value0.length && i < maxLoop; i++) cb(value0[i], i);
	}
}
function shouldRetrieveDataByName(source) {
	var sourceFormat = source.sourceFormat;
	return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}

//#endregion
//#region node_modules/echarts/lib/data/helper/SeriesDataSchema.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var inner$3 = makeInner();
var dimTypeShort = {
	float: "f",
	int: "i",
	ordinal: "o",
	number: "n",
	time: "t"
};
/**
* Represents the dimension requirement of a series.
*
* NOTICE:
* When there are too many dimensions in dataset and many series, only the used dimensions
* (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.
* But users may query data by other unused dimension names.
* In this case, users can only query data if and only if they have defined dimension names
* via ec option, so we provide `getDimensionIndexFromSource`, which only query them from
* `source` dimensions.
*/
var SeriesDataSchema = function() {
	function SeriesDataSchema$1(opt) {
		this.dimensions = opt.dimensions;
		this._dimOmitted = opt.dimensionOmitted;
		this.source = opt.source;
		this._fullDimCount = opt.fullDimensionCount;
		this._updateDimOmitted(opt.dimensionOmitted);
	}
	SeriesDataSchema$1.prototype.isDimensionOmitted = function() {
		return this._dimOmitted;
	};
	SeriesDataSchema$1.prototype._updateDimOmitted = function(dimensionOmitted) {
		this._dimOmitted = dimensionOmitted;
		if (!dimensionOmitted) return;
		if (!this._dimNameMap) this._dimNameMap = ensureSourceDimNameMap(this.source);
	};
	/**
	* @caution Can only be used when `dimensionOmitted: true`.
	*
	* Get index by user defined dimension name (i.e., not internal generate name).
	* That is, get index from `dimensionsDefine`.
	* If no `dimensionsDefine`, or no name get, return -1.
	*/
	SeriesDataSchema$1.prototype.getSourceDimensionIndex = function(dimName) {
		return retrieve2(this._dimNameMap.get(dimName), -1);
	};
	/**
	* @caution Can only be used when `dimensionOmitted: true`.
	*
	* Notice: may return `null`/`undefined` if user not specify dimension names.
	*/
	SeriesDataSchema$1.prototype.getSourceDimension = function(dimIndex) {
		var dimensionsDefine = this.source.dimensionsDefine;
		if (dimensionsDefine) return dimensionsDefine[dimIndex];
	};
	SeriesDataSchema$1.prototype.makeStoreSchema = function() {
		var dimCount = this._fullDimCount;
		var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
		var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
		var dimHash = "";
		var dims = [];
		for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
			var property = void 0;
			var type = void 0;
			var ordinalMeta = void 0;
			var seriesDimDef = this.dimensions[seriesDimIdx];
			if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
				property = willRetrieveDataByName ? seriesDimDef.name : null;
				type = seriesDimDef.type;
				ordinalMeta = seriesDimDef.ordinalMeta;
				seriesDimIdx++;
			} else {
				var sourceDimDef = this.getSourceDimension(fullDimIdx);
				if (sourceDimDef) {
					property = willRetrieveDataByName ? sourceDimDef.name : null;
					type = sourceDimDef.type;
				}
			}
			dims.push({
				property,
				type,
				ordinalMeta
			});
			if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
			dimHash += "$";
			dimHash += dimTypeShort[type] || "f";
			if (ordinalMeta) dimHash += ordinalMeta.uid;
			dimHash += "$";
		}
		var source = this.source;
		return {
			dimensions: dims,
			hash: [
				source.seriesLayoutBy,
				source.startIndex,
				dimHash
			].join("$$")
		};
	};
	SeriesDataSchema$1.prototype.makeOutputDimensionNames = function() {
		var result = [];
		for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
			var name_1 = void 0;
			var seriesDimDef = this.dimensions[seriesDimIdx];
			if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
				if (!seriesDimDef.isCalculationCoord) name_1 = seriesDimDef.name;
				seriesDimIdx++;
			} else {
				var sourceDimDef = this.getSourceDimension(fullDimIdx);
				if (sourceDimDef) name_1 = sourceDimDef.name;
			}
			result.push(name_1);
		}
		return result;
	};
	SeriesDataSchema$1.prototype.appendCalculationDimension = function(dimDef) {
		this.dimensions.push(dimDef);
		dimDef.isCalculationCoord = true;
		this._fullDimCount++;
		this._updateDimOmitted(true);
	};
	return SeriesDataSchema$1;
}();
function isSeriesDataSchema(schema) {
	return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
	var dataDimNameMap = createHashMap();
	for (var i = 0; i < (dimsDef || []).length; i++) {
		var dimDefItemRaw = dimsDef[i];
		var userDimName = isObject$1(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
		if (userDimName != null && dataDimNameMap.get(userDimName) == null) dataDimNameMap.set(userDimName, i);
	}
	return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
	var innerSource = inner$3(source);
	return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
	return dimCount > 30;
}

//#endregion
//#region node_modules/echarts/lib/data/helper/dataStackHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Note that it is too complicated to support 3d stack by value
* (have to create two-dimension inverted index), so in 3d case
* we just support that stacked by index.
*
* @param seriesModel
* @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.
*        The input will be modified.
* @param opt
* @param opt.stackedCoordDimension Specify a coord dimension if needed.
* @param opt.byIndex=false
* @return calculationInfo
* {
*     stackedDimension: string
*     stackedByDimension: string
*     isStackedByIndex: boolean
*     stackedOverDimension: string
*     stackResultDimension: string
* }
*/
function enableDataStack(seriesModel, dimensionsInput, opt) {
	opt = opt || {};
	var byIndex = opt.byIndex;
	var stackedCoordDimension = opt.stackedCoordDimension;
	var dimensionDefineList;
	var schema;
	var store;
	if (isLegacyDimensionsInput(dimensionsInput)) dimensionDefineList = dimensionsInput;
	else {
		schema = dimensionsInput.schema;
		dimensionDefineList = schema.dimensions;
		store = dimensionsInput.store;
	}
	var mayStack = !!(seriesModel && seriesModel.get("stack"));
	var stackedByDimInfo;
	var stackedDimInfo;
	var stackResultDimension;
	var stackedOverDimension;
	each(dimensionDefineList, function(dimensionInfo, index) {
		if (isString(dimensionInfo)) dimensionDefineList[index] = dimensionInfo = { name: dimensionInfo };
		if (mayStack && !dimensionInfo.isExtraCoord) {
			if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) stackedByDimInfo = dimensionInfo;
			if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) stackedDimInfo = dimensionInfo;
		}
	});
	if (stackedDimInfo && !byIndex && !stackedByDimInfo) byIndex = true;
	if (stackedDimInfo) {
		stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
		stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
		if (stackedByDimInfo) stackedByDimInfo.createInvertedIndices = true;
		var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
		var stackedDimType = stackedDimInfo.type;
		var stackedDimCoordIndex_1 = 0;
		each(dimensionDefineList, function(dimensionInfo) {
			if (dimensionInfo.coordDim === stackedDimCoordDim_1) stackedDimCoordIndex_1++;
		});
		var stackedOverDimensionDefine = {
			name: stackResultDimension,
			coordDim: stackedDimCoordDim_1,
			coordDimIndex: stackedDimCoordIndex_1,
			type: stackedDimType,
			isExtraCoord: true,
			isCalculationCoord: true,
			storeDimIndex: dimensionDefineList.length
		};
		var stackResultDimensionDefine = {
			name: stackedOverDimension,
			coordDim: stackedOverDimension,
			coordDimIndex: stackedDimCoordIndex_1 + 1,
			type: stackedDimType,
			isExtraCoord: true,
			isCalculationCoord: true,
			storeDimIndex: dimensionDefineList.length + 1
		};
		if (schema) {
			if (store) {
				stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
				stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
			}
			schema.appendCalculationDimension(stackedOverDimensionDefine);
			schema.appendCalculationDimension(stackResultDimensionDefine);
		} else {
			dimensionDefineList.push(stackedOverDimensionDefine);
			dimensionDefineList.push(stackResultDimensionDefine);
		}
	}
	return {
		stackedDimension: stackedDimInfo && stackedDimInfo.name,
		stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
		isStackedByIndex: byIndex,
		stackedOverDimension,
		stackResultDimension
	};
}
function isLegacyDimensionsInput(dimensionsInput) {
	return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked(data, stackedDim) {
	return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data, targetDim) {
	return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
}

//#endregion
//#region node_modules/echarts/lib/chart/helper/createRenderPlanner.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* @return {string} If large mode changed, return string 'reset';
*/
function createRenderPlanner() {
	var inner$5 = makeInner();
	return function(seriesModel) {
		var fields = inner$5(seriesModel);
		var pipelineContext = seriesModel.pipelineContext;
		var originalLarge = !!fields.large;
		var originalProgressive = !!fields.progressiveRender;
		var large = fields.large = !!(pipelineContext && pipelineContext.large);
		var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
		return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
	};
}

//#endregion
//#region node_modules/echarts/lib/util/vendor.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
	if (isArray(arg)) return supportFloat32Array ? new Float32Array(arg) : arg;
	return new Float32ArrayCtor(arg);
}

//#endregion
//#region node_modules/echarts/lib/layout/barGrid.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId(seriesModel) {
	return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey(axis) {
	return axis.dim + axis.index;
}
/**
* @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
*/
function getLayoutOnAxis(opt) {
	var params = [];
	var baseAxis = opt.axis;
	var axisKey = "axis0";
	if (baseAxis.type !== "category") return;
	var bandWidth = baseAxis.getBandWidth();
	for (var i = 0; i < opt.count || 0; i++) params.push(defaults({
		bandWidth,
		axisKey,
		stackId: STACK_PREFIX + i
	}, opt));
	var widthAndOffsets = doCalBarWidthAndOffset(params);
	var result = [];
	for (var i = 0; i < opt.count; i++) {
		var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
		item.offsetCenter = item.offset + item.width / 2;
		result.push(item);
	}
	return result;
}
function prepareLayoutBarSeries(seriesType$1, ecModel) {
	var seriesModels = [];
	ecModel.eachSeriesByType(seriesType$1, function(seriesModel) {
		if (isOnCartesian(seriesModel)) seriesModels.push(seriesModel);
	});
	return seriesModels;
}
/**
* Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent
* values.
* This works for time axes, value axes, and log axes.
* For a single time axis, return value is in the form like
* {'x_0': [1000000]}.
* The value of 1000000 is in milliseconds.
*/
function getValueAxesMinGaps(barSeries) {
	/**
	* Map from axis.index to values.
	* For a single time axis, axisValues is in the form like
	* {'x_0': [1495555200000, 1495641600000, 1495728000000]}.
	* Items in axisValues[x], e.g. 1495555200000, are time values of all
	* series.
	*/
	var axisValues = {};
	each(barSeries, function(seriesModel) {
		var baseAxis = seriesModel.coordinateSystem.getBaseAxis();
		if (baseAxis.type !== "time" && baseAxis.type !== "value") return;
		var data = seriesModel.getData();
		var key$2 = baseAxis.dim + "_" + baseAxis.index;
		var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
		var store = data.getStore();
		for (var i = 0, cnt = store.count(); i < cnt; ++i) {
			var value = store.get(dimIdx, i);
			if (!axisValues[key$2]) axisValues[key$2] = [value];
			else axisValues[key$2].push(value);
		}
	});
	var axisMinGaps = {};
	for (var key$1 in axisValues) if (axisValues.hasOwnProperty(key$1)) {
		var valuesInAxis = axisValues[key$1];
		if (valuesInAxis) {
			valuesInAxis.sort(function(a, b) {
				return a - b;
			});
			var min$1 = null;
			for (var j = 1; j < valuesInAxis.length; ++j) {
				var delta = valuesInAxis[j] - valuesInAxis[j - 1];
				if (delta > 0) min$1 = min$1 === null ? delta : Math.min(min$1, delta);
			}
			axisMinGaps[key$1] = min$1;
		}
	}
	return axisMinGaps;
}
function makeColumnLayout(barSeries) {
	var axisMinGaps = getValueAxesMinGaps(barSeries);
	var seriesInfoList = [];
	each(barSeries, function(seriesModel) {
		var baseAxis = seriesModel.coordinateSystem.getBaseAxis();
		var axisExtent = baseAxis.getExtent();
		var bandWidth;
		if (baseAxis.type === "category") bandWidth = baseAxis.getBandWidth();
		else if (baseAxis.type === "value" || baseAxis.type === "time") {
			var minGap = axisMinGaps[baseAxis.dim + "_" + baseAxis.index];
			var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
			var scale$2 = baseAxis.scale.getExtent();
			var scaleSpan = Math.abs(scale$2[1] - scale$2[0]);
			bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
		} else {
			var data = seriesModel.getData();
			bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
		}
		var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
		var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
		var barMinWidth = parsePercent(seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? .5 : 1), bandWidth);
		var barGap = seriesModel.get("barGap");
		var barCategoryGap = seriesModel.get("barCategoryGap");
		var defaultBarGap = seriesModel.get("defaultBarGap");
		seriesInfoList.push({
			bandWidth,
			barWidth,
			barMaxWidth,
			barMinWidth,
			barGap,
			barCategoryGap,
			defaultBarGap,
			axisKey: getAxisKey(baseAxis),
			stackId: getSeriesStackId(seriesModel)
		});
	});
	return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
	var columnsMap = {};
	each(seriesInfoList, function(seriesInfo, idx) {
		var axisKey = seriesInfo.axisKey;
		var bandWidth = seriesInfo.bandWidth;
		var columnsOnAxis = columnsMap[axisKey] || {
			bandWidth,
			remainedWidth: bandWidth,
			autoWidthCount: 0,
			categoryGap: null,
			gap: seriesInfo.defaultBarGap || 0,
			stacks: {}
		};
		var stacks = columnsOnAxis.stacks;
		columnsMap[axisKey] = columnsOnAxis;
		var stackId = seriesInfo.stackId;
		if (!stacks[stackId]) columnsOnAxis.autoWidthCount++;
		stacks[stackId] = stacks[stackId] || {
			width: 0,
			maxWidth: 0
		};
		var barWidth = seriesInfo.barWidth;
		if (barWidth && !stacks[stackId].width) {
			stacks[stackId].width = barWidth;
			barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
			columnsOnAxis.remainedWidth -= barWidth;
		}
		var barMaxWidth = seriesInfo.barMaxWidth;
		barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
		var barMinWidth = seriesInfo.barMinWidth;
		barMinWidth && (stacks[stackId].minWidth = barMinWidth);
		var barGap = seriesInfo.barGap;
		barGap != null && (columnsOnAxis.gap = barGap);
		var barCategoryGap = seriesInfo.barCategoryGap;
		barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
	});
	var result = {};
	each(columnsMap, function(columnsOnAxis, coordSysName) {
		result[coordSysName] = {};
		var stacks = columnsOnAxis.stacks;
		var bandWidth = columnsOnAxis.bandWidth;
		var categoryGapPercent = columnsOnAxis.categoryGap;
		if (categoryGapPercent == null) {
			var columnCount = keys(stacks).length;
			categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
		}
		var categoryGap = parsePercent(categoryGapPercent, bandWidth);
		var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
		var remainedWidth = columnsOnAxis.remainedWidth;
		var autoWidthCount = columnsOnAxis.autoWidthCount;
		var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
		autoWidth = Math.max(autoWidth, 0);
		each(stacks, function(column) {
			var maxWidth = column.maxWidth;
			var minWidth = column.minWidth;
			if (!column.width) {
				var finalWidth = autoWidth;
				if (maxWidth && maxWidth < finalWidth) finalWidth = Math.min(maxWidth, remainedWidth);
				if (minWidth && minWidth > finalWidth) finalWidth = minWidth;
				if (finalWidth !== autoWidth) {
					column.width = finalWidth;
					remainedWidth -= finalWidth + barGapPercent * finalWidth;
					autoWidthCount--;
				}
			} else {
				var finalWidth = column.width;
				if (maxWidth) finalWidth = Math.min(finalWidth, maxWidth);
				if (minWidth) finalWidth = Math.max(finalWidth, minWidth);
				column.width = finalWidth;
				remainedWidth -= finalWidth + barGapPercent * finalWidth;
				autoWidthCount--;
			}
		});
		autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
		autoWidth = Math.max(autoWidth, 0);
		var widthSum = 0;
		var lastColumn;
		each(stacks, function(column, idx) {
			if (!column.width) column.width = autoWidth;
			lastColumn = column;
			widthSum += column.width * (1 + barGapPercent);
		});
		if (lastColumn) widthSum -= lastColumn.width * barGapPercent;
		var offset = -widthSum / 2;
		each(stacks, function(column, stackId) {
			result[coordSysName][stackId] = result[coordSysName][stackId] || {
				bandWidth,
				offset,
				width: column.width
			};
			offset += column.width * (1 + barGapPercent);
		});
	});
	return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
	if (barWidthAndOffset && axis) {
		var result = barWidthAndOffset[getAxisKey(axis)];
		if (result != null && seriesModel != null) return result[getSeriesStackId(seriesModel)];
		return result;
	}
}
function layout(seriesType$1, ecModel) {
	var seriesModels = prepareLayoutBarSeries(seriesType$1, ecModel);
	var barWidthAndOffset = makeColumnLayout(seriesModels);
	each(seriesModels, function(seriesModel) {
		var data = seriesModel.getData();
		var baseAxis = seriesModel.coordinateSystem.getBaseAxis();
		var stackId = getSeriesStackId(seriesModel);
		var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
		var columnOffset = columnLayoutInfo.offset;
		var columnWidth = columnLayoutInfo.width;
		data.setLayout({
			bandWidth: columnLayoutInfo.bandWidth,
			offset: columnOffset,
			size: columnWidth
		});
	});
}
function createProgressiveLayout(seriesType$1) {
	return {
		seriesType: seriesType$1,
		plan: createRenderPlanner(),
		reset: function(seriesModel) {
			if (!isOnCartesian(seriesModel)) return;
			var data = seriesModel.getData();
			var cartesian = seriesModel.coordinateSystem;
			var baseAxis = cartesian.getBaseAxis();
			var valueAxis = cartesian.getOtherAxis(baseAxis);
			var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis.dim));
			var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
			var drawBackground = seriesModel.get("showBackground", true);
			var valueDim = data.mapDimension(valueAxis.dim);
			var stackResultDim = data.getCalculationInfo("stackResultDimension");
			var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
			var isValueAxisH = valueAxis.isHorizontal();
			var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);
			var isLarge = isInLargeMode(seriesModel);
			var barMinHeight = seriesModel.get("barMinHeight") || 0;
			var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
			var columnWidth = data.getLayout("size");
			var columnOffset = data.getLayout("offset");
			return { progress: function(params, data$1) {
				var count = params.count;
				var largePoints = isLarge && createFloat32Array(count * 3);
				var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3);
				var largeDataIndices = isLarge && createFloat32Array(count);
				var coordLayout = cartesian.master.getRect();
				var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
				var dataIndex;
				var store = data$1.getStore();
				var idxOffset = 0;
				while ((dataIndex = params.next()) != null) {
					var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
					var baseValue = store.get(baseDimIdx, dataIndex);
					var baseCoord = valueAxisStart;
					var stackStartValue = void 0;
					if (stacked) stackStartValue = +value - store.get(valueDimIdx, dataIndex);
					var x = void 0;
					var y = void 0;
					var width = void 0;
					var height = void 0;
					if (isValueAxisH) {
						var coord = cartesian.dataToPoint([value, baseValue]);
						if (stacked) {
							var startCoord = cartesian.dataToPoint([stackStartValue, baseValue]);
							baseCoord = startCoord[0];
						}
						x = baseCoord;
						y = coord[1] + columnOffset;
						width = coord[0] - baseCoord;
						height = columnWidth;
						if (Math.abs(width) < barMinHeight) width = (width < 0 ? -1 : 1) * barMinHeight;
					} else {
						var coord = cartesian.dataToPoint([baseValue, value]);
						if (stacked) {
							var startCoord = cartesian.dataToPoint([baseValue, stackStartValue]);
							baseCoord = startCoord[1];
						}
						x = coord[0] + columnOffset;
						y = baseCoord;
						width = columnWidth;
						height = coord[1] - baseCoord;
						if (Math.abs(height) < barMinHeight) height = (height <= 0 ? -1 : 1) * barMinHeight;
					}
					if (!isLarge) data$1.setItemLayout(dataIndex, {
						x,
						y,
						width,
						height
					});
					else {
						largePoints[idxOffset] = x;
						largePoints[idxOffset + 1] = y;
						largePoints[idxOffset + 2] = isValueAxisH ? width : height;
						if (largeBackgroundPoints) {
							largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;
							largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;
							largeBackgroundPoints[idxOffset + 2] = bgSize;
						}
						largeDataIndices[dataIndex] = dataIndex;
					}
					idxOffset += 3;
				}
				if (isLarge) data$1.setLayout({
					largePoints,
					largeDataIndices,
					largeBackgroundPoints,
					valueAxisHorizontal: isValueAxisH
				});
			} };
		}
	};
}
function isOnCartesian(seriesModel) {
	return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
	return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis) {
	var startValue = valueAxis.model.get("startValue");
	if (!startValue) startValue = 0;
	return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === "log" ? startValue > 0 ? startValue : 1 : startValue));
}

//#endregion
//#region node_modules/echarts/lib/scale/Time.js
init_tslib_es6();
var bisect = function(a, x, lo, hi) {
	while (lo < hi) {
		var mid = lo + hi >>> 1;
		if (a[mid][1] < x) lo = mid + 1;
		else hi = mid;
	}
	return lo;
};
var TimeScale = function(_super) {
	__extends(TimeScale$1, _super);
	function TimeScale$1(settings) {
		var _this = _super.call(this, settings) || this;
		_this.type = "time";
		return _this;
	}
	/**
	* Get label is mainly for other components like dataZoom, tooltip.
	*/
	TimeScale$1.prototype.getLabel = function(tick) {
		var useUTC = this.getSetting("useUTC");
		return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
	};
	TimeScale$1.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
		var isUTC = this.getSetting("useUTC");
		return leveledFormat(tick, idx, labelFormatter, this.getSetting("locale"), isUTC);
	};
	/**
	* @override
	*/
	TimeScale$1.prototype.getTicks = function(opt) {
		opt = opt || {};
		var interval = this._interval;
		var extent = this._extent;
		var scaleBreakHelper = getScaleBreakHelper();
		var ticks = [];
		if (!interval) return ticks;
		var useUTC = this.getSetting("useUTC");
		if (scaleBreakHelper && opt.breakTicks === "only_break") {
			getScaleBreakHelper().addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
			return ticks;
		}
		var extent0Unit = getUnitFromValue(extent[1], useUTC);
		ticks.push({
			value: extent[0],
			time: {
				level: 0,
				upperTimeUnit: extent0Unit,
				lowerTimeUnit: extent0Unit
			}
		});
		var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent, this._getExtentSpanWithBreaks(), this._brkCtx);
		ticks = ticks.concat(innerTicks);
		var extent1Unit = getUnitFromValue(extent[1], useUTC);
		ticks.push({
			value: extent[1],
			time: {
				level: 0,
				upperTimeUnit: extent1Unit,
				lowerTimeUnit: extent1Unit
			}
		});
		var isUTC = this.getSetting("useUTC");
		var upperUnitIndex = primaryTimeUnits.length - 1;
		var maxLevel = 0;
		each(ticks, function(tick) {
			upperUnitIndex = Math.min(upperUnitIndex, indexOf(primaryTimeUnits, tick.time.upperTimeUnit));
			maxLevel = Math.max(maxLevel, tick.time.level);
		});
		if (scaleBreakHelper) getScaleBreakHelper().pruneTicksByBreak(opt.pruneByBreak, ticks, this._brkCtx.breaks, function(item) {
			return item.value;
		}, this._approxInterval, this._extent);
		if (scaleBreakHelper && opt.breakTicks !== "none") getScaleBreakHelper().addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent, function(trimmedBrk) {
			var lowerBrkUnitIndex = Math.max(indexOf(primaryTimeUnits, getUnitFromValue(trimmedBrk.vmin, isUTC)), indexOf(primaryTimeUnits, getUnitFromValue(trimmedBrk.vmax, isUTC)));
			var upperBrkUnitIndex = 0;
			for (var unitIdx = 0; unitIdx < primaryTimeUnits.length; unitIdx++) if (!isPrimaryUnitValueAndGreaterSame(primaryTimeUnits[unitIdx], trimmedBrk.vmin, trimmedBrk.vmax, isUTC)) {
				upperBrkUnitIndex = unitIdx;
				break;
			}
			var upperIdx = Math.min(upperBrkUnitIndex, upperUnitIndex);
			return {
				level: maxLevel,
				lowerTimeUnit: primaryTimeUnits[Math.max(upperIdx, lowerBrkUnitIndex)],
				upperTimeUnit: primaryTimeUnits[upperIdx]
			};
		});
		return ticks;
	};
	TimeScale$1.prototype.calcNiceExtent = function(opt) {
		var extent = this.getExtent();
		if (extent[0] === extent[1]) {
			extent[0] -= ONE_DAY;
			extent[1] += ONE_DAY;
		}
		if (extent[1] === -Infinity && extent[0] === Infinity) {
			var d = /* @__PURE__ */ new Date();
			extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
			extent[0] = extent[1] - ONE_DAY;
		}
		this._innerSetExtent(extent[0], extent[1]);
		this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
	};
	TimeScale$1.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
		approxTickNum = approxTickNum || 10;
		this._approxInterval = this._getExtentSpanWithBreaks() / approxTickNum;
		if (minInterval != null && this._approxInterval < minInterval) this._approxInterval = minInterval;
		if (maxInterval != null && this._approxInterval > maxInterval) this._approxInterval = maxInterval;
		var scaleIntervalsLen = scaleIntervals.length;
		var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
		this._interval = scaleIntervals[idx][1];
		this._intervalPrecision = getIntervalPrecision(this._interval);
		this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
	};
	TimeScale$1.prototype.parse = function(val) {
		return isNumber(val) ? val : +parseDate(val);
	};
	TimeScale$1.prototype.contain = function(val) {
		return contain$1(val, this._extent);
	};
	TimeScale$1.prototype.normalize = function(val) {
		return this._calculator.normalize(val, this._extent);
	};
	TimeScale$1.prototype.scale = function(val) {
		return this._calculator.scale(val, this._extent);
	};
	TimeScale$1.type = "time";
	return TimeScale$1;
}(Interval_default);
/**
* This implementation was originally copied from "d3.js"
* <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>
* with some modifications made for this program.
* See the license statement at the head of this file.
*/
var scaleIntervals = [
	["second", ONE_SECOND],
	["minute", ONE_MINUTE],
	["hour", ONE_HOUR],
	["quarter-day", ONE_HOUR * 6],
	["half-day", ONE_HOUR * 12],
	["day", ONE_DAY * 1.2],
	["half-week", ONE_DAY * 3.5],
	["week", ONE_DAY * 7],
	["month", ONE_DAY * 31],
	["quarter", ONE_DAY * 95],
	["half-year", ONE_YEAR / 2],
	["year", ONE_YEAR]
];
function isPrimaryUnitValueAndGreaterSame(unit, valueA, valueB, isUTC) {
	return roundTime(new Date(valueA), unit, isUTC).getTime() === roundTime(new Date(valueB), unit, isUTC).getTime();
}
function getDateInterval(approxInterval, daysInMonth) {
	approxInterval /= ONE_DAY;
	return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
	var APPROX_ONE_MONTH = 30 * ONE_DAY;
	approxInterval /= APPROX_ONE_MONTH;
	return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
	approxInterval /= ONE_HOUR;
	return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
	approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
	return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
	return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(timestamp, unitName, isUTC) {
	var upperUnitIdx = Math.max(0, indexOf(primaryTimeUnits, unitName) - 1);
	return roundTime(new Date(timestamp), primaryTimeUnits[upperUnitIdx], isUTC).getTime();
}
function createEstimateNiceMultiple(setMethodName, dateMethodInterval) {
	var tmpDate = /* @__PURE__ */ new Date(0);
	tmpDate[setMethodName](1);
	var tmpTime = tmpDate.getTime();
	tmpDate[setMethodName](1 + dateMethodInterval);
	var approxTimeInterval = tmpDate.getTime() - tmpTime;
	return function(tickVal, targetValue) {
		return Math.max(0, Math.round((targetValue - tickVal) / approxTimeInterval));
	};
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent, extentSpanWithBreaks, brkCtx) {
	var safeLimit = 1e4;
	var unitNames = timeUnits;
	var iter = 0;
	function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out$1) {
		var estimateNiceMultiple = createEstimateNiceMultiple(setMethodName, interval);
		var dateTime = minTimestamp;
		var date = new Date(dateTime);
		while (dateTime < maxTimestamp && dateTime <= extent[1]) {
			out$1.push({ value: dateTime });
			if (iter++ > safeLimit) {
				warn("Exceed safe limit in time scale.");
				break;
			}
			date[setMethodName](date[getMethodName]() + interval);
			dateTime = date.getTime();
			if (brkCtx) {
				var moreMultiple = brkCtx.calcNiceTickMultiple(dateTime, estimateNiceMultiple);
				if (moreMultiple > 0) {
					date[setMethodName](date[getMethodName]() + moreMultiple * interval);
					dateTime = date.getTime();
				}
			}
		}
		out$1.push({
			value: dateTime,
			notAdd: true
		});
	}
	function addLevelTicks(unitName, lastLevelTicks, levelTicks$1) {
		var newAddedTicks = [];
		var isFirstLevel = !lastLevelTicks.length;
		if (isPrimaryUnitValueAndGreaterSame(getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) return;
		if (isFirstLevel) lastLevelTicks = [{ value: getFirstTimestampOfUnit(extent[0], unitName, isUTC) }, { value: extent[1] }];
		for (var i$1 = 0; i$1 < lastLevelTicks.length - 1; i$1++) {
			var startTick = lastLevelTicks[i$1].value;
			var endTick = lastLevelTicks[i$1 + 1].value;
			if (startTick === endTick) continue;
			var interval = void 0;
			var getterName = void 0;
			var setterName = void 0;
			var isDate = false;
			switch (unitName) {
				case "year":
					interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
					getterName = fullYearGetterName(isUTC);
					setterName = fullYearSetterName(isUTC);
					break;
				case "half-year":
				case "quarter":
				case "month":
					interval = getMonthInterval(approxInterval);
					getterName = monthGetterName(isUTC);
					setterName = monthSetterName(isUTC);
					break;
				case "week":
				case "half-week":
				case "day":
					interval = getDateInterval(approxInterval, 31);
					getterName = dateGetterName(isUTC);
					setterName = dateSetterName(isUTC);
					isDate = true;
					break;
				case "half-day":
				case "quarter-day":
				case "hour":
					interval = getHourInterval(approxInterval);
					getterName = hoursGetterName(isUTC);
					setterName = hoursSetterName(isUTC);
					break;
				case "minute":
					interval = getMinutesAndSecondsInterval(approxInterval, true);
					getterName = minutesGetterName(isUTC);
					setterName = minutesSetterName(isUTC);
					break;
				case "second":
					interval = getMinutesAndSecondsInterval(approxInterval, false);
					getterName = secondsGetterName(isUTC);
					setterName = secondsSetterName(isUTC);
					break;
				case "millisecond":
					interval = getMillisecondsInterval(approxInterval);
					getterName = millisecondsGetterName(isUTC);
					setterName = millisecondsSetterName(isUTC);
					break;
			}
			if (endTick >= extent[0] && startTick <= extent[1]) addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
			if (unitName === "year" && levelTicks$1.length > 1 && i$1 === 0) levelTicks$1.unshift({ value: levelTicks$1[0].value - interval });
		}
		for (var i$1 = 0; i$1 < newAddedTicks.length; i$1++) levelTicks$1.push(newAddedTicks[i$1]);
	}
	var levelsTicks = [];
	var currentLevelTicks = [];
	var tickCount = 0;
	var lastLevelTickCount = 0;
	for (var i = 0; i < unitNames.length; ++i) {
		var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);
		if (!isPrimaryTimeUnit(unitNames[i])) continue;
		addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
		if (primaryTimeUnit !== (unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null)) {
			if (currentLevelTicks.length) {
				lastLevelTickCount = tickCount;
				currentLevelTicks.sort(function(a, b) {
					return a.value - b.value;
				});
				var levelTicksRemoveDuplicated = [];
				for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
					var tickValue = currentLevelTicks[i_1].value;
					if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
						levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
						if (tickValue >= extent[0] && tickValue <= extent[1]) tickCount++;
					}
				}
				var targetTickNum = extentSpanWithBreaks / approxInterval;
				if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) break;
				levelsTicks.push(levelTicksRemoveDuplicated);
				if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) break;
			}
			currentLevelTicks = [];
		}
	}
	var levelsTicksInExtent = filter(map$1(levelsTicks, function(levelTicks$1) {
		return filter(levelTicks$1, function(tick) {
			return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd;
		});
	}), function(levelTicks$1) {
		return levelTicks$1.length > 0;
	});
	var ticks = [];
	var maxLevel = levelsTicksInExtent.length - 1;
	for (var i = 0; i < levelsTicksInExtent.length; ++i) {
		var levelTicks = levelsTicksInExtent[i];
		for (var k = 0; k < levelTicks.length; ++k) {
			var unit = getUnitFromValue(levelTicks[k].value, isUTC);
			ticks.push({
				value: levelTicks[k].value,
				time: {
					level: maxLevel - i,
					upperTimeUnit: unit,
					lowerTimeUnit: unit
				}
			});
		}
	}
	ticks.sort(function(a, b) {
		return a.value - b.value;
	});
	var result = [];
	for (var i = 0; i < ticks.length; ++i) if (i === 0 || ticks[i].value !== ticks[i - 1].value) result.push(ticks[i]);
	return result;
}
Scale_default.registerClass(TimeScale);
var Time_default = TimeScale;

//#endregion
//#region node_modules/echarts/lib/scale/Log.js
init_tslib_es6();
var fixRound = round;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow = Math.pow;
var mathLog = Math.log;
var LogScale = function(_super) {
	__extends(LogScale$1, _super);
	function LogScale$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this.type = "log";
		_this.base = 10;
		_this._originalScale = new Interval_default();
		return _this;
	}
	/**
	* @param Whether expand the ticks to niced extent.
	*/
	LogScale$1.prototype.getTicks = function(opt) {
		opt = opt || {};
		var extent = this._extent.slice();
		var originalExtent = this._originalScale.getExtent();
		var ticks = _super.prototype.getTicks.call(this, opt);
		var base$1 = this.base;
		var originalBreaks = this._originalScale._innerGetBreaks();
		var scaleBreakHelper = getScaleBreakHelper();
		return map$1(ticks, function(tick) {
			var val = tick.value;
			var roundingCriterion = null;
			var powVal = mathPow(base$1, val);
			if (val === extent[0] && this._fixMin) roundingCriterion = originalExtent[0];
			else if (val === extent[1] && this._fixMax) roundingCriterion = originalExtent[1];
			var vBreak;
			if (scaleBreakHelper) {
				var transformed = scaleBreakHelper.getTicksLogTransformBreak(tick, base$1, originalBreaks, fixRoundingError);
				vBreak = transformed.vBreak;
				if (roundingCriterion == null) roundingCriterion = transformed.brkRoundingCriterion;
			}
			if (roundingCriterion != null) powVal = fixRoundingError(powVal, roundingCriterion);
			return {
				value: powVal,
				"break": vBreak
			};
		}, this);
	};
	LogScale$1.prototype._getNonTransBreaks = function() {
		return this._originalScale._innerGetBreaks();
	};
	LogScale$1.prototype.setExtent = function(start, end) {
		this._originalScale.setExtent(start, end);
		var loggedExtent = logTransform(this.base, [start, end]);
		_super.prototype.setExtent.call(this, loggedExtent[0], loggedExtent[1]);
	};
	/**
	* @return {number} end
	*/
	LogScale$1.prototype.getExtent = function() {
		var base$1 = this.base;
		var extent = _super.prototype.getExtent.call(this);
		extent[0] = mathPow(base$1, extent[0]);
		extent[1] = mathPow(base$1, extent[1]);
		var originalExtent = this._originalScale.getExtent();
		this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
		this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
		return extent;
	};
	LogScale$1.prototype.unionExtentFromData = function(data, dim) {
		this._originalScale.unionExtentFromData(data, dim);
		var loggedOther = logTransform(this.base, data.getApproximateExtent(dim), true);
		this._innerUnionExtent(loggedOther);
	};
	/**
	* Update interval and extent of intervals for nice ticks
	* @param approxTickNum default 10 Given approx tick number
	*/
	LogScale$1.prototype.calcNiceTicks = function(approxTickNum) {
		approxTickNum = approxTickNum || 10;
		var extent = this._extent.slice();
		var span = this._getExtentSpanWithBreaks();
		if (!isFinite(span) || span <= 0) return;
		var interval = quantity(span);
		if (approxTickNum / span * interval <= .5) interval *= 10;
		while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) interval *= 10;
		var niceExtent = [fixRound(mathCeil(extent[0] / interval) * interval), fixRound(mathFloor(extent[1] / interval) * interval)];
		this._interval = interval;
		this._intervalPrecision = getIntervalPrecision(interval);
		this._niceExtent = niceExtent;
	};
	LogScale$1.prototype.calcNiceExtent = function(opt) {
		_super.prototype.calcNiceExtent.call(this, opt);
		this._fixMin = opt.fixMin;
		this._fixMax = opt.fixMax;
	};
	LogScale$1.prototype.contain = function(val) {
		val = mathLog(val) / mathLog(this.base);
		return _super.prototype.contain.call(this, val);
	};
	LogScale$1.prototype.normalize = function(val) {
		val = mathLog(val) / mathLog(this.base);
		return _super.prototype.normalize.call(this, val);
	};
	LogScale$1.prototype.scale = function(val) {
		val = _super.prototype.scale.call(this, val);
		return mathPow(this.base, val);
	};
	LogScale$1.prototype.setBreaksFromOption = function(breakOptionList) {
		var scaleBreakHelper = getScaleBreakHelper();
		if (!scaleBreakHelper) return;
		var _a$1 = scaleBreakHelper.logarithmicParseBreaksFromOption(breakOptionList, this.base, bind(this.parse, this)), parsedOriginal = _a$1.parsedOriginal, parsedLogged = _a$1.parsedLogged;
		this._originalScale._innerSetBreak(parsedOriginal);
		this._innerSetBreak(parsedLogged);
	};
	LogScale$1.type = "log";
	return LogScale$1;
}(Interval_default);
function fixRoundingError(val, originalVal) {
	return fixRound(val, getPrecision(originalVal));
}
Scale_default.registerClass(LogScale);
var Log_default = LogScale;

//#endregion
//#region node_modules/echarts/lib/coord/scaleRawExtentInfo.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var ScaleRawExtentInfo = function() {
	function ScaleRawExtentInfo$1(scale$2, model, originalExtent) {
		this._prepareParams(scale$2, model, originalExtent);
	}
	/**
	* Parameters depending on outside (like model, user callback)
	* are prepared and fixed here.
	*/
	ScaleRawExtentInfo$1.prototype._prepareParams = function(scale$2, model, dataExtent) {
		if (dataExtent[1] < dataExtent[0]) dataExtent = [NaN, NaN];
		this._dataMin = dataExtent[0];
		this._dataMax = dataExtent[1];
		var isOrdinal = this._isOrdinal = scale$2.type === "ordinal";
		this._needCrossZero = scale$2.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
		var axisMinValue = model.get("min", true);
		if (axisMinValue == null) axisMinValue = model.get("startValue", true);
		var modelMinRaw = this._modelMinRaw = axisMinValue;
		if (isFunction(modelMinRaw)) this._modelMinNum = parseAxisModelMinMax(scale$2, modelMinRaw({
			min: dataExtent[0],
			max: dataExtent[1]
		}));
		else if (modelMinRaw !== "dataMin") this._modelMinNum = parseAxisModelMinMax(scale$2, modelMinRaw);
		var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
		if (isFunction(modelMaxRaw)) this._modelMaxNum = parseAxisModelMinMax(scale$2, modelMaxRaw({
			min: dataExtent[0],
			max: dataExtent[1]
		}));
		else if (modelMaxRaw !== "dataMax") this._modelMaxNum = parseAxisModelMinMax(scale$2, modelMaxRaw);
		if (isOrdinal) this._axisDataLen = model.getCategories().length;
		else {
			var boundaryGap = model.get("boundaryGap");
			var boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
			if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
				console.warn("Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., \"20%\". Currently, boundaryGap is set to be 0.");
				this._boundaryGapInner = [0, 0];
			} else this._boundaryGapInner = [parsePercent$1(boundaryGapArr[0], 1), parsePercent$1(boundaryGapArr[1], 1)];
		}
	};
	/**
	* Calculate extent by prepared parameters.
	* This method has no external dependency and can be called duplicatedly,
	* getting the same result.
	* If parameters changed, should call this method to recalcuate.
	*/
	ScaleRawExtentInfo$1.prototype.calculate = function() {
		var isOrdinal = this._isOrdinal;
		var dataMin = this._dataMin;
		var dataMax = this._dataMax;
		var axisDataLen = this._axisDataLen;
		var boundaryGapInner = this._boundaryGapInner;
		var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
		var min$1 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
		var max$1 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
		var minFixed = min$1 != null;
		var maxFixed = max$1 != null;
		if (min$1 == null) min$1 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
		if (max$1 == null) max$1 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
		(min$1 == null || !isFinite(min$1)) && (min$1 = NaN);
		(max$1 == null || !isFinite(max$1)) && (max$1 = NaN);
		var isBlank = eqNaN(min$1) || eqNaN(max$1) || isOrdinal && !axisDataLen;
		if (this._needCrossZero) {
			if (min$1 > 0 && max$1 > 0 && !minFixed) min$1 = 0;
			if (min$1 < 0 && max$1 < 0 && !maxFixed) max$1 = 0;
		}
		var determinedMin = this._determinedMin;
		var determinedMax = this._determinedMax;
		if (determinedMin != null) {
			min$1 = determinedMin;
			minFixed = true;
		}
		if (determinedMax != null) {
			max$1 = determinedMax;
			maxFixed = true;
		}
		return {
			min: min$1,
			max: max$1,
			minFixed,
			maxFixed,
			isBlank
		};
	};
	ScaleRawExtentInfo$1.prototype.modifyDataMinMax = function(minMaxName, val) {
		assert(!this.frozen);
		this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
	};
	ScaleRawExtentInfo$1.prototype.setDeterminedMinMax = function(minMaxName, val) {
		var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
		assert(!this.frozen && this[attr] == null);
		this[attr] = val;
	};
	ScaleRawExtentInfo$1.prototype.freeze = function() {
		this.frozen = true;
	};
	return ScaleRawExtentInfo$1;
}();
var DETERMINED_MIN_MAX_ATTR = {
	min: "_determinedMin",
	max: "_determinedMax"
};
var DATA_MIN_MAX_ATTR = {
	min: "_dataMin",
	max: "_dataMax"
};
/**
* Get scale min max and related info only depends on model settings.
* This method can be called after coordinate system created.
* For example, in data processing stage.
*
* Scale extent info probably be required multiple times during a workflow.
* For example:
* (1) `dataZoom` depends it to get the axis extent in "100%" state.
* (2) `processor/extentCalculator` depends it to make sure whether axis extent is specified.
* (3) `coordSys.update` use it to finally decide the scale extent.
* But the callback of `min`/`max` should not be called multiple times.
* The code below should not be implemented repeatedly either.
* So we cache the result in the scale instance, which will be recreated at the beginning
* of the workflow (because `scale` instance will be recreated each round of the workflow).
*/
function ensureScaleRawExtentInfo(scale$2, model, originalExtent) {
	var rawExtentInfo = scale$2.rawExtentInfo;
	if (rawExtentInfo) return rawExtentInfo;
	rawExtentInfo = new ScaleRawExtentInfo(scale$2, model, originalExtent);
	scale$2.rawExtentInfo = rawExtentInfo;
	return rawExtentInfo;
}
function parseAxisModelMinMax(scale$2, minMax) {
	return minMax == null ? null : eqNaN(minMax) ? NaN : scale$2.parse(minMax);
}

//#endregion
//#region node_modules/echarts/lib/coord/axisHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Get axis scale extent before niced.
* Item of returned array can only be number (including Infinity and NaN).
*
* Caution:
* Precondition of calling this method:
* The scale extent has been initialized using series data extent via
* `scale.setExtent` or `scale.unionExtentFromData`;
*/
function getScaleExtent(scale$2, model) {
	var scaleType = scale$2.type;
	var rawExtentResult = ensureScaleRawExtentInfo(scale$2, model, scale$2.getExtent()).calculate();
	scale$2.setBlank(rawExtentResult.isBlank);
	var min$1 = rawExtentResult.min;
	var max$1 = rawExtentResult.max;
	var ecModel = model.ecModel;
	if (ecModel && scaleType === "time") {
		var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
		var isBaseAxisAndHasBarSeries_1 = false;
		each(barSeriesModels, function(seriesModel) {
			isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
		});
		if (isBaseAxisAndHasBarSeries_1) {
			var barWidthAndOffset = makeColumnLayout(barSeriesModels);
			var adjustedScale = adjustScaleForOverflow(min$1, max$1, model, barWidthAndOffset);
			min$1 = adjustedScale.min;
			max$1 = adjustedScale.max;
		}
	}
	return {
		extent: [min$1, max$1],
		fixMin: rawExtentResult.minFixed,
		fixMax: rawExtentResult.maxFixed
	};
}
function adjustScaleForOverflow(min$1, max$1, model, barWidthAndOffset) {
	var axisExtent = model.axis.getExtent();
	var axisLength = Math.abs(axisExtent[1] - axisExtent[0]);
	var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
	if (barsOnCurrentAxis === void 0) return {
		min: min$1,
		max: max$1
	};
	var minOverflow = Infinity;
	each(barsOnCurrentAxis, function(item) {
		minOverflow = Math.min(item.offset, minOverflow);
	});
	var maxOverflow = -Infinity;
	each(barsOnCurrentAxis, function(item) {
		maxOverflow = Math.max(item.offset + item.width, maxOverflow);
	});
	minOverflow = Math.abs(minOverflow);
	maxOverflow = Math.abs(maxOverflow);
	var totalOverFlow = minOverflow + maxOverflow;
	var oldRange = max$1 - min$1;
	var overflowBuffer = oldRange / (1 - (minOverflow + maxOverflow) / axisLength) - oldRange;
	max$1 += overflowBuffer * (maxOverflow / totalOverFlow);
	min$1 -= overflowBuffer * (minOverflow / totalOverFlow);
	return {
		min: min$1,
		max: max$1
	};
}
function niceScaleExtent(scale$2, inModel) {
	var model = inModel;
	var extentInfo = getScaleExtent(scale$2, model);
	var extent = extentInfo.extent;
	var splitNumber = model.get("splitNumber");
	if (scale$2 instanceof Log_default) scale$2.base = model.get("logBase");
	var scaleType = scale$2.type;
	var interval = model.get("interval");
	var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
	scale$2.setBreaksFromOption(retrieveAxisBreaksOption(model));
	scale$2.setExtent(extent[0], extent[1]);
	scale$2.calcNiceExtent({
		splitNumber,
		fixMin: extentInfo.fixMin,
		fixMax: extentInfo.fixMax,
		minInterval: isIntervalOrTime ? model.get("minInterval") : null,
		maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
	});
	if (interval != null) scale$2.setInterval && scale$2.setInterval(interval);
}
/**
* @param axisType Default retrieve from model.type
*/
function createScaleByModel(model, axisType) {
	axisType = axisType || model.get("type");
	if (axisType) switch (axisType) {
		case "category": return new Ordinal_default({
			ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
			extent: [Infinity, -Infinity]
		});
		case "time": return new Time_default({
			locale: model.ecModel.getLocaleModel(),
			useUTC: model.ecModel.get("useUTC")
		});
		default: return new ((Scale_default.getClass(axisType)) || Interval_default)();
	}
}
/**
* Check if the axis cross 0
*/
function ifAxisCrossZero(axis) {
	var dataExtent = axis.scale.getExtent();
	var min$1 = dataExtent[0];
	var max$1 = dataExtent[1];
	return !(min$1 > 0 && max$1 > 0 || min$1 < 0 && max$1 < 0);
}
/**
* @param axis
* @return Label formatter function.
*         param: {number} tickValue,
*         param: {number} idx, the index in all ticks.
*                         If category axis, this param is not required.
*         return: {string} label string.
*/
function makeLabelFormatter(axis) {
	var labelFormatter = axis.getLabelModel().get("formatter");
	if (axis.type === "time") {
		var parsed_1 = parseTimeAxisLabelFormatter(labelFormatter);
		return function(tick, idx) {
			return axis.scale.getFormattedLabel(tick, idx, parsed_1);
		};
	} else if (isString(labelFormatter)) return function(tick) {
		var label = axis.scale.getLabel(tick);
		return labelFormatter.replace("{value}", label != null ? label : "");
	};
	else if (isFunction(labelFormatter)) {
		if (axis.type === "category") return function(tick, idx) {
			return labelFormatter(getAxisRawValue(axis, tick), tick.value - axis.scale.getExtent()[0], null);
		};
		var scaleBreakHelper_1 = getScaleBreakHelper();
		return function(tick, idx) {
			var extra = null;
			if (scaleBreakHelper_1) extra = scaleBreakHelper_1.makeAxisLabelFormatterParamBreak(extra, tick["break"]);
			return labelFormatter(getAxisRawValue(axis, tick), idx, extra);
		};
	} else return function(tick) {
		return axis.scale.getLabel(tick);
	};
}
function getAxisRawValue(axis, tick) {
	return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
/**
* @param model axisLabelModel or axisTickModel
* @return {number|String} Can be null|'auto'|number|function
*/
function getOptionCategoryInterval(model) {
	var interval = model.get("interval");
	return interval == null ? "auto" : interval;
}
/**
* Set `categoryInterval` as 0 implicitly indicates that
* show all labels regardless of overlap.
* @param {Object} axis axisModel.axis
*/
function shouldShowAllLabels(axis) {
	return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
	var dataDimMap = {};
	each(data.mapDimensionsAll(axisDim), function(dataDim) {
		dataDimMap[getStackedDimension(data, dataDim)] = true;
	});
	return keys(dataDimMap);
}
function unionAxisExtentFromData(dataExtent, data, axisDim) {
	if (data) each(getDataDimensionsOnAxis(data, axisDim), function(dim) {
		var seriesExtent = data.getApproximateExtent(dim);
		seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
		seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
	});
}
function isNameLocationCenter(nameLocation) {
	return nameLocation === "middle" || nameLocation === "center";
}
function shouldAxisShow(axisModel) {
	return axisModel.getShallow("show");
}
function retrieveAxisBreaksOption(model) {
	var option = model.get("breaks", true);
	if (option != null) {
		if (!getScaleBreakHelper()) {
			error("Must `import {AxisBreak} from \"echarts/features.js\"; use(AxisBreak);` first if using breaks option.");
			return;
		}
		if (!isSupportAxisBreak(model.axis)) {
			error("Axis '" + model.axis.dim + "'-'" + model.axis.type + "' does not support break.");
			return;
		}
		return option;
	}
}
function isSupportAxisBreak(axis) {
	return (axis.dim === "x" || axis.dim === "y" || axis.dim === "z" || axis.dim === "single") && axis.type !== "category";
}

//#endregion
//#region node_modules/echarts/lib/coord/axisTickLabelBuilder.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var modelInner = makeInner();
var axisInner = makeInner();
var AxisTickLabelComputingKind = {
	estimate: 1,
	determine: 2
};
function createAxisLabelsComputingContext(kind) {
	return {
		out: { noPxChangeTryDetermine: [] },
		kind
	};
}
function tickValuesToNumbers(axis, values) {
	var nums = map$1(values, function(val) {
		return axis.scale.parse(val);
	});
	if (axis.type === "time" && nums.length > 0) {
		nums.sort();
		nums.unshift(nums[0]);
		nums.push(nums[nums.length - 1]);
	}
	return nums;
}
function createAxisLabels(axis, ctx) {
	var custom = axis.getLabelModel().get("customValues");
	if (custom) {
		var labelFormatter_1 = makeLabelFormatter(axis);
		var extent_1 = axis.scale.getExtent();
		var tickNumbers = tickValuesToNumbers(axis, custom);
		var ticks = filter(tickNumbers, function(val) {
			return val >= extent_1[0] && val <= extent_1[1];
		});
		return { labels: map$1(ticks, function(numval) {
			var tick = { value: numval };
			return {
				formattedLabel: labelFormatter_1(tick),
				rawLabel: axis.scale.getLabel(tick),
				tickValue: numval,
				time: void 0,
				"break": void 0
			};
		}) };
	}
	return axis.type === "category" ? makeCategoryLabels(axis, ctx) : makeRealNumberLabels(axis);
}
/**
* @param tickModel For example, can be axisTick, splitLine, splitArea.
*/
function createAxisTicks(axis, tickModel, opt) {
	var custom = axis.getTickModel().get("customValues");
	if (custom) {
		var extent_2 = axis.scale.getExtent();
		var tickNumbers = tickValuesToNumbers(axis, custom);
		return { ticks: filter(tickNumbers, function(val) {
			return val >= extent_2[0] && val <= extent_2[1];
		}) };
	}
	return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : { ticks: map$1(axis.scale.getTicks(opt), function(tick) {
		return tick.value;
	}) };
}
function makeCategoryLabels(axis, ctx) {
	var labelModel = axis.getLabelModel();
	var result = makeCategoryLabelsActually(axis, labelModel, ctx);
	return !labelModel.get("show") || axis.scale.isBlank() ? { labels: [] } : result;
}
function makeCategoryLabelsActually(axis, labelModel, ctx) {
	var labelsCache = ensureCategoryLabelCache(axis);
	var optionLabelInterval = getOptionCategoryInterval(labelModel);
	var isEstimate = ctx.kind === AxisTickLabelComputingKind.estimate;
	if (!isEstimate) {
		var result_1 = axisCacheGet(labelsCache, optionLabelInterval);
		if (result_1) return result_1;
	}
	var labels;
	var numericLabelInterval;
	if (isFunction(optionLabelInterval)) labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
	else {
		numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis, ctx) : optionLabelInterval;
		labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
	}
	var result = {
		labels,
		labelCategoryInterval: numericLabelInterval
	};
	if (!isEstimate) axisCacheSet(labelsCache, optionLabelInterval, result);
	else ctx.out.noPxChangeTryDetermine.push(function() {
		axisCacheSet(labelsCache, optionLabelInterval, result);
		return true;
	});
	return result;
}
function makeCategoryTicks(axis, tickModel) {
	var ticksCache = ensureCategoryTickCache(axis);
	var optionTickInterval = getOptionCategoryInterval(tickModel);
	var result = axisCacheGet(ticksCache, optionTickInterval);
	if (result) return result;
	var ticks;
	var tickCategoryInterval;
	if (!tickModel.get("show") || axis.scale.isBlank()) ticks = [];
	if (isFunction(optionTickInterval)) ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
	else if (optionTickInterval === "auto") {
		var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel(), createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine));
		tickCategoryInterval = labelsResult.labelCategoryInterval;
		ticks = map$1(labelsResult.labels, function(labelItem) {
			return labelItem.tickValue;
		});
	} else {
		tickCategoryInterval = optionTickInterval;
		ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
	}
	return axisCacheSet(ticksCache, optionTickInterval, {
		ticks,
		tickCategoryInterval
	});
}
function makeRealNumberLabels(axis) {
	var ticks = axis.scale.getTicks();
	var labelFormatter = makeLabelFormatter(axis);
	return { labels: map$1(ticks, function(tick, idx) {
		return {
			formattedLabel: labelFormatter(tick, idx),
			rawLabel: axis.scale.getLabel(tick),
			tickValue: tick.value,
			time: tick.time,
			"break": tick["break"]
		};
	}) };
}
var ensureCategoryTickCache = initAxisCacheMethod("axisTick");
var ensureCategoryLabelCache = initAxisCacheMethod("axisLabel");
/**
* PENDING: refactor to JS Map? Because key can be a function or more complicated object, and
* cache size always is small, and currently no JS Map object key polyfill, we use a simple
* array cache instead of plain object hash.
*/
function initAxisCacheMethod(prop) {
	return function ensureCache(axis) {
		return axisInner(axis)[prop] || (axisInner(axis)[prop] = { list: [] });
	};
}
function axisCacheGet(cache, key$1) {
	for (var i = 0; i < cache.list.length; i++) if (cache.list[i].key === key$1) return cache.list[i].value;
}
function axisCacheSet(cache, key$1, value) {
	cache.list.push({
		key: key$1,
		value
	});
	return value;
}
function makeAutoCategoryInterval(axis, ctx) {
	if (ctx.kind === AxisTickLabelComputingKind.estimate) {
		var result_2 = axis.calculateCategoryInterval(ctx);
		ctx.out.noPxChangeTryDetermine.push(function() {
			axisInner(axis).autoInterval = result_2;
			return true;
		});
		return result_2;
	}
	var result = axisInner(axis).autoInterval;
	return result != null ? result : axisInner(axis).autoInterval = axis.calculateCategoryInterval(ctx);
}
/**
* Calculate interval for category axis ticks and labels.
* Use a stretegy to try to avoid overlapping.
* To get precise result, at least one of `getRotate` and `isHorizontal`
* should be implemented in axis.
*/
function calculateCategoryInterval(axis, ctx) {
	var kind = ctx.kind;
	var params = fetchAutoCategoryIntervalCalculationParams(axis);
	var labelFormatter = makeLabelFormatter(axis);
	var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
	var ordinalScale = axis.scale;
	var ordinalExtent = ordinalScale.getExtent();
	var tickCount = ordinalScale.count();
	if (ordinalExtent[1] - ordinalExtent[0] < 1) return 0;
	var step = 1;
	var maxCount = 40;
	if (tickCount > maxCount) step = Math.max(1, Math.floor(tickCount / maxCount));
	var tickValue = ordinalExtent[0];
	var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
	var unitW = Math.abs(unitSpan * Math.cos(rotation));
	var unitH = Math.abs(unitSpan * Math.sin(rotation));
	var maxW = 0;
	var maxH = 0;
	for (; tickValue <= ordinalExtent[1]; tickValue += step) {
		var width = 0;
		var height = 0;
		var rect = getBoundingRect(labelFormatter({ value: tickValue }), params.font, "center", "top");
		width = rect.width * 1.3;
		height = rect.height * 1.3;
		maxW = Math.max(maxW, width, 7);
		maxH = Math.max(maxH, height, 7);
	}
	var dw = maxW / unitW;
	var dh = maxH / unitH;
	isNaN(dw) && (dw = Infinity);
	isNaN(dh) && (dh = Infinity);
	var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
	if (kind === AxisTickLabelComputingKind.estimate) {
		ctx.out.noPxChangeTryDetermine.push(bind(calculateCategoryIntervalTryDetermine, null, axis, interval, tickCount));
		return interval;
	}
	var lastInterval = calculateCategoryIntervalDealCache(axis, interval, tickCount);
	return lastInterval != null ? lastInterval : interval;
}
function calculateCategoryIntervalTryDetermine(axis, interval, tickCount) {
	return calculateCategoryIntervalDealCache(axis, interval, tickCount) == null;
}
function calculateCategoryIntervalDealCache(axis, interval, tickCount) {
	var cache = modelInner(axis.model);
	var axisExtent = axis.getExtent();
	var lastAutoInterval = cache.lastAutoInterval;
	var lastTickCount = cache.lastTickCount;
	if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) return lastAutoInterval;
	else {
		cache.lastTickCount = tickCount;
		cache.lastAutoInterval = interval;
		cache.axisExtent0 = axisExtent[0];
		cache.axisExtent1 = axisExtent[1];
	}
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
	var labelModel = axis.getLabelModel();
	return {
		axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
		labelRotate: labelModel.get("rotate") || 0,
		font: labelModel.getFont()
	};
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
	var labelFormatter = makeLabelFormatter(axis);
	var ordinalScale = axis.scale;
	var ordinalExtent = ordinalScale.getExtent();
	var labelModel = axis.getLabelModel();
	var result = [];
	var step = Math.max((categoryInterval || 0) + 1, 1);
	var startTick = ordinalExtent[0];
	var tickCount = ordinalScale.count();
	if (startTick !== 0 && step > 1 && tickCount / step > 2) startTick = Math.round(Math.ceil(startTick / step) * step);
	var showAllLabel = shouldShowAllLabels(axis);
	var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
	var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
	if (includeMinLabel && startTick !== ordinalExtent[0]) addItem(ordinalExtent[0]);
	var tickValue = startTick;
	for (; tickValue <= ordinalExtent[1]; tickValue += step) addItem(tickValue);
	if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) addItem(ordinalExtent[1]);
	function addItem(tickValue$1) {
		var tickObj = { value: tickValue$1 };
		result.push(onlyTick ? tickValue$1 : {
			formattedLabel: labelFormatter(tickObj),
			rawLabel: ordinalScale.getLabel(tickObj),
			tickValue: tickValue$1,
			time: void 0,
			"break": void 0
		});
	}
	return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
	var ordinalScale = axis.scale;
	var labelFormatter = makeLabelFormatter(axis);
	var result = [];
	each(ordinalScale.getTicks(), function(tick) {
		var rawLabel = ordinalScale.getLabel(tick);
		var tickValue = tick.value;
		if (categoryInterval(tick.value, rawLabel)) result.push(onlyTick ? tickValue : {
			formattedLabel: labelFormatter(tick),
			rawLabel,
			tickValue,
			time: void 0,
			"break": void 0
		});
	});
	return result;
}

//#endregion
//#region node_modules/echarts/lib/coord/Axis.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var NORMALIZED_EXTENT = [0, 1];
/**
* Base class of Axis.
*
* Lifetime: recreate for each main process.
* [NOTICE]: Some caches is stored on the axis instance (see `axisTickLabelBuilder.ts`)
*  which is based on this lifetime.
*/
var Axis = function() {
	function Axis$1(dim, scale$2, extent) {
		this.onBand = false;
		this.inverse = false;
		this.dim = dim;
		this.scale = scale$2;
		this._extent = extent || [0, 0];
	}
	/**
	* If axis extent contain given coord
	*/
	Axis$1.prototype.contain = function(coord) {
		var extent = this._extent;
		var min$1 = Math.min(extent[0], extent[1]);
		var max$1 = Math.max(extent[0], extent[1]);
		return coord >= min$1 && coord <= max$1;
	};
	/**
	* If axis extent contain given data
	*/
	Axis$1.prototype.containData = function(data) {
		return this.scale.contain(this.scale.parse(data));
	};
	/**
	* Get coord extent.
	*/
	Axis$1.prototype.getExtent = function() {
		return this._extent.slice();
	};
	/**
	* Get precision used for formatting
	*/
	Axis$1.prototype.getPixelPrecision = function(dataExtent) {
		return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
	};
	/**
	* Set coord extent
	*/
	Axis$1.prototype.setExtent = function(start, end) {
		var extent = this._extent;
		extent[0] = start;
		extent[1] = end;
	};
	/**
	* Convert data to coord. Data is the rank if it has an ordinal scale
	*/
	Axis$1.prototype.dataToCoord = function(data, clamp$1) {
		var extent = this._extent;
		var scale$2 = this.scale;
		data = scale$2.normalize(scale$2.parse(data));
		if (this.onBand && scale$2.type === "ordinal") {
			extent = extent.slice();
			fixExtentWithBands(extent, scale$2.count());
		}
		return linearMap(data, NORMALIZED_EXTENT, extent, clamp$1);
	};
	/**
	* Convert coord to data. Data is the rank if it has an ordinal scale
	*/
	Axis$1.prototype.coordToData = function(coord, clamp$1) {
		var extent = this._extent;
		var scale$2 = this.scale;
		if (this.onBand && scale$2.type === "ordinal") {
			extent = extent.slice();
			fixExtentWithBands(extent, scale$2.count());
		}
		var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp$1);
		return this.scale.scale(t);
	};
	/**
	* Convert pixel point to data in axis
	*/
	Axis$1.prototype.pointToData = function(point, clamp$1) {};
	/**
	* Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
	* `axis.getTicksCoords` considers `onBand`, which is used by
	* `boundaryGap:true` of category axis and splitLine and splitArea.
	* @param opt.tickModel default: axis.model.getModel('axisTick')
	* @param opt.clamp If `true`, the first and the last
	*        tick must be at the axis end points. Otherwise, clip ticks
	*        that outside the axis extent.
	*/
	Axis$1.prototype.getTicksCoords = function(opt) {
		opt = opt || {};
		var tickModel = opt.tickModel || this.getTickModel();
		var ticks = createAxisTicks(this, tickModel, {
			breakTicks: opt.breakTicks,
			pruneByBreak: opt.pruneByBreak
		}).ticks;
		var ticksCoords = map$1(ticks, function(tickVal) {
			return {
				coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
				tickValue: tickVal
			};
		}, this);
		var alignWithLabel = tickModel.get("alignWithLabel");
		fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
		return ticksCoords;
	};
	Axis$1.prototype.getMinorTicksCoords = function() {
		if (this.scale.type === "ordinal") return [];
		var splitNumber = this.model.getModel("minorTick").get("splitNumber");
		if (!(splitNumber > 0 && splitNumber < 100)) splitNumber = 5;
		return map$1(this.scale.getMinorTicks(splitNumber), function(minorTicksGroup) {
			return map$1(minorTicksGroup, function(minorTick) {
				return {
					coord: this.dataToCoord(minorTick),
					tickValue: minorTick
				};
			}, this);
		}, this);
	};
	Axis$1.prototype.getViewLabels = function(ctx) {
		ctx = ctx || createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine);
		return createAxisLabels(this, ctx).labels;
	};
	Axis$1.prototype.getLabelModel = function() {
		return this.model.getModel("axisLabel");
	};
	/**
	* Notice here we only get the default tick model. For splitLine
	* or splitArea, we should pass the splitLineModel or splitAreaModel
	* manually when calling `getTicksCoords`.
	* In GL, this method may be overridden to:
	* `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
	*/
	Axis$1.prototype.getTickModel = function() {
		return this.model.getModel("axisTick");
	};
	/**
	* Get width of band
	*/
	Axis$1.prototype.getBandWidth = function() {
		var axisExtent = this._extent;
		var dataExtent = this.scale.getExtent();
		var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
		len === 0 && (len = 1);
		var size = Math.abs(axisExtent[1] - axisExtent[0]);
		return Math.abs(size) / len;
	};
	/**
	* Only be called in category axis.
	* Can be overridden, consider other axes like in 3D.
	* @return Auto interval for cateogry axis tick and label
	*/
	Axis$1.prototype.calculateCategoryInterval = function(ctx) {
		ctx = ctx || createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine);
		return calculateCategoryInterval(this, ctx);
	};
	return Axis$1;
}();
function fixExtentWithBands(extent, nTick) {
	var margin = (extent[1] - extent[0]) / nTick / 2;
	extent[0] += margin;
	extent[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp$1) {
	var ticksLen = ticksCoords.length;
	if (!axis.onBand || alignWithLabel || !ticksLen) return;
	var axisExtent = axis.getExtent();
	var last;
	var diffSize;
	if (ticksLen === 1) {
		ticksCoords[0].coord = axisExtent[0];
		ticksCoords[0].onBand = true;
		last = ticksCoords[1] = {
			coord: axisExtent[1],
			tickValue: ticksCoords[0].tickValue,
			onBand: true
		};
	} else {
		var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
		var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
		each(ticksCoords, function(ticksItem) {
			ticksItem.coord -= shift_1 / 2;
			ticksItem.onBand = true;
		});
		var dataExtent = axis.scale.getExtent();
		diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
		last = {
			coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize,
			tickValue: dataExtent[1] + 1,
			onBand: true
		};
		ticksCoords.push(last);
	}
	var inverse = axisExtent[0] > axisExtent[1];
	if (littleThan(ticksCoords[0].coord, axisExtent[0])) clamp$1 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
	if (clamp$1 && littleThan(axisExtent[0], ticksCoords[0].coord)) ticksCoords.unshift({
		coord: axisExtent[0],
		onBand: true
	});
	if (littleThan(axisExtent[1], last.coord)) clamp$1 ? last.coord = axisExtent[1] : ticksCoords.pop();
	if (clamp$1 && littleThan(last.coord, axisExtent[1])) ticksCoords.push({
		coord: axisExtent[1],
		onBand: true
	});
	function littleThan(a, b) {
		a = round(a);
		b = round(b);
		return inverse ? a > b : a < b;
	}
}
var Axis_default = Axis;

//#endregion
//#region node_modules/echarts/lib/util/symbol.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Triangle shape
* @inner
*/
var Triangle = Path_default.extend({
	type: "triangle",
	shape: {
		cx: 0,
		cy: 0,
		width: 0,
		height: 0
	},
	buildPath: function(path, shape) {
		var cx = shape.cx;
		var cy = shape.cy;
		var width = shape.width / 2;
		var height = shape.height / 2;
		path.moveTo(cx, cy - height);
		path.lineTo(cx + width, cy + height);
		path.lineTo(cx - width, cy + height);
		path.closePath();
	}
});
/**
* Diamond shape
* @inner
*/
var Diamond = Path_default.extend({
	type: "diamond",
	shape: {
		cx: 0,
		cy: 0,
		width: 0,
		height: 0
	},
	buildPath: function(path, shape) {
		var cx = shape.cx;
		var cy = shape.cy;
		var width = shape.width / 2;
		var height = shape.height / 2;
		path.moveTo(cx, cy - height);
		path.lineTo(cx + width, cy);
		path.lineTo(cx, cy + height);
		path.lineTo(cx - width, cy);
		path.closePath();
	}
});
/**
* Pin shape
* @inner
*/
var Pin = Path_default.extend({
	type: "pin",
	shape: {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	buildPath: function(path, shape) {
		var x = shape.x;
		var y = shape.y;
		var w = shape.width / 5 * 3;
		var h = Math.max(w, shape.height);
		var r = w / 2;
		var dy = r * r / (h - r);
		var cy = y - h + r + dy;
		var angle = Math.asin(dy / r);
		var dx = Math.cos(angle) * r;
		var tanX = Math.sin(angle);
		var tanY = Math.cos(angle);
		var cpLen = r * .6;
		var cpLen2 = r * .7;
		path.moveTo(x - dx, cy + dy);
		path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
		path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
		path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
		path.closePath();
	}
});
/**
* Arrow shape
* @inner
*/
var Arrow = Path_default.extend({
	type: "arrow",
	shape: {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	buildPath: function(ctx, shape) {
		var height = shape.height;
		var width = shape.width;
		var x = shape.x;
		var y = shape.y;
		var dx = width / 3 * 2;
		ctx.moveTo(x, y);
		ctx.lineTo(x + dx, y + height);
		ctx.lineTo(x, y + height / 4 * 3);
		ctx.lineTo(x - dx, y + height);
		ctx.lineTo(x, y);
		ctx.closePath();
	}
});
/**
* Map of path constructors
*/
var symbolCtors = {
	line: Line_default,
	rect: Rect_default,
	roundRect: Rect_default,
	square: Rect_default,
	circle: Circle_default,
	diamond: Diamond,
	pin: Pin,
	arrow: Arrow,
	triangle: Triangle
};
var symbolShapeMakers = {
	line: function(x, y, w, h, shape) {
		shape.x1 = x;
		shape.y1 = y + h / 2;
		shape.x2 = x + w;
		shape.y2 = y + h / 2;
	},
	rect: function(x, y, w, h, shape) {
		shape.x = x;
		shape.y = y;
		shape.width = w;
		shape.height = h;
	},
	roundRect: function(x, y, w, h, shape) {
		shape.x = x;
		shape.y = y;
		shape.width = w;
		shape.height = h;
		shape.r = Math.min(w, h) / 4;
	},
	square: function(x, y, w, h, shape) {
		var size = Math.min(w, h);
		shape.x = x;
		shape.y = y;
		shape.width = size;
		shape.height = size;
	},
	circle: function(x, y, w, h, shape) {
		shape.cx = x + w / 2;
		shape.cy = y + h / 2;
		shape.r = Math.min(w, h) / 2;
	},
	diamond: function(x, y, w, h, shape) {
		shape.cx = x + w / 2;
		shape.cy = y + h / 2;
		shape.width = w;
		shape.height = h;
	},
	pin: function(x, y, w, h, shape) {
		shape.x = x + w / 2;
		shape.y = y + h / 2;
		shape.width = w;
		shape.height = h;
	},
	arrow: function(x, y, w, h, shape) {
		shape.x = x + w / 2;
		shape.y = y + h / 2;
		shape.width = w;
		shape.height = h;
	},
	triangle: function(x, y, w, h, shape) {
		shape.cx = x + w / 2;
		shape.cy = y + h / 2;
		shape.width = w;
		shape.height = h;
	}
};
var symbolBuildProxies = {};
each(symbolCtors, function(Ctor, name) {
	symbolBuildProxies[name] = new Ctor();
});
var SymbolClz = Path_default.extend({
	type: "symbol",
	shape: {
		symbolType: "",
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	calculateTextPosition: function(out$1, config, rect) {
		var res = calculateTextPosition(out$1, config, rect);
		var shape = this.shape;
		if (shape && shape.symbolType === "pin" && config.position === "inside") res.y = rect.y + rect.height * .4;
		return res;
	},
	buildPath: function(ctx, shape, inBundle) {
		var symbolType = shape.symbolType;
		if (symbolType !== "none") {
			var proxySymbol = symbolBuildProxies[symbolType];
			if (!proxySymbol) {
				symbolType = "rect";
				proxySymbol = symbolBuildProxies[symbolType];
			}
			symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
			proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
		}
	}
});
function symbolPathSetColor(color$2, innerColor$1) {
	if (this.type !== "image") {
		var symbolStyle = this.style;
		if (this.__isEmptyBrush) {
			symbolStyle.stroke = color$2;
			symbolStyle.fill = innerColor$1 || tokens_default.color.neutral00;
			symbolStyle.lineWidth = 2;
		} else if (this.shape.symbolType === "line") symbolStyle.stroke = color$2;
		else symbolStyle.fill = color$2;
		this.markRedraw();
	}
}
/**
* Create a symbol element with given symbol configuration: shape, x, y, width, height, color
*/
function createSymbol(symbolType, x, y, w, h, color$2, keepAspect) {
	var isEmpty = symbolType.indexOf("empty") === 0;
	if (isEmpty) symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	var symbolPath;
	if (symbolType.indexOf("image://") === 0) symbolPath = makeImage(symbolType.slice(8), new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
	else if (symbolType.indexOf("path://") === 0) symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
	else symbolPath = new SymbolClz({ shape: {
		symbolType,
		x,
		y,
		width: w,
		height: h
	} });
	symbolPath.__isEmptyBrush = isEmpty;
	symbolPath.setColor = symbolPathSetColor;
	if (color$2) symbolPath.setColor(color$2);
	return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
	if (!isArray(symbolSize)) symbolSize = [+symbolSize, +symbolSize];
	return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
	if (symbolOffset == null) return;
	if (!isArray(symbolOffset)) symbolOffset = [symbolOffset, symbolOffset];
	return [parsePercent(symbolOffset[0], symbolSize[0]) || 0, parsePercent(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
}

//#endregion
//#region node_modules/echarts/lib/util/throttle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
/**
* @public
* @param {(Function)} fn
* @param {number} [delay=0] Unit: ms.
* @param {boolean} [debounce=false]
*        true: If call interval less than `delay`, only the last call works.
*        false: If call interval less than `delay, call works on fixed rate.
* @return {(Function)} throttled fn.
*/
function throttle(fn, delay, debounce) {
	var currCall;
	var lastCall = 0;
	var lastExec = 0;
	var timer = null;
	var diff;
	var scope;
	var args;
	var debounceNextCall;
	delay = delay || 0;
	function exec() {
		lastExec = (/* @__PURE__ */ new Date()).getTime();
		timer = null;
		fn.apply(scope, args || []);
	}
	var cb = function() {
		var cbArgs = [];
		for (var _i = 0; _i < arguments.length; _i++) cbArgs[_i] = arguments[_i];
		currCall = (/* @__PURE__ */ new Date()).getTime();
		scope = this;
		args = cbArgs;
		var thisDelay = debounceNextCall || delay;
		var thisDebounce = debounceNextCall || debounce;
		debounceNextCall = null;
		diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
		clearTimeout(timer);
		if (thisDebounce) timer = setTimeout(exec, thisDelay);
		else if (diff >= 0) exec();
		else timer = setTimeout(exec, -diff);
		lastCall = currCall;
	};
	/**
	* Clear throttle.
	* @public
	*/
	cb.clear = function() {
		if (timer) {
			clearTimeout(timer);
			timer = null;
		}
	};
	/**
	* Enable debounce once.
	*/
	cb.debounceNextCall = function(debounceDelay) {
		debounceNextCall = debounceDelay;
	};
	return cb;
}
/**
* Create throttle method or update throttle rate.
*
* @example
* ComponentView.prototype.render = function () {
*     ...
*     throttle.createOrUpdate(
*         this,
*         '_dispatchAction',
*         this.model.get('throttle'),
*         'fixRate'
*     );
* };
* ComponentView.prototype.remove = function () {
*     throttle.clear(this, '_dispatchAction');
* };
* ComponentView.prototype.dispose = function () {
*     throttle.clear(this, '_dispatchAction');
* };
*
*/
function createOrUpdate(obj, fnAttr, rate, throttleType) {
	var fn = obj[fnAttr];
	if (!fn) return;
	var originFn = fn[ORIGIN_METHOD] || fn;
	var lastThrottleType = fn[THROTTLE_TYPE];
	if (fn[RATE] !== rate || lastThrottleType !== throttleType) {
		if (rate == null || !throttleType) return obj[fnAttr] = originFn;
		fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
		fn[ORIGIN_METHOD] = originFn;
		fn[THROTTLE_TYPE] = throttleType;
		fn[RATE] = rate;
	}
	return fn;
}
/**
* Clear throttle. Example see throttle.createOrUpdate.
*/
function clear(obj, fnAttr) {
	var fn = obj[fnAttr];
	if (fn && fn[ORIGIN_METHOD]) {
		fn.clear && fn.clear();
		obj[fnAttr] = fn[ORIGIN_METHOD];
	}
}

//#endregion
//#region node_modules/echarts/lib/model/globalDefault.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var platform = "";
if (typeof navigator !== "undefined") platform = navigator.platform || "";
var decalColor = "rgba(0, 0, 0, 0.2)";
var themeColor = tokens_default.color.theme[0];
var lightThemeColor = modifyHSL(themeColor, null, null, .9);
var globalDefault_default = {
	darkMode: "auto",
	colorBy: "series",
	color: tokens_default.color.theme,
	gradientColor: [lightThemeColor, themeColor],
	aria: { decal: { decals: [
		{
			color: decalColor,
			dashArrayX: [1, 0],
			dashArrayY: [2, 5],
			symbolSize: 1,
			rotation: Math.PI / 6
		},
		{
			color: decalColor,
			symbol: "circle",
			dashArrayX: [[8, 8], [
				0,
				8,
				8,
				0
			]],
			dashArrayY: [6, 0],
			symbolSize: .8
		},
		{
			color: decalColor,
			dashArrayX: [1, 0],
			dashArrayY: [4, 3],
			rotation: -Math.PI / 4
		},
		{
			color: decalColor,
			dashArrayX: [[6, 6], [
				0,
				6,
				6,
				0
			]],
			dashArrayY: [6, 0]
		},
		{
			color: decalColor,
			dashArrayX: [[1, 0], [1, 6]],
			dashArrayY: [
				1,
				0,
				6,
				0
			],
			rotation: Math.PI / 4
		},
		{
			color: decalColor,
			symbol: "triangle",
			dashArrayX: [[9, 9], [
				0,
				9,
				9,
				0
			]],
			dashArrayY: [7, 2],
			symbolSize: .75
		}
	] } },
	textStyle: {
		fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
		fontSize: 12,
		fontStyle: "normal",
		fontWeight: "normal"
	},
	blendMode: null,
	stateAnimation: {
		duration: 300,
		easing: "cubicOut"
	},
	animation: "auto",
	animationDuration: 1e3,
	animationDurationUpdate: 500,
	animationEasing: "cubicInOut",
	animationEasingUpdate: "cubicInOut",
	animationThreshold: 2e3,
	progressiveThreshold: 3e3,
	progressive: 400,
	hoverLayerThreshold: 3e3,
	useUTC: false
};

//#endregion
//#region node_modules/echarts/lib/model/internalComponentCreator.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(mainType, creator) {
	assert(internalOptionCreatorMap.get(mainType) == null && creator);
	internalOptionCreatorMap.set(mainType, creator);
}
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
	var internalOptionCreator = internalOptionCreatorMap.get(mainType);
	if (!internalOptionCreator) return newCmptOptionList;
	var internalOptions = internalOptionCreator(ecModel);
	if (!internalOptions) return newCmptOptionList;
	for (var i = 0; i < internalOptions.length; i++) assert(isComponentIdInternal(internalOptions[i]));
	return newCmptOptionList.concat(internalOptions);
}

//#endregion
//#region node_modules/echarts/lib/model/mixin/palette.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var innerColor = makeInner();
var innerDecal = makeInner();
var PaletteMixin = function() {
	function PaletteMixin$1() {}
	PaletteMixin$1.prototype.getColorFromPalette = function(name, scope, requestNum) {
		var defaultPalette = normalizeToArray(this.get("color", true));
		var layeredPalette = this.get("colorLayer", true);
		return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
	};
	PaletteMixin$1.prototype.clearColorPalette = function() {
		clearPalette(this, innerColor);
	};
	return PaletteMixin$1;
}();
function getDecalFromPalette(ecModel, name, scope, requestNum) {
	return getFromPalette(ecModel, innerDecal, normalizeToArray(ecModel.get([
		"aria",
		"decal",
		"decals"
	])), null, name, scope, requestNum);
}
function getNearestPalette(palettes, requestColorNum) {
	var paletteNum = palettes.length;
	for (var i = 0; i < paletteNum; i++) if (palettes[i].length > requestColorNum) return palettes[i];
	return palettes[paletteNum - 1];
}
/**
* @param name MUST NOT be null/undefined. Otherwise call this function
*             twise with the same parameters will get different result.
* @param scope default this.
* @return Can be null/undefined
*/
function getFromPalette(that, inner$5, defaultPalette, layeredPalette, name, scope, requestNum) {
	scope = scope || that;
	var scopeFields = inner$5(scope);
	var paletteIdx = scopeFields.paletteIdx || 0;
	var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
	if (paletteNameMap.hasOwnProperty(name)) return paletteNameMap[name];
	var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
	palette = palette || defaultPalette;
	if (!palette || !palette.length) return;
	var pickedPaletteItem = palette[paletteIdx];
	if (name) paletteNameMap[name] = pickedPaletteItem;
	scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
	return pickedPaletteItem;
}
function clearPalette(that, inner$5) {
	inner$5(that).paletteIdx = 0;
	inner$5(that).paletteNameMap = {};
}

//#endregion
//#region node_modules/echarts/lib/model/Global.js
/**
* Caution: If the mechanism should be changed some day, these cases
* should be considered:
*
* (1) In `merge option` mode, if using the same option to call `setOption`
* many times, the result should be the same (try our best to ensure that).
* (2) In `merge option` mode, if a component has no id/name specified, it
* will be merged by index, and the result sequence of the components is
* consistent to the original sequence.
* (3) In `replaceMerge` mode, keep the result sequence of the components is
* consistent to the original sequence, even though there might result in "hole".
* (4) `reset` feature (in toolbox). Find detailed info in comments about
* `mergeOption` in module:echarts/model/OptionManager.
*/
init_tslib_es6();
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\0_ec_inner";
var OPTION_INNER_VALUE = 1;
var BUITIN_COMPONENTS_MAP = {
	grid: "GridComponent",
	polar: "PolarComponent",
	geo: "GeoComponent",
	singleAxis: "SingleAxisComponent",
	parallel: "ParallelComponent",
	calendar: "CalendarComponent",
	matrix: "MatrixComponent",
	graphic: "GraphicComponent",
	toolbox: "ToolboxComponent",
	tooltip: "TooltipComponent",
	axisPointer: "AxisPointerComponent",
	brush: "BrushComponent",
	title: "TitleComponent",
	timeline: "TimelineComponent",
	markPoint: "MarkPointComponent",
	markLine: "MarkLineComponent",
	markArea: "MarkAreaComponent",
	legend: "LegendComponent",
	dataZoom: "DataZoomComponent",
	visualMap: "VisualMapComponent",
	xAxis: "GridComponent",
	yAxis: "GridComponent",
	angleAxis: "PolarComponent",
	radiusAxis: "PolarComponent"
};
var BUILTIN_CHARTS_MAP = {
	line: "LineChart",
	bar: "BarChart",
	pie: "PieChart",
	scatter: "ScatterChart",
	radar: "RadarChart",
	map: "MapChart",
	tree: "TreeChart",
	treemap: "TreemapChart",
	graph: "GraphChart",
	chord: "ChordChart",
	gauge: "GaugeChart",
	funnel: "FunnelChart",
	parallel: "ParallelChart",
	sankey: "SankeyChart",
	boxplot: "BoxplotChart",
	candlestick: "CandlestickChart",
	effectScatter: "EffectScatterChart",
	lines: "LinesChart",
	heatmap: "HeatmapChart",
	pictorialBar: "PictorialBarChart",
	themeRiver: "ThemeRiverChart",
	sunburst: "SunburstChart",
	custom: "CustomChart"
};
var componetsMissingLogPrinted = {};
function checkMissingComponents(option) {
	each(option, function(componentOption, mainType) {
		if (!Component_default$1.hasClass(mainType)) {
			var componentImportName = BUITIN_COMPONENTS_MAP[mainType];
			if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
				error("Component " + mainType + " is used but not imported.\nimport { " + componentImportName + " } from 'echarts/components';\necharts.use([" + componentImportName + "]);");
				componetsMissingLogPrinted[componentImportName] = true;
			}
		}
	});
}
var GlobalModel = function(_super) {
	__extends(GlobalModel$1, _super);
	function GlobalModel$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	GlobalModel$1.prototype.init = function(option, parentModel, ecModel, theme$1, locale, optionManager) {
		theme$1 = theme$1 || {};
		this.option = null;
		this._theme = new Model_default(theme$1);
		this._locale = new Model_default(locale);
		this._optionManager = optionManager;
	};
	GlobalModel$1.prototype.setOption = function(option, opts, optionPreprocessorFuncs$1) {
		assert(option != null, "option is null/undefined");
		assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()");
		var innerOpt = normalizeSetOptionInput(opts);
		this._optionManager.setOption(option, optionPreprocessorFuncs$1, innerOpt);
		this._resetOption(null, innerOpt);
	};
	/**
	* @param type null/undefined: reset all.
	*        'recreate': force recreate all.
	*        'timeline': only reset timeline option
	*        'media': only reset media query option
	* @return Whether option changed.
	*/
	GlobalModel$1.prototype.resetOption = function(type, opt) {
		return this._resetOption(type, normalizeSetOptionInput(opt));
	};
	GlobalModel$1.prototype._resetOption = function(type, opt) {
		var optionChanged = false;
		var optionManager = this._optionManager;
		if (!type || type === "recreate") {
			var baseOption = optionManager.mountOption(type === "recreate");
			checkMissingComponents(baseOption);
			if (!this.option || type === "recreate") initBase(this, baseOption);
			else {
				this.restoreData();
				this._mergeOption(baseOption, opt);
			}
			optionChanged = true;
		}
		if (type === "timeline" || type === "media") this.restoreData();
		if (!type || type === "recreate" || type === "timeline") {
			var timelineOption = optionManager.getTimelineOption(this);
			if (timelineOption) {
				optionChanged = true;
				this._mergeOption(timelineOption, opt);
			}
		}
		if (!type || type === "recreate" || type === "media") {
			var mediaOptions = optionManager.getMediaOption(this);
			if (mediaOptions.length) each(mediaOptions, function(mediaOption) {
				optionChanged = true;
				this._mergeOption(mediaOption, opt);
			}, this);
		}
		return optionChanged;
	};
	GlobalModel$1.prototype.mergeOption = function(option) {
		this._mergeOption(option, null);
	};
	GlobalModel$1.prototype._mergeOption = function(newOption, opt) {
		var option = this.option;
		var componentsMap = this._componentsMap;
		var componentsCount = this._componentsCount;
		var newCmptTypes = [];
		var newCmptTypeMap = createHashMap();
		var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
		resetSourceDefaulter(this);
		each(newOption, function(componentOption, mainType) {
			if (componentOption == null) return;
			if (!Component_default$1.hasClass(mainType)) option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
			else if (mainType) {
				newCmptTypes.push(mainType);
				newCmptTypeMap.set(mainType, true);
			}
		});
		if (replaceMergeMainTypeMap) replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
			if (Component_default$1.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
				newCmptTypes.push(mainTypeInReplaceMerge);
				newCmptTypeMap.set(mainTypeInReplaceMerge, true);
			}
		});
		Component_default$1.topologicalTravel(newCmptTypes, Component_default$1.getAllClassMainTypes(), visitComponent, this);
		function visitComponent(mainType) {
			var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
			var oldCmptList = componentsMap.get(mainType);
			var mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
			var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
			setComponentTypeToKeyInfo(mappingResult, mainType, Component_default$1);
			option[mainType] = null;
			componentsMap.set(mainType, null);
			componentsCount.set(mainType, 0);
			var optionsByMainType = [];
			var cmptsByMainType = [];
			var cmptsCountByMainType = 0;
			var tooltipExists;
			var tooltipWarningLogged;
			each(mappingResult, function(resultItem, index) {
				var componentModel = resultItem.existing;
				var newCmptOption = resultItem.newOption;
				if (!newCmptOption) {
					if (componentModel) {
						componentModel.mergeOption({}, this);
						componentModel.optionUpdated({}, false);
					}
				} else {
					var isSeriesType = mainType === "series";
					var ComponentModelClass = Component_default$1.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType);
					if (!ComponentModelClass) {
						var subType = resultItem.keyInfo.subType;
						var seriesImportName = BUILTIN_CHARTS_MAP[subType];
						if (!componetsMissingLogPrinted[subType]) {
							componetsMissingLogPrinted[subType] = true;
							if (seriesImportName) error("Series " + subType + " is used but not imported.\nimport { " + seriesImportName + " } from 'echarts/charts';\necharts.use([" + seriesImportName + "]);");
							else error("Unknown series " + subType);
						}
						return;
					}
					if (mainType === "tooltip") {
						if (tooltipExists) {
							if (!tooltipWarningLogged) {
								warn("Currently only one tooltip component is allowed.");
								tooltipWarningLogged = true;
							}
							return;
						}
						tooltipExists = true;
					}
					if (componentModel && componentModel.constructor === ComponentModelClass) {
						componentModel.name = resultItem.keyInfo.name;
						componentModel.mergeOption(newCmptOption, this);
						componentModel.optionUpdated(newCmptOption, false);
					} else {
						var extraOpt = extend({ componentIndex: index }, resultItem.keyInfo);
						componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
						extend(componentModel, extraOpt);
						if (resultItem.brandNew) componentModel.__requireNewView = true;
						componentModel.init(newCmptOption, this, this);
						componentModel.optionUpdated(null, true);
					}
				}
				if (componentModel) {
					optionsByMainType.push(componentModel.option);
					cmptsByMainType.push(componentModel);
					cmptsCountByMainType++;
				} else {
					optionsByMainType.push(void 0);
					cmptsByMainType.push(void 0);
				}
			}, this);
			option[mainType] = optionsByMainType;
			componentsMap.set(mainType, cmptsByMainType);
			componentsCount.set(mainType, cmptsCountByMainType);
			if (mainType === "series") reCreateSeriesIndices(this);
		}
		if (!this._seriesIndices) reCreateSeriesIndices(this);
	};
	/**
	* Get option for output (cloned option and inner info removed)
	*/
	GlobalModel$1.prototype.getOption = function() {
		var option = clone(this.option);
		each(option, function(optInMainType, mainType) {
			if (Component_default$1.hasClass(mainType)) {
				var opts = normalizeToArray(optInMainType);
				var realLen = opts.length;
				var metNonInner = false;
				for (var i = realLen - 1; i >= 0; i--) if (opts[i] && !isComponentIdInternal(opts[i])) metNonInner = true;
				else {
					opts[i] = null;
					!metNonInner && realLen--;
				}
				opts.length = realLen;
				option[mainType] = opts;
			}
		});
		delete option[OPTION_INNER_KEY];
		return option;
	};
	GlobalModel$1.prototype.setTheme = function(theme$1) {
		this._theme = new Model_default(theme$1);
		this._resetOption("recreate", null);
	};
	GlobalModel$1.prototype.getTheme = function() {
		return this._theme;
	};
	GlobalModel$1.prototype.getLocaleModel = function() {
		return this._locale;
	};
	GlobalModel$1.prototype.setUpdatePayload = function(payload) {
		this._payload = payload;
	};
	GlobalModel$1.prototype.getUpdatePayload = function() {
		return this._payload;
	};
	/**
	* @param idx If not specified, return the first one.
	*/
	GlobalModel$1.prototype.getComponent = function(mainType, idx) {
		var list = this._componentsMap.get(mainType);
		if (list) {
			var cmpt = list[idx || 0];
			if (cmpt) return cmpt;
			else if (idx == null) {
				for (var i = 0; i < list.length; i++) if (list[i]) return list[i];
			}
		}
	};
	/**
	* @return Never be null/undefined.
	*/
	GlobalModel$1.prototype.queryComponents = function(condition) {
		var mainType = condition.mainType;
		if (!mainType) return [];
		var index = condition.index;
		var id = condition.id;
		var name = condition.name;
		var cmpts = this._componentsMap.get(mainType);
		if (!cmpts || !cmpts.length) return [];
		var result;
		if (index != null) {
			result = [];
			each(normalizeToArray(index), function(idx) {
				cmpts[idx] && result.push(cmpts[idx]);
			});
		} else if (id != null) result = queryByIdOrName("id", id, cmpts);
		else if (name != null) result = queryByIdOrName("name", name, cmpts);
		else result = filter(cmpts, function(cmpt) {
			return !!cmpt;
		});
		return filterBySubType(result, condition);
	};
	/**
	* The interface is different from queryComponents,
	* which is convenient for inner usage.
	*
	* @usage
	* let result = findComponents(
	*     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
	* );
	* let result = findComponents(
	*     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
	* );
	* let result = findComponents(
	*     {mainType: 'series',
	*     filter: function (model, index) {...}}
	* );
	* // result like [component0, componnet1, ...]
	*/
	GlobalModel$1.prototype.findComponents = function(condition) {
		var query = condition.query;
		var mainType = condition.mainType;
		var queryCond = getQueryCond(query);
		return doFilter(filterBySubType(queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), function(cmpt) {
			return !!cmpt;
		}), condition));
		function getQueryCond(q) {
			var indexAttr = mainType + "Index";
			var idAttr = mainType + "Id";
			var nameAttr = mainType + "Name";
			return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
				mainType,
				index: q[indexAttr],
				id: q[idAttr],
				name: q[nameAttr]
			} : null;
		}
		function doFilter(res) {
			return condition.filter ? filter(res, condition.filter) : res;
		}
	};
	GlobalModel$1.prototype.eachComponent = function(mainType, cb, context) {
		var componentsMap = this._componentsMap;
		if (isFunction(mainType)) {
			var ctxForAll_1 = cb;
			var cbForAll_1 = mainType;
			componentsMap.each(function(cmpts$1, componentType) {
				for (var i$1 = 0; cmpts$1 && i$1 < cmpts$1.length; i$1++) {
					var cmpt$1 = cmpts$1[i$1];
					cmpt$1 && cbForAll_1.call(ctxForAll_1, componentType, cmpt$1, cmpt$1.componentIndex);
				}
			});
		} else {
			var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject$1(mainType) ? this.findComponents(mainType) : null;
			for (var i = 0; cmpts && i < cmpts.length; i++) {
				var cmpt = cmpts[i];
				cmpt && cb.call(context, cmpt, cmpt.componentIndex);
			}
		}
	};
	/**
	* Get series list before filtered by name.
	*/
	GlobalModel$1.prototype.getSeriesByName = function(name) {
		var nameStr = convertOptionIdName(name, null);
		return filter(this._componentsMap.get("series"), function(oneSeries) {
			return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
		});
	};
	/**
	* Get series list before filtered by index.
	*/
	GlobalModel$1.prototype.getSeriesByIndex = function(seriesIndex) {
		return this._componentsMap.get("series")[seriesIndex];
	};
	/**
	* Get series list before filtered by type.
	* FIXME: rename to getRawSeriesByType?
	*/
	GlobalModel$1.prototype.getSeriesByType = function(subType) {
		return filter(this._componentsMap.get("series"), function(oneSeries) {
			return !!oneSeries && oneSeries.subType === subType;
		});
	};
	/**
	* Get all series before filtered.
	*/
	GlobalModel$1.prototype.getSeries = function() {
		return filter(this._componentsMap.get("series"), function(oneSeries) {
			return !!oneSeries;
		});
	};
	/**
	* Count series before filtered.
	*/
	GlobalModel$1.prototype.getSeriesCount = function() {
		return this._componentsCount.get("series");
	};
	/**
	* After filtering, series may be different
	* from raw series.
	*/
	GlobalModel$1.prototype.eachSeries = function(cb, context) {
		assertSeriesInitialized(this);
		each(this._seriesIndices, function(rawSeriesIndex) {
			var series = this._componentsMap.get("series")[rawSeriesIndex];
			cb.call(context, series, rawSeriesIndex);
		}, this);
	};
	/**
	* Iterate raw series before filtered.
	*
	* @param {Function} cb
	* @param {*} context
	*/
	GlobalModel$1.prototype.eachRawSeries = function(cb, context) {
		each(this._componentsMap.get("series"), function(series) {
			series && cb.call(context, series, series.componentIndex);
		});
	};
	/**
	* After filtering, series may be different.
	* from raw series.
	*/
	GlobalModel$1.prototype.eachSeriesByType = function(subType, cb, context) {
		assertSeriesInitialized(this);
		each(this._seriesIndices, function(rawSeriesIndex) {
			var series = this._componentsMap.get("series")[rawSeriesIndex];
			if (series.subType === subType) cb.call(context, series, rawSeriesIndex);
		}, this);
	};
	/**
	* Iterate raw series before filtered of given type.
	*/
	GlobalModel$1.prototype.eachRawSeriesByType = function(subType, cb, context) {
		return each(this.getSeriesByType(subType), cb, context);
	};
	GlobalModel$1.prototype.isSeriesFiltered = function(seriesModel) {
		assertSeriesInitialized(this);
		return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
	};
	GlobalModel$1.prototype.getCurrentSeriesIndices = function() {
		return (this._seriesIndices || []).slice();
	};
	GlobalModel$1.prototype.filterSeries = function(cb, context) {
		assertSeriesInitialized(this);
		var newSeriesIndices = [];
		each(this._seriesIndices, function(seriesRawIdx) {
			var series = this._componentsMap.get("series")[seriesRawIdx];
			cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
		}, this);
		this._seriesIndices = newSeriesIndices;
		this._seriesIndicesMap = createHashMap(newSeriesIndices);
	};
	GlobalModel$1.prototype.restoreData = function(payload) {
		reCreateSeriesIndices(this);
		var componentsMap = this._componentsMap;
		var componentTypes = [];
		componentsMap.each(function(components, componentType) {
			if (Component_default$1.hasClass(componentType)) componentTypes.push(componentType);
		});
		Component_default$1.topologicalTravel(componentTypes, Component_default$1.getAllClassMainTypes(), function(componentType) {
			each(componentsMap.get(componentType), function(component) {
				if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) component.restoreData();
			});
		});
	};
	GlobalModel$1.internalField = function() {
		reCreateSeriesIndices = function(ecModel) {
			var seriesIndices = ecModel._seriesIndices = [];
			each(ecModel._componentsMap.get("series"), function(series) {
				series && seriesIndices.push(series.componentIndex);
			});
			ecModel._seriesIndicesMap = createHashMap(seriesIndices);
		};
		assertSeriesInitialized = function(ecModel) {
			if (!ecModel._seriesIndices) throw new Error("Option should contains series.");
		};
		initBase = function(ecModel, baseOption) {
			ecModel.option = {};
			ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
			ecModel._componentsMap = createHashMap({ series: [] });
			ecModel._componentsCount = createHashMap();
			var airaOption = baseOption.aria;
			if (isObject$1(airaOption) && airaOption.enabled == null) airaOption.enabled = true;
			mergeTheme(baseOption, ecModel._theme.option);
			merge(baseOption, globalDefault_default, false);
			ecModel._mergeOption(baseOption, null);
		};
	}();
	return GlobalModel$1;
}(Model_default);
function isNotTargetSeries(seriesModel, payload) {
	if (payload) {
		var index = payload.seriesIndex;
		var id = payload.seriesId;
		var name_1 = payload.seriesName;
		return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
	}
}
function mergeTheme(option, theme$1) {
	var notMergeColorLayer = option.color && !option.colorLayer;
	each(theme$1, function(themeItem, name) {
		if (name === "colorLayer" && notMergeColorLayer || name === "color" && option.color) return;
		if (!Component_default$1.hasClass(name)) {
			if (typeof themeItem === "object") option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);
			else if (option[name] == null) option[name] = themeItem;
		}
	});
}
function queryByIdOrName(attr, idOrName, cmpts) {
	if (isArray(idOrName)) {
		var keyMap_1 = createHashMap();
		each(idOrName, function(idOrNameItem) {
			if (idOrNameItem != null) convertOptionIdName(idOrNameItem, null) != null && keyMap_1.set(idOrNameItem, true);
		});
		return filter(cmpts, function(cmpt) {
			return cmpt && keyMap_1.get(cmpt[attr]);
		});
	} else {
		var idName_1 = convertOptionIdName(idOrName, null);
		return filter(cmpts, function(cmpt) {
			return cmpt && idName_1 != null && cmpt[attr] === idName_1;
		});
	}
}
function filterBySubType(components, condition) {
	return condition.hasOwnProperty("subType") ? filter(components, function(cmpt) {
		return cmpt && cmpt.subType === condition.subType;
	}) : components;
}
function normalizeSetOptionInput(opts) {
	var replaceMergeMainTypeMap = createHashMap();
	opts && each(normalizeToArray(opts.replaceMerge), function(mainType) {
		assert(Component_default$1.hasClass(mainType), "\"" + mainType + "\" is not valid component main type in \"replaceMerge\"");
		replaceMergeMainTypeMap.set(mainType, true);
	});
	return { replaceMergeMainTypeMap };
}
mixin(GlobalModel, PaletteMixin);
var Global_default = GlobalModel;

//#endregion
//#region node_modules/echarts/lib/core/ExtensionAPI.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var availableMethods = [
	"getDom",
	"getZr",
	"getWidth",
	"getHeight",
	"getDevicePixelRatio",
	"dispatchAction",
	"isSSR",
	"isDisposed",
	"on",
	"off",
	"getDataURL",
	"getConnectedDataURL",
	"getOption",
	"getId",
	"updateLabelLayout"
];
var ExtensionAPI = function() {
	function ExtensionAPI$1(ecInstance) {
		each(availableMethods, function(methodName) {
			this[methodName] = bind(ecInstance[methodName], ecInstance);
		}, this);
	}
	return ExtensionAPI$1;
}();
var ExtensionAPI_default = ExtensionAPI;

//#endregion
//#region node_modules/echarts/lib/model/OptionManager.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var QUERY_REG = /^(min|max)?(.+)$/;
/**
* TERM EXPLANATIONS:
* See `ECOption` and `ECUnitOption` in `src/util/types.ts`.
*/
var OptionManager = function() {
	function OptionManager$1(api) {
		this._timelineOptions = [];
		this._mediaList = [];
		/**
		* -1, means default.
		* empty means no media.
		*/
		this._currentMediaIndices = [];
		this._api = api;
	}
	OptionManager$1.prototype.setOption = function(rawOption, optionPreprocessorFuncs$1, opt) {
		if (rawOption) {
			each(normalizeToArray(rawOption.series), function(series) {
				series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
			});
			each(normalizeToArray(rawOption.dataset), function(dataset) {
				dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
			});
		}
		rawOption = clone(rawOption);
		var optionBackup = this._optionBackup;
		var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs$1, !optionBackup);
		this._newBaseOption = newParsedOption.baseOption;
		if (optionBackup) {
			if (newParsedOption.timelineOptions.length) optionBackup.timelineOptions = newParsedOption.timelineOptions;
			if (newParsedOption.mediaList.length) optionBackup.mediaList = newParsedOption.mediaList;
			if (newParsedOption.mediaDefault) optionBackup.mediaDefault = newParsedOption.mediaDefault;
		} else this._optionBackup = newParsedOption;
	};
	OptionManager$1.prototype.mountOption = function(isRecreate) {
		var optionBackup = this._optionBackup;
		this._timelineOptions = optionBackup.timelineOptions;
		this._mediaList = optionBackup.mediaList;
		this._mediaDefault = optionBackup.mediaDefault;
		this._currentMediaIndices = [];
		return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
	};
	OptionManager$1.prototype.getTimelineOption = function(ecModel) {
		var option;
		var timelineOptions = this._timelineOptions;
		if (timelineOptions.length) {
			var timelineModel = ecModel.getComponent("timeline");
			if (timelineModel) option = clone(timelineOptions[timelineModel.getCurrentIndex()]);
		}
		return option;
	};
	OptionManager$1.prototype.getMediaOption = function(ecModel) {
		var ecWidth = this._api.getWidth();
		var ecHeight = this._api.getHeight();
		var mediaList = this._mediaList;
		var mediaDefault = this._mediaDefault;
		var indices = [];
		var result = [];
		if (!mediaList.length && !mediaDefault) return result;
		for (var i = 0, len = mediaList.length; i < len; i++) if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) indices.push(i);
		if (!indices.length && mediaDefault) indices = [-1];
		if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) result = map$1(indices, function(index) {
			return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
		});
		this._currentMediaIndices = indices;
		return result;
	};
	return OptionManager$1;
}();
/**
* [RAW_OPTION_PATTERNS]
* (Note: "series: []" represents all other props in `ECUnitOption`)
*
* (1) No prop "baseOption" declared:
* Root option is used as "baseOption" (except prop "options" and "media").
* ```js
* option = {
*     series: [],
*     timeline: {},
*     options: [],
* };
* option = {
*     series: [],
*     media: {},
* };
* option = {
*     series: [],
*     timeline: {},
*     options: [],
*     media: {},
* }
* ```
*
* (2) Prop "baseOption" declared:
* If "baseOption" declared, `ECUnitOption` props can only be declared
* inside "baseOption" except prop "timeline" (compat ec2).
* ```js
* option = {
*     baseOption: {
*         timeline: {},
*         series: [],
*     },
*     options: []
* };
* option = {
*     baseOption: {
*         series: [],
*     },
*     media: []
* };
* option = {
*     baseOption: {
*         timeline: {},
*         series: [],
*     },
*     options: []
*     media: []
* };
* option = {
*     // ec3 compat ec2: allow (only) `timeline` declared
*     // outside baseOption. Keep this setting for compat.
*     timeline: {},
*     baseOption: {
*         series: [],
*     },
*     options: [],
*     media: []
* };
* ```
*/
function parseRawOption(rawOption, optionPreprocessorFuncs$1, isNew) {
	var mediaList = [];
	var mediaDefault;
	var baseOption;
	var declaredBaseOption = rawOption.baseOption;
	var timelineOnRoot = rawOption.timeline;
	var timelineOptionsOnRoot = rawOption.options;
	var mediaOnRoot = rawOption.media;
	var hasMedia = !!rawOption.media;
	var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
	if (declaredBaseOption) {
		baseOption = declaredBaseOption;
		if (!baseOption.timeline) baseOption.timeline = timelineOnRoot;
	} else {
		if (hasTimeline || hasMedia) rawOption.options = rawOption.media = null;
		baseOption = rawOption;
	}
	if (hasMedia) if (isArray(mediaOnRoot)) each(mediaOnRoot, function(singleMedia) {
		if (singleMedia && !singleMedia.option && isObject$1(singleMedia.query) && isObject$1(singleMedia.query.option)) error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }");
		if (singleMedia && singleMedia.option) {
			if (singleMedia.query) mediaList.push(singleMedia);
			else if (!mediaDefault) mediaDefault = singleMedia;
		}
	});
	else error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }");
	doPreprocess(baseOption);
	each(timelineOptionsOnRoot, function(option) {
		return doPreprocess(option);
	});
	each(mediaList, function(media) {
		return doPreprocess(media.option);
	});
	function doPreprocess(option) {
		each(optionPreprocessorFuncs$1, function(preProcess) {
			preProcess(option, isNew);
		});
	}
	return {
		baseOption,
		timelineOptions: timelineOptionsOnRoot || [],
		mediaDefault,
		mediaList
	};
}
/**
* @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
* Support: width, height, aspectRatio
* Can use max or min as prefix.
*/
function applyMediaQuery(query, ecWidth, ecHeight) {
	var realMap = {
		width: ecWidth,
		height: ecHeight,
		aspectratio: ecWidth / ecHeight
	};
	var applicable = true;
	each(query, function(value, attr) {
		var matched = attr.match(QUERY_REG);
		if (!matched || !matched[1] || !matched[2]) return;
		var operator = matched[1];
		if (!compare(realMap[matched[2].toLowerCase()], value, operator)) applicable = false;
	});
	return applicable;
}
function compare(real, expect, operator) {
	if (operator === "min") return real >= expect;
	else if (operator === "max") return real <= expect;
	else return real === expect;
}
function indicesEquals(indices1, indices2) {
	return indices1.join(",") === indices2.join(",");
}
/**
* Consider case:
* `chart.setOption(opt1);`
* Then user do some interaction like dataZoom, dataView changing.
* `chart.setOption(opt2);`
* Then user press 'reset button' in toolbox.
*
* After doing that all of the interaction effects should be reset, the
* chart should be the same as the result of invoke
* `chart.setOption(opt1); chart.setOption(opt2);`.
*
* Although it is not able ensure that
* `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
* `chart.setOption(merge(opt1, opt2));` exactly,
* this might be the only simple way to implement that feature.
*
* MEMO: We've considered some other approaches:
* 1. Each model handles its self restoration but not uniform treatment.
*     (Too complex in logic and error-prone)
* 2. Use a shadow ecModel. (Performance expensive)
*
* FIXME: A possible solution:
* Add a extra level of model for each component model. The inheritance chain would be:
* ecModel <- componentModel <- componentActionModel <- dataItemModel
* And all of the actions can only modify the `componentActionModel` rather than
* `componentModel`. `setOption` will only modify the `ecModel` and `componentModel`.
* When "resotre" action triggered, model from `componentActionModel` will be discarded
* instead of recreating the "ecModel" from the "_optionBackup".
*/
var OptionManager_default = OptionManager;

//#endregion
//#region node_modules/echarts/lib/preprocessor/helper/compatStyle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var each$1 = each;
var isObject$2 = isObject$1;
var POSSIBLE_STYLES = [
	"areaStyle",
	"lineStyle",
	"nodeStyle",
	"linkStyle",
	"chordStyle",
	"label",
	"labelLine"
];
function compatEC2ItemStyle(opt) {
	var itemStyleOpt = opt && opt.itemStyle;
	if (!itemStyleOpt) return;
	for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
		var styleName = POSSIBLE_STYLES[i];
		var normalItemStyleOpt = itemStyleOpt.normal;
		var emphasisItemStyleOpt = itemStyleOpt.emphasis;
		if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
			deprecateReplaceLog("itemStyle.normal." + styleName, styleName);
			opt[styleName] = opt[styleName] || {};
			if (!opt[styleName].normal) opt[styleName].normal = normalItemStyleOpt[styleName];
			else merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
			normalItemStyleOpt[styleName] = null;
		}
		if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
			deprecateReplaceLog("itemStyle.emphasis." + styleName, "emphasis." + styleName);
			opt[styleName] = opt[styleName] || {};
			if (!opt[styleName].emphasis) opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
			else merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
			emphasisItemStyleOpt[styleName] = null;
		}
	}
}
function convertNormalEmphasis(opt, optType, useExtend) {
	if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
		var normalOpt = opt[optType].normal;
		var emphasisOpt = opt[optType].emphasis;
		if (normalOpt) {
			deprecateLog("'normal' hierarchy in " + optType + " has been removed since 4.0. All style properties are configured in " + optType + " directly now.");
			if (useExtend) {
				opt[optType].normal = opt[optType].emphasis = null;
				defaults(opt[optType], normalOpt);
			} else opt[optType] = normalOpt;
		}
		if (emphasisOpt) {
			deprecateLog(optType + ".emphasis has been changed to emphasis." + optType + " since 4.0");
			opt.emphasis = opt.emphasis || {};
			opt.emphasis[optType] = emphasisOpt;
			if (emphasisOpt.focus) opt.emphasis.focus = emphasisOpt.focus;
			if (emphasisOpt.blurScope) opt.emphasis.blurScope = emphasisOpt.blurScope;
		}
	}
}
function removeEC3NormalStatus(opt) {
	convertNormalEmphasis(opt, "itemStyle");
	convertNormalEmphasis(opt, "lineStyle");
	convertNormalEmphasis(opt, "areaStyle");
	convertNormalEmphasis(opt, "label");
	convertNormalEmphasis(opt, "labelLine");
	convertNormalEmphasis(opt, "upperLabel");
	convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
	var labelOptSingle = isObject$2(opt) && opt[propName];
	var textStyle = isObject$2(labelOptSingle) && labelOptSingle.textStyle;
	if (textStyle) {
		deprecateLog("textStyle hierarchy in " + propName + " has been removed since 4.0. All textStyle properties are configured in " + propName + " directly now.");
		for (var i = 0, len = TEXT_STYLE_OPTIONS.length; i < len; i++) {
			var textPropName = TEXT_STYLE_OPTIONS[i];
			if (textStyle.hasOwnProperty(textPropName)) labelOptSingle[textPropName] = textStyle[textPropName];
		}
	}
}
function compatEC3CommonStyles(opt) {
	if (opt) {
		removeEC3NormalStatus(opt);
		compatTextStyle(opt, "label");
		opt.emphasis && compatTextStyle(opt.emphasis, "label");
	}
}
function processSeries(seriesOpt) {
	if (!isObject$2(seriesOpt)) return;
	compatEC2ItemStyle(seriesOpt);
	removeEC3NormalStatus(seriesOpt);
	compatTextStyle(seriesOpt, "label");
	compatTextStyle(seriesOpt, "upperLabel");
	compatTextStyle(seriesOpt, "edgeLabel");
	if (seriesOpt.emphasis) {
		compatTextStyle(seriesOpt.emphasis, "label");
		compatTextStyle(seriesOpt.emphasis, "upperLabel");
		compatTextStyle(seriesOpt.emphasis, "edgeLabel");
	}
	var markPoint = seriesOpt.markPoint;
	if (markPoint) {
		compatEC2ItemStyle(markPoint);
		compatEC3CommonStyles(markPoint);
	}
	var markLine = seriesOpt.markLine;
	if (markLine) {
		compatEC2ItemStyle(markLine);
		compatEC3CommonStyles(markLine);
	}
	var markArea = seriesOpt.markArea;
	if (markArea) compatEC3CommonStyles(markArea);
	var data = seriesOpt.data;
	if (seriesOpt.type === "graph") {
		data = data || seriesOpt.nodes;
		var edgeData = seriesOpt.links || seriesOpt.edges;
		if (edgeData && !isTypedArray(edgeData)) for (var i = 0; i < edgeData.length; i++) compatEC3CommonStyles(edgeData[i]);
		each(seriesOpt.categories, function(opt) {
			removeEC3NormalStatus(opt);
		});
	}
	if (data && !isTypedArray(data)) for (var i = 0; i < data.length; i++) compatEC3CommonStyles(data[i]);
	markPoint = seriesOpt.markPoint;
	if (markPoint && markPoint.data) {
		var mpData = markPoint.data;
		for (var i = 0; i < mpData.length; i++) compatEC3CommonStyles(mpData[i]);
	}
	markLine = seriesOpt.markLine;
	if (markLine && markLine.data) {
		var mlData = markLine.data;
		for (var i = 0; i < mlData.length; i++) if (isArray(mlData[i])) {
			compatEC3CommonStyles(mlData[i][0]);
			compatEC3CommonStyles(mlData[i][1]);
		} else compatEC3CommonStyles(mlData[i]);
	}
	if (seriesOpt.type === "gauge") {
		compatTextStyle(seriesOpt, "axisLabel");
		compatTextStyle(seriesOpt, "title");
		compatTextStyle(seriesOpt, "detail");
	} else if (seriesOpt.type === "treemap") {
		convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
		each(seriesOpt.levels, function(opt) {
			removeEC3NormalStatus(opt);
		});
	} else if (seriesOpt.type === "tree") removeEC3NormalStatus(seriesOpt.leaves);
}
function toArr(o) {
	return isArray(o) ? o : o ? [o] : [];
}
function toObj(o) {
	return (isArray(o) ? o[0] : o) || {};
}
function globalCompatStyle(option, isTheme) {
	each$1(toArr(option.series), function(seriesOpt) {
		isObject$2(seriesOpt) && processSeries(seriesOpt);
	});
	var axes = [
		"xAxis",
		"yAxis",
		"radiusAxis",
		"angleAxis",
		"singleAxis",
		"parallelAxis",
		"radar"
	];
	isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
	each$1(axes, function(axisName) {
		each$1(toArr(option[axisName]), function(axisOpt) {
			if (axisOpt) {
				compatTextStyle(axisOpt, "axisLabel");
				compatTextStyle(axisOpt.axisPointer, "label");
			}
		});
	});
	each$1(toArr(option.parallel), function(parallelOpt) {
		var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
		compatTextStyle(parallelAxisDefault, "axisLabel");
		compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
	});
	each$1(toArr(option.calendar), function(calendarOpt) {
		convertNormalEmphasis(calendarOpt, "itemStyle");
		compatTextStyle(calendarOpt, "dayLabel");
		compatTextStyle(calendarOpt, "monthLabel");
		compatTextStyle(calendarOpt, "yearLabel");
	});
	each$1(toArr(option.radar), function(radarOpt) {
		compatTextStyle(radarOpt, "name");
		if (radarOpt.name && radarOpt.axisName == null) {
			radarOpt.axisName = radarOpt.name;
			delete radarOpt.name;
			deprecateLog("name property in radar component has been changed to axisName");
		}
		if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
			radarOpt.axisNameGap = radarOpt.nameGap;
			delete radarOpt.nameGap;
			deprecateLog("nameGap property in radar component has been changed to axisNameGap");
		}
		each$1(radarOpt.indicator, function(indicatorOpt) {
			if (indicatorOpt.text) deprecateReplaceLog("text", "name", "radar.indicator");
		});
	});
	each$1(toArr(option.geo), function(geoOpt) {
		if (isObject$2(geoOpt)) {
			compatEC3CommonStyles(geoOpt);
			each$1(toArr(geoOpt.regions), function(regionObj) {
				compatEC3CommonStyles(regionObj);
			});
		}
	});
	each$1(toArr(option.timeline), function(timelineOpt) {
		compatEC3CommonStyles(timelineOpt);
		convertNormalEmphasis(timelineOpt, "label");
		convertNormalEmphasis(timelineOpt, "itemStyle");
		convertNormalEmphasis(timelineOpt, "controlStyle", true);
		var data = timelineOpt.data;
		isArray(data) && each(data, function(item) {
			if (isObject$1(item)) {
				convertNormalEmphasis(item, "label");
				convertNormalEmphasis(item, "itemStyle");
			}
		});
	});
	each$1(toArr(option.toolbox), function(toolboxOpt) {
		convertNormalEmphasis(toolboxOpt, "iconStyle");
		each$1(toolboxOpt.feature, function(featureOpt) {
			convertNormalEmphasis(featureOpt, "iconStyle");
		});
	});
	compatTextStyle(toObj(option.axisPointer), "label");
	compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}

//#endregion
//#region node_modules/echarts/lib/preprocessor/backwardCompat.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function get(opt, path) {
	var pathArr = path.split(",");
	var obj = opt;
	for (var i = 0; i < pathArr.length; i++) {
		obj = obj && obj[pathArr[i]];
		if (obj == null) break;
	}
	return obj;
}
function set(opt, path, val, overwrite) {
	var pathArr = path.split(",");
	var obj = opt;
	var key$1;
	var i = 0;
	for (; i < pathArr.length - 1; i++) {
		key$1 = pathArr[i];
		if (obj[key$1] == null) obj[key$1] = {};
		obj = obj[key$1];
	}
	if (overwrite || obj[pathArr[i]] == null) obj[pathArr[i]] = val;
}
function compatLayoutProperties(option) {
	option && each(LAYOUT_PROPERTIES, function(prop) {
		if (prop[0] in option && !(prop[1] in option)) option[prop[1]] = option[prop[0]];
	});
}
var LAYOUT_PROPERTIES = [
	["x", "left"],
	["y", "top"],
	["x2", "right"],
	["y2", "bottom"]
];
var COMPATITABLE_COMPONENTS = [
	"grid",
	"geo",
	"parallel",
	"legend",
	"toolbox",
	"title",
	"visualMap",
	"dataZoom",
	"timeline"
];
var BAR_ITEM_STYLE_MAP = [
	["borderRadius", "barBorderRadius"],
	["borderColor", "barBorderColor"],
	["borderWidth", "barBorderWidth"]
];
function compatBarItemStyle(option) {
	var itemStyle = option && option.itemStyle;
	if (itemStyle) for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
		var oldName = BAR_ITEM_STYLE_MAP[i][1];
		var newName = BAR_ITEM_STYLE_MAP[i][0];
		if (itemStyle[oldName] != null) {
			itemStyle[newName] = itemStyle[oldName];
			deprecateReplaceLog(oldName, newName);
		}
	}
}
function compatPieLabel(option) {
	if (!option) return;
	if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
		deprecateReplaceLog("label.margin", "label.edgeDistance", "pie");
		option.edgeDistance = option.margin;
	}
}
function compatSunburstState(option) {
	if (!option) return;
	if (option.downplay && !option.blur) {
		option.blur = option.downplay;
		deprecateReplaceLog("downplay", "blur", "sunburst");
	}
}
function compatGraphFocus(option) {
	if (!option) return;
	if (option.focusNodeAdjacency != null) {
		option.emphasis = option.emphasis || {};
		if (option.emphasis.focus == null) {
			deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey");
			option.emphasis.focus = "adjacency";
		}
	}
}
function traverseTree(data, cb) {
	if (data) for (var i = 0; i < data.length; i++) {
		cb(data[i]);
		data[i] && traverseTree(data[i].children, cb);
	}
}
function globalBackwardCompat(option, isTheme) {
	globalCompatStyle(option, isTheme);
	option.series = normalizeToArray(option.series);
	each(option.series, function(seriesOpt) {
		if (!isObject$1(seriesOpt)) return;
		var seriesType$1 = seriesOpt.type;
		if (seriesType$1 === "line") {
			if (seriesOpt.clipOverflow != null) {
				seriesOpt.clip = seriesOpt.clipOverflow;
				deprecateReplaceLog("clipOverflow", "clip", "line");
			}
		} else if (seriesType$1 === "pie" || seriesType$1 === "gauge") {
			if (seriesOpt.clockWise != null) {
				seriesOpt.clockwise = seriesOpt.clockWise;
				deprecateReplaceLog("clockWise", "clockwise");
			}
			compatPieLabel(seriesOpt.label);
			var data = seriesOpt.data;
			if (data && !isTypedArray(data)) for (var i = 0; i < data.length; i++) compatPieLabel(data[i]);
			if (seriesOpt.hoverOffset != null) {
				seriesOpt.emphasis = seriesOpt.emphasis || {};
				if (seriesOpt.emphasis.scaleSize = null) {
					deprecateReplaceLog("hoverOffset", "emphasis.scaleSize");
					seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
				}
			}
		} else if (seriesType$1 === "gauge") {
			var pointerColor = get(seriesOpt, "pointer.color");
			pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
		} else if (seriesType$1 === "bar") {
			compatBarItemStyle(seriesOpt);
			compatBarItemStyle(seriesOpt.backgroundStyle);
			compatBarItemStyle(seriesOpt.emphasis);
			var data = seriesOpt.data;
			if (data && !isTypedArray(data)) {
				for (var i = 0; i < data.length; i++) if (typeof data[i] === "object") {
					compatBarItemStyle(data[i]);
					compatBarItemStyle(data[i] && data[i].emphasis);
				}
			}
		} else if (seriesType$1 === "sunburst") {
			var highlightPolicy = seriesOpt.highlightPolicy;
			if (highlightPolicy) {
				seriesOpt.emphasis = seriesOpt.emphasis || {};
				if (!seriesOpt.emphasis.focus) {
					seriesOpt.emphasis.focus = highlightPolicy;
					deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst");
				}
			}
			compatSunburstState(seriesOpt);
			traverseTree(seriesOpt.data, compatSunburstState);
		} else if (seriesType$1 === "graph" || seriesType$1 === "sankey") compatGraphFocus(seriesOpt);
		else if (seriesType$1 === "map") {
			if (seriesOpt.mapType && !seriesOpt.map) {
				deprecateReplaceLog("mapType", "map", "map");
				seriesOpt.map = seriesOpt.mapType;
			}
			if (seriesOpt.mapLocation) {
				deprecateLog("`mapLocation` is not used anymore.");
				defaults(seriesOpt, seriesOpt.mapLocation);
			}
		}
		if (seriesOpt.hoverAnimation != null) {
			seriesOpt.emphasis = seriesOpt.emphasis || {};
			if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
				deprecateReplaceLog("hoverAnimation", "emphasis.scale");
				seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
			}
		}
		compatLayoutProperties(seriesOpt);
	});
	if (option.dataRange) option.visualMap = option.dataRange;
	each(COMPATITABLE_COMPONENTS, function(componentName) {
		var options = option[componentName];
		if (options) {
			if (!isArray(options)) options = [options];
			each(options, function(option$1) {
				compatLayoutProperties(option$1);
			});
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/processor/dataStack.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function dataStack(ecModel) {
	var stackInfoMap = createHashMap();
	ecModel.eachSeries(function(seriesModel) {
		var stack = seriesModel.get("stack");
		if (stack) {
			var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
			var data = seriesModel.getData();
			var stackInfo = {
				stackResultDimension: data.getCalculationInfo("stackResultDimension"),
				stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
				stackedDimension: data.getCalculationInfo("stackedDimension"),
				stackedByDimension: data.getCalculationInfo("stackedByDimension"),
				isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
				data,
				seriesModel
			};
			if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) return;
			stackInfoList.push(stackInfo);
		}
	});
	stackInfoMap.each(function(stackInfoList) {
		if (stackInfoList.length === 0) return;
		if ((stackInfoList[0].seriesModel.get("stackOrder") || "seriesAsc") === "seriesDesc") stackInfoList.reverse();
		each(stackInfoList, function(stackInfo, index) {
			stackInfo.data.setCalculationInfo("stackedOnSeries", index > 0 ? stackInfoList[index - 1].seriesModel : null);
		});
		calculateStack(stackInfoList);
	});
}
function calculateStack(stackInfoList) {
	each(stackInfoList, function(targetStackInfo, idxInStack) {
		var resultVal = [];
		var resultNaN = [NaN, NaN];
		var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
		var targetData = targetStackInfo.data;
		var isStackedByIndex = targetStackInfo.isStackedByIndex;
		var stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
		targetData.modify(dims, function(v0, v1, dataIndex) {
			var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
			if (isNaN(sum)) return resultNaN;
			var byValue;
			var stackedDataRawIndex;
			if (isStackedByIndex) stackedDataRawIndex = targetData.getRawIndex(dataIndex);
			else byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
			var stackedOver = NaN;
			for (var j = idxInStack - 1; j >= 0; j--) {
				var stackInfo = stackInfoList[j];
				if (!isStackedByIndex) stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
				if (stackedDataRawIndex >= 0) {
					var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
					if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum >= 0 && val > 0 || stackStrategy === "samesign" && sum <= 0 && val < 0) {
						sum = addSafe(sum, val);
						stackedOver = val;
						break;
					}
				}
			}
			resultVal[0] = sum;
			resultVal[1] = stackedOver;
			return resultVal;
		});
	});
}

//#endregion
//#region node_modules/echarts/lib/data/helper/dataProvider.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var _a, _b, _c, _d;
var providerMethods;
var mountMethods;
/**
* If normal array used, mutable chunk size is supported.
* If typed array used, chunk size must be fixed.
*/
var DefaultDataProvider = function() {
	function DefaultDataProvider$1(sourceParam, dimSize) {
		var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
		this._source = source;
		var data = this._data = source.data;
		var sourceFormat = source.sourceFormat;
		var seriesLayoutBy = source.seriesLayoutBy;
		if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
			if (dimSize == null) throw new Error("Typed array data must specify dimension size");
			this._offset = 0;
			this._dimSize = dimSize;
			this._data = data;
		}
		var validator = rawSourceDataValidatorMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
		validator && validator(data, source.dimensionsDefine);
		mountMethods(this, data, source);
	}
	DefaultDataProvider$1.prototype.getSource = function() {
		return this._source;
	};
	DefaultDataProvider$1.prototype.count = function() {
		return 0;
	};
	DefaultDataProvider$1.prototype.getItem = function(idx, out$1) {};
	DefaultDataProvider$1.prototype.appendData = function(newData) {};
	DefaultDataProvider$1.prototype.clean = function() {};
	DefaultDataProvider$1.protoInitialize = function() {
		var proto = DefaultDataProvider$1.prototype;
		proto.pure = false;
		proto.persistent = true;
	}();
	DefaultDataProvider$1.internalField = function() {
		var _a$1;
		mountMethods = function(provider, data, source) {
			var sourceFormat = source.sourceFormat;
			var seriesLayoutBy = source.seriesLayoutBy;
			var startIndex = source.startIndex;
			var dimsDef = source.dimensionsDefine;
			var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
			assert(methods, "Invalide sourceFormat: " + sourceFormat);
			extend(provider, methods);
			if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
				provider.getItem = getItemForTypedArray;
				provider.count = countForTypedArray;
				provider.fillStorage = fillStorageForTypedArray;
			} else {
				provider.getItem = bind(getRawSourceItemGetter(sourceFormat, seriesLayoutBy), null, data, startIndex, dimsDef);
				provider.count = bind(getRawSourceDataCounter(sourceFormat, seriesLayoutBy), null, data, startIndex, dimsDef);
			}
		};
		var getItemForTypedArray = function(idx, out$1) {
			idx = idx - this._offset;
			out$1 = out$1 || [];
			var data = this._data;
			var dimSize = this._dimSize;
			var offset = dimSize * idx;
			for (var i = 0; i < dimSize; i++) out$1[i] = data[offset + i];
			return out$1;
		};
		var fillStorageForTypedArray = function(start, end, storage, extent) {
			var data = this._data;
			var dimSize = this._dimSize;
			for (var dim = 0; dim < dimSize; dim++) {
				var dimExtent = extent[dim];
				var min$1 = dimExtent[0] == null ? Infinity : dimExtent[0];
				var max$1 = dimExtent[1] == null ? -Infinity : dimExtent[1];
				var count = end - start;
				var arr = storage[dim];
				for (var i = 0; i < count; i++) {
					var val = data[i * dimSize + dim];
					arr[start + i] = val;
					val < min$1 && (min$1 = val);
					val > max$1 && (max$1 = val);
				}
				dimExtent[0] = min$1;
				dimExtent[1] = max$1;
			}
		};
		var countForTypedArray = function() {
			return this._data ? this._data.length / this._dimSize : 0;
		};
		providerMethods = (_a$1 = {}, _a$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
			pure: true,
			appendData: appendDataSimply
		}, _a$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
			pure: true,
			appendData: function() {
				throw new Error("Do not support appendData when set seriesLayoutBy: \"row\".");
			}
		}, _a$1[SOURCE_FORMAT_OBJECT_ROWS] = {
			pure: true,
			appendData: appendDataSimply
		}, _a$1[SOURCE_FORMAT_KEYED_COLUMNS] = {
			pure: true,
			appendData: function(newData) {
				var data = this._data;
				each(newData, function(newCol, key$1) {
					var oldCol = data[key$1] || (data[key$1] = []);
					for (var i = 0; i < (newCol || []).length; i++) oldCol.push(newCol[i]);
				});
			}
		}, _a$1[SOURCE_FORMAT_ORIGINAL] = { appendData: appendDataSimply }, _a$1[SOURCE_FORMAT_TYPED_ARRAY] = {
			persistent: false,
			pure: true,
			appendData: function(newData) {
				assert(isTypedArray(newData), "Added data must be TypedArray if data in initialization is TypedArray");
				this._data = newData;
			},
			clean: function() {
				this._offset += this.count();
				this._data = null;
			}
		}, _a$1);
		function appendDataSimply(newData) {
			for (var i = 0; i < newData.length; i++) this._data.push(newData[i]);
		}
	}();
	return DefaultDataProvider$1;
}();
var validateSimply = function(rawData) {
	if (!isArray(rawData)) error("series.data or dataset.source must be an array.");
};
/**
* Only run in dev mode - hint users for debug.
*/
var rawSourceDataValidatorMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = validateSimply, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = validateSimply, _a[SOURCE_FORMAT_OBJECT_ROWS] = validateSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, dimsDef) {
	for (var i = 0; i < dimsDef.length; i++) if (dimsDef[i].name == null) error("dimension name must not be null/undefined.");
}, _a[SOURCE_FORMAT_ORIGINAL] = validateSimply, _a);
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
	return rawData[idx];
};
var rawSourceItemGetterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
	return rawData[idx + startIndex];
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out$1) {
	idx += startIndex;
	var item = out$1 || [];
	var data = rawData;
	for (var i = 0; i < data.length; i++) {
		var row = data[i];
		item[i] = row ? row[idx] : null;
	}
	return item;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out$1) {
	var item = out$1 || [];
	for (var i = 0; i < dimsDef.length; i++) {
		var dimName = dimsDef[i].name;
		var col = dimName != null ? rawData[dimName] : null;
		item[i] = col ? col[idx] : null;
	}
	return item;
}, _b[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _b);
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
	var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
	assert(method, "Do not support get item on \"" + sourceFormat + "\", \"" + seriesLayoutBy + "\".");
	return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
	return rawData.length;
};
var rawSourceDataCounterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
	return Math.max(0, rawData.length - startIndex);
}, _c[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
	var row = rawData[0];
	return row ? Math.max(0, row.length - startIndex) : 0;
}, _c[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _c[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
	var dimName = dimsDef[0].name;
	var col = dimName != null ? rawData[dimName] : null;
	return col ? col.length : 0;
}, _c[SOURCE_FORMAT_ORIGINAL] = countSimply, _c);
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
	var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
	assert(method, "Do not support count on \"" + sourceFormat + "\", \"" + seriesLayoutBy + "\".");
	return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property) {
	return dataItem[dimIndex];
};
var rawSourceValueGetterMap = (_d = {}, _d[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _d[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property) {
	return dataItem[property];
}, _d[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _d[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property) {
	var value = getDataItemValue(dataItem);
	return !(value instanceof Array) ? value : value[dimIndex];
}, _d[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _d);
function getRawSourceValueGetter(sourceFormat) {
	var method = rawSourceValueGetterMap[sourceFormat];
	assert(method, "Do not support get value on \"" + sourceFormat + "\".");
	return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
	return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data, dataIndex, dim) {
	if (!data) return;
	var dataItem = data.getRawDataItem(dataIndex);
	if (dataItem == null) return;
	var store = data.getStore();
	var sourceFormat = store.getSource().sourceFormat;
	if (dim != null) {
		var dimIndex = data.getDimensionIndex(dim);
		var property = store.getDimensionProperty(dimIndex);
		return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
	} else {
		var result = dataItem;
		if (sourceFormat === SOURCE_FORMAT_ORIGINAL) result = getDataItemValue(dataItem);
		return result;
	}
}

//#endregion
//#region node_modules/echarts/lib/model/mixin/dataFormat.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = function() {
	function DataFormatMixin$1() {}
	/**
	* Get params for formatter
	*/
	DataFormatMixin$1.prototype.getDataParams = function(dataIndex, dataType) {
		var data = this.getData(dataType);
		var rawValue = this.getRawValue(dataIndex, dataType);
		var rawDataIndex = data.getRawIndex(dataIndex);
		var name = data.getName(dataIndex);
		var itemOpt = data.getRawDataItem(dataIndex);
		var style = data.getItemVisual(dataIndex, "style");
		var color$2 = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
		var borderColor = style && style.stroke;
		var mainType = this.mainType;
		var isSeries$1 = mainType === "series";
		var userOutput = data.userOutput && data.userOutput.get();
		return {
			componentType: mainType,
			componentSubType: this.subType,
			componentIndex: this.componentIndex,
			seriesType: isSeries$1 ? this.subType : null,
			seriesIndex: this.seriesIndex,
			seriesId: isSeries$1 ? this.id : null,
			seriesName: isSeries$1 ? this.name : null,
			name,
			dataIndex: rawDataIndex,
			data: itemOpt,
			dataType,
			value: rawValue,
			color: color$2,
			borderColor,
			dimensionNames: userOutput ? userOutput.fullDimensions : null,
			encode: userOutput ? userOutput.encode : null,
			$vars: [
				"seriesName",
				"name",
				"value"
			]
		};
	};
	/**
	* Format label
	* @param dataIndex
	* @param status 'normal' by default
	* @param dataType
	* @param labelDimIndex Only used in some chart that
	*        use formatter in different dimensions, like radar.
	* @param formatter Formatter given outside.
	* @return return null/undefined if no formatter
	*/
	DataFormatMixin$1.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
		status = status || "normal";
		var data = this.getData(dataType);
		var params = this.getDataParams(dataIndex, dataType);
		if (extendParams) params.value = extendParams.interpolatedValue;
		if (labelDimIndex != null && isArray(params.value)) params.value = params.value[labelDimIndex];
		if (!formatter) formatter = data.getItemModel(dataIndex).get(status === "normal" ? ["label", "formatter"] : [
			status,
			"label",
			"formatter"
		]);
		if (isFunction(formatter)) {
			params.status = status;
			params.dimensionIndex = labelDimIndex;
			return formatter(params);
		} else if (isString(formatter)) return formatTpl(formatter, params).replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
			var len = dimStr.length;
			var dimLoose = dimStr;
			if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len - 1) === "]") {
				dimLoose = +dimLoose.slice(1, len - 1);
				if (isNaN(dimLoose)) error("Invalide label formatter: @" + dimStr + ", only support @[0], @[1], @[2], ...");
			}
			var val = retrieveRawValue(data, dataIndex, dimLoose);
			if (extendParams && isArray(extendParams.interpolatedValue)) {
				var dimIndex = data.getDimensionIndex(dimLoose);
				if (dimIndex >= 0) val = extendParams.interpolatedValue[dimIndex];
			}
			return val != null ? val + "" : "";
		});
	};
	/**
	* Get raw value in option
	*/
	DataFormatMixin$1.prototype.getRawValue = function(idx, dataType) {
		return retrieveRawValue(this.getData(dataType), idx);
	};
	/**
	* Should be implemented.
	* @param {number} dataIndex
	* @param {boolean} [multipleSeries=false]
	* @param {string} [dataType]
	*/
	DataFormatMixin$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {};
	return DataFormatMixin$1;
}();
/**
* For backward compat, normalize the return from `formatTooltip`.
*/
function normalizeTooltipFormatResult(result) {
	var markupText;
	var markupFragment;
	if (isObject$1(result)) if (result.type) markupFragment = result;
	else console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(result));
	else markupText = result;
	return {
		text: markupText,
		frag: markupFragment
	};
}

//#endregion
//#region node_modules/echarts/lib/core/task.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* @param {Object} define
* @return See the return of `createTask`.
*/
function createTask(define) {
	return new Task(define);
}
var Task = function() {
	function Task$1(define) {
		define = define || {};
		this._reset = define.reset;
		this._plan = define.plan;
		this._count = define.count;
		this._onDirty = define.onDirty;
		this._dirty = true;
	}
	/**
	* @param step Specified step.
	* @param skip Skip customer perform call.
	* @param modBy Sampling window size.
	* @param modDataCount Sampling count.
	* @return whether unfinished.
	*/
	Task$1.prototype.perform = function(performArgs) {
		var upTask = this._upstream;
		var skip = performArgs && performArgs.skip;
		if (this._dirty && upTask) {
			var context = this.context;
			context.data = context.outputData = upTask.context.outputData;
		}
		if (this.__pipeline) this.__pipeline.currentTask = this;
		var planResult;
		if (this._plan && !skip) planResult = this._plan(this.context);
		var lastModBy = normalizeModBy(this._modBy);
		var lastModDataCount = this._modDataCount || 0;
		var modBy = normalizeModBy(performArgs && performArgs.modBy);
		var modDataCount = performArgs && performArgs.modDataCount || 0;
		if (lastModBy !== modBy || lastModDataCount !== modDataCount) planResult = "reset";
		function normalizeModBy(val) {
			!(val >= 1) && (val = 1);
			return val;
		}
		var forceFirstProgress;
		if (this._dirty || planResult === "reset") {
			this._dirty = false;
			forceFirstProgress = this._doReset(skip);
		}
		this._modBy = modBy;
		this._modDataCount = modDataCount;
		var step = performArgs && performArgs.step;
		if (upTask) {
			assert(upTask._outputDueEnd != null);
			this._dueEnd = upTask._outputDueEnd;
		} else {
			assert(!this._progress || this._count);
			this._dueEnd = this._count ? this._count(this.context) : Infinity;
		}
		if (this._progress) {
			var start = this._dueIndex;
			var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
			if (!skip && (forceFirstProgress || start < end)) {
				var progress = this._progress;
				if (isArray(progress)) for (var i = 0; i < progress.length; i++) this._doProgress(progress[i], start, end, modBy, modDataCount);
				else this._doProgress(progress, start, end, modBy, modDataCount);
			}
			this._dueIndex = end;
			var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;
			assert(outputDueEnd >= this._outputDueEnd);
			this._outputDueEnd = outputDueEnd;
		} else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
		return this.unfinished();
	};
	Task$1.prototype.dirty = function() {
		this._dirty = true;
		this._onDirty && this._onDirty(this.context);
	};
	Task$1.prototype._doProgress = function(progress, start, end, modBy, modDataCount) {
		iterator.reset(start, end, modBy, modDataCount);
		this._callingProgress = progress;
		this._callingProgress({
			start,
			end,
			count: end - start,
			next: iterator.next
		}, this.context);
	};
	Task$1.prototype._doReset = function(skip) {
		this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
		this._settedOutputEnd = null;
		var progress;
		var forceFirstProgress;
		if (!skip && this._reset) {
			progress = this._reset(this.context);
			if (progress && progress.progress) {
				forceFirstProgress = progress.forceFirstProgress;
				progress = progress.progress;
			}
			if (isArray(progress) && !progress.length) progress = null;
		}
		this._progress = progress;
		this._modBy = this._modDataCount = null;
		var downstream = this._downstream;
		downstream && downstream.dirty();
		return forceFirstProgress;
	};
	Task$1.prototype.unfinished = function() {
		return this._progress && this._dueIndex < this._dueEnd;
	};
	/**
	* @param downTask The downstream task.
	* @return The downstream task.
	*/
	Task$1.prototype.pipe = function(downTask) {
		assert(downTask && !downTask._disposed && downTask !== this);
		if (this._downstream !== downTask || this._dirty) {
			this._downstream = downTask;
			downTask._upstream = this;
			downTask.dirty();
		}
	};
	Task$1.prototype.dispose = function() {
		if (this._disposed) return;
		this._upstream && (this._upstream._downstream = null);
		this._downstream && (this._downstream._upstream = null);
		this._dirty = false;
		this._disposed = true;
	};
	Task$1.prototype.getUpstream = function() {
		return this._upstream;
	};
	Task$1.prototype.getDownstream = function() {
		return this._downstream;
	};
	Task$1.prototype.setOutputEnd = function(end) {
		this._outputDueEnd = this._settedOutputEnd = end;
	};
	return Task$1;
}();
var iterator = function() {
	var end;
	var current;
	var modBy;
	var modDataCount;
	var winCount;
	var it = { reset: function(s, e$1, sStep, sCount) {
		current = s;
		end = e$1;
		modBy = sStep;
		modDataCount = sCount;
		winCount = Math.ceil(modDataCount / modBy);
		it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
	} };
	return it;
	function sequentialNext() {
		return current < end ? current++ : null;
	}
	function modNext() {
		var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
		var result = current >= end ? null : dataIndex < modDataCount ? dataIndex : current;
		current++;
		return result;
	}
}();

//#endregion
//#region node_modules/echarts/lib/data/helper/dataValueHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Convert raw the value in to inner value in List.
*
* [Performance sensitive]
*
* [Caution]: this is the key logic of user value parser.
* For backward compatibility, do not modify it until you have to!
*/
function parseDataValue(value, opt) {
	var dimType = opt && opt.type;
	if (dimType === "ordinal") return value;
	if (dimType === "time" && !isNumber(value) && value != null && value !== "-") value = +parseDate(value);
	return value == null || value === "" ? NaN : Number(value);
}
var valueParserMap = createHashMap({
	"number": function(val) {
		return parseFloat(val);
	},
	"time": function(val) {
		return +parseDate(val);
	},
	"trim": function(val) {
		return isString(val) ? trim(val) : val;
	}
});
function getRawValueParser(type) {
	return valueParserMap.get(type);
}
var ORDER_COMPARISON_OP_MAP = {
	lt: function(lval, rval) {
		return lval < rval;
	},
	lte: function(lval, rval) {
		return lval <= rval;
	},
	gt: function(lval, rval) {
		return lval > rval;
	},
	gte: function(lval, rval) {
		return lval >= rval;
	}
};
var FilterOrderComparator = function() {
	function FilterOrderComparator$1(op, rval) {
		if (!isNumber(rval)) {
			var errMsg = "";
			errMsg = "rvalue of \"<\", \">\", \"<=\", \">=\" can only be number in filter.";
			throwError(errMsg);
		}
		this._opFn = ORDER_COMPARISON_OP_MAP[op];
		this._rvalFloat = numericToNumber(rval);
	}
	FilterOrderComparator$1.prototype.evaluate = function(lval) {
		return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
	};
	return FilterOrderComparator$1;
}();
var SortOrderComparator = function() {
	/**
	* @param order by default: 'asc'
	* @param incomparable by default: Always on the tail.
	*        That is, if 'asc' => 'max', if 'desc' => 'min'
	*        See the definition of "incomparable" in [SORT_COMPARISON_RULE].
	*/
	function SortOrderComparator$1(order, incomparable) {
		var isDesc = order === "desc";
		this._resultLT = isDesc ? 1 : -1;
		if (incomparable == null) incomparable = isDesc ? "min" : "max";
		this._incomparable = incomparable === "min" ? -Infinity : Infinity;
	}
	SortOrderComparator$1.prototype.evaluate = function(lval, rval) {
		var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
		var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
		var lvalNotNumeric = isNaN(lvalFloat);
		var rvalNotNumeric = isNaN(rvalFloat);
		if (lvalNotNumeric) lvalFloat = this._incomparable;
		if (rvalNotNumeric) rvalFloat = this._incomparable;
		if (lvalNotNumeric && rvalNotNumeric) {
			var lvalIsStr = isString(lval);
			var rvalIsStr = isString(rval);
			if (lvalIsStr) lvalFloat = rvalIsStr ? lval : 0;
			if (rvalIsStr) rvalFloat = lvalIsStr ? rval : 0;
		}
		return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
	};
	return SortOrderComparator$1;
}();
var FilterEqualityComparator = function() {
	function FilterEqualityComparator$1(isEq, rval) {
		this._rval = rval;
		this._isEQ = isEq;
		this._rvalTypeof = typeof rval;
		this._rvalFloat = numericToNumber(rval);
	}
	FilterEqualityComparator$1.prototype.evaluate = function(lval) {
		var eqResult = lval === this._rval;
		if (!eqResult) {
			var lvalTypeof = typeof lval;
			if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) eqResult = numericToNumber(lval) === this._rvalFloat;
		}
		return this._isEQ ? eqResult : !eqResult;
	};
	return FilterEqualityComparator$1;
}();
/**
* [FILTER_COMPARISON_RULE]
* `lt`|`lte`|`gt`|`gte`:
* + rval must be a number. And lval will be converted to number (`numericToNumber`) to compare.
* `eq`:
* + If same type, compare with `===`.
* + If there is one number, convert to number (`numericToNumber`) to compare.
* + Else return `false`.
* `ne`:
* + Not `eq`.
*
*
* [SORT_COMPARISON_RULE]
* All the values are grouped into three categories:
* + "numeric" (number and numeric string)
* + "non-numeric-string" (string that excluding numeric string)
* + "others"
* "numeric" vs "numeric": values are ordered by number order.
* "non-numeric-string" vs "non-numeric-string": values are ordered by ES spec (#sec-abstract-relational-comparison).
* "others" vs "others": do not change order (always return 0).
* "numeric" vs "non-numeric-string": "non-numeric-string" is treated as "incomparable".
* "number" vs "others": "others" is treated as "incomparable".
* "non-numeric-string" vs "others": "others" is treated as "incomparable".
* "incomparable" will be seen as -Infinity or Infinity (depends on the settings).
* MEMO:
*   Non-numeric string sort makes sense when we need to put the items with the same tag together.
*   But if we support string sort, we still need to avoid the misleading like `'2' > '12'`,
*   So we treat "numeric-string" sorted by number order rather than string comparison.
*
*
* [CHECK_LIST_OF_THE_RULE_DESIGN]
* + Do not support string comparison until required. And also need to
*   avoid the misleading of "2" > "12".
* + Should avoid the misleading case:
*   `" 22 " gte "22"` is `true` but `" 22 " eq "22"` is `false`.
* + JS bad case should be avoided: null <= 0, [] <= 0, ' ' <= 0, ...
* + Only "numeric" can be converted to comparable number, otherwise converted to NaN.
*   See `util/number.ts#numericToNumber`.
*
* @return If `op` is not `RelationalOperator`, return null;
*/
function createFilterComparator(op, rval) {
	return op === "eq" || op === "ne" ? new FilterEqualityComparator(op === "eq", rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
}

//#endregion
//#region node_modules/echarts/lib/data/helper/transform.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* TODO: disable writable.
* This structure will be exposed to users.
*/
var ExternalSource = function() {
	function ExternalSource$1() {}
	ExternalSource$1.prototype.getRawData = function() {
		throw new Error("not supported");
	};
	ExternalSource$1.prototype.getRawDataItem = function(dataIndex) {
		throw new Error("not supported");
	};
	ExternalSource$1.prototype.cloneRawData = function() {};
	/**
	* @return If dimension not found, return null/undefined.
	*/
	ExternalSource$1.prototype.getDimensionInfo = function(dim) {};
	/**
	* dimensions defined if and only if either:
	* (a) dataset.dimensions are declared.
	* (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).
	* If dimensions are defined, `dimensionInfoAll` is corresponding to
	* the defined dimensions.
	* Otherwise, `dimensionInfoAll` is determined by data columns.
	* @return Always return an array (even empty array).
	*/
	ExternalSource$1.prototype.cloneAllDimensionInfo = function() {};
	ExternalSource$1.prototype.count = function() {};
	/**
	* Only support by dimension index.
	* No need to support by dimension name in transform function,
	* because transform function is not case-specific, no need to use name literally.
	*/
	ExternalSource$1.prototype.retrieveValue = function(dataIndex, dimIndex) {};
	ExternalSource$1.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {};
	ExternalSource$1.prototype.convertValue = function(rawVal, dimInfo) {
		return parseDataValue(rawVal, dimInfo);
	};
	return ExternalSource$1;
}();
function createExternalSource(internalSource, externalTransform) {
	var extSource = new ExternalSource();
	var data = internalSource.data;
	var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
	var sourceHeaderCount = internalSource.startIndex;
	var errMsg = "";
	if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
		errMsg = "`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.";
		throwError(errMsg);
	}
	var dimensions = [];
	var dimsByName = {};
	var dimsDef = internalSource.dimensionsDefine;
	if (dimsDef) each(dimsDef, function(dimDef, idx) {
		var name = dimDef.name;
		var dimDefExt = {
			index: idx,
			name,
			displayName: dimDef.displayName
		};
		dimensions.push(dimDefExt);
		if (name != null) {
			var errMsg_1 = "";
			if (hasOwn(dimsByName, name)) {
				errMsg_1 = "dimension name \"" + name + "\" duplicated.";
				throwError(errMsg_1);
			}
			dimsByName[name] = dimDefExt;
		}
	});
	else for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) dimensions.push({ index: i });
	var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
	if (externalTransform.__isBuiltIn) {
		extSource.getRawDataItem = function(dataIndex) {
			return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
		};
		extSource.getRawData = bind(getRawData, null, internalSource);
	}
	extSource.cloneRawData = bind(cloneRawData, null, internalSource);
	extSource.count = bind(getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN), null, data, sourceHeaderCount, dimensions);
	var rawValueGetter = getRawSourceValueGetter(sourceFormat);
	extSource.retrieveValue = function(dataIndex, dimIndex) {
		return retrieveValueFromItem(rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex), dimIndex);
	};
	var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
		if (dataItem == null) return;
		var dimDef = dimensions[dimIndex];
		if (dimDef) return rawValueGetter(dataItem, dimIndex, dimDef.name);
	};
	extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);
	extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);
	return extSource;
}
function getRawData(upstream) {
	var sourceFormat = upstream.sourceFormat;
	if (!isSupportedSourceFormat(sourceFormat)) {
		var errMsg = "";
		errMsg = "`getRawData` is not supported in source format " + sourceFormat;
		throwError(errMsg);
	}
	return upstream.data;
}
function cloneRawData(upstream) {
	var sourceFormat = upstream.sourceFormat;
	var data = upstream.data;
	if (!isSupportedSourceFormat(sourceFormat)) {
		var errMsg = "";
		errMsg = "`cloneRawData` is not supported in source format " + sourceFormat;
		throwError(errMsg);
	}
	if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
		var result = [];
		for (var i = 0, len = data.length; i < len; i++) result.push(data[i].slice());
		return result;
	} else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
		var result = [];
		for (var i = 0, len = data.length; i < len; i++) result.push(extend({}, data[i]));
		return result;
	}
}
function getDimensionInfo(dimensions, dimsByName, dim) {
	if (dim == null) return;
	if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) return dimensions[dim];
	else if (hasOwn(dimsByName, dim)) return dimsByName[dim];
}
function cloneAllDimensionInfo(dimensions) {
	return clone(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
	externalTransform = clone(externalTransform);
	var type = externalTransform.type;
	var errMsg = "";
	if (!type) {
		errMsg = "Must have a `type` when `registerTransform`.";
		throwError(errMsg);
	}
	var typeParsed = type.split(":");
	if (typeParsed.length !== 2) {
		errMsg = "Name must include namespace like \"ns:regression\".";
		throwError(errMsg);
	}
	var isBuiltIn = false;
	if (typeParsed[0] === "echarts") {
		type = typeParsed[1];
		isBuiltIn = true;
	}
	externalTransform.__isBuiltIn = isBuiltIn;
	externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
	var pipedTransOption = normalizeToArray(rawTransOption);
	var pipeLen = pipedTransOption.length;
	var errMsg = "";
	if (!pipeLen) {
		errMsg = "If `transform` declared, it should at least contain one transform.";
		throwError(errMsg);
	}
	for (var i = 0, len = pipeLen; i < len; i++) {
		var transOption = pipedTransOption[i];
		sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);
		if (i !== len - 1) sourceList.length = Math.max(sourceList.length, 1);
	}
	return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
	var errMsg = "";
	if (!upSourceList.length) {
		errMsg = "Must have at least one upstream dataset.";
		throwError(errMsg);
	}
	if (!isObject$1(transOption)) {
		errMsg = "transform declaration must be an object rather than " + typeof transOption + ".";
		throwError(errMsg);
	}
	var transType = transOption.type;
	var externalTransform = externalTransformMap.get(transType);
	if (!externalTransform) {
		errMsg = "Can not find transform on type \"" + transType + "\".";
		throwError(errMsg);
	}
	var extUpSourceList = map$1(upSourceList, function(upSource) {
		return createExternalSource(upSource, externalTransform);
	});
	var resultList = normalizeToArray(externalTransform.transform({
		upstream: extUpSourceList[0],
		upstreamList: extUpSourceList,
		config: clone(transOption.config)
	}));
	if (transOption.print) log(map$1(resultList, function(extSource) {
		var pipeIndexStr = pipeIndex != null ? " === pipe index: " + pipeIndex : "";
		return [
			"=== dataset index: " + infoForPrint.datasetIndex + pipeIndexStr + " ===",
			"- transform result data:",
			makePrintable(extSource.data),
			"- transform result dimensions:",
			makePrintable(extSource.dimensions)
		].join("\n");
	}).join("\n"));
	return map$1(resultList, function(result, resultIndex) {
		var errMsg$1 = "";
		if (!isObject$1(result)) {
			errMsg$1 = "A transform should not return some empty results.";
			throwError(errMsg$1);
		}
		if (!result.data) {
			errMsg$1 = "Transform result data should be not be null or undefined";
			throwError(errMsg$1);
		}
		if (!isSupportedSourceFormat(detectSourceFormat(result.data))) {
			errMsg$1 = "Transform result data should be array rows or object rows.";
			throwError(errMsg$1);
		}
		var resultMetaRawOption;
		var firstUpSource = upSourceList[0];
		/**
		* Intuitively, the end users known the content of the original `dataset.source`,
		* calucating the transform result in mind.
		* Suppose the original `dataset.source` is:
		* ```js
		* [
		*     ['product', '2012', '2013', '2014', '2015'],
		*     ['AAA', 41.1, 30.4, 65.1, 53.3],
		*     ['BBB', 86.5, 92.1, 85.7, 83.1],
		*     ['CCC', 24.1, 67.2, 79.5, 86.4]
		* ]
		* ```
		* The dimension info have to be detected from the source data.
		* Some of the transformers (like filter, sort) will follow the dimension info
		* of upstream, while others use new dimensions (like aggregate).
		* Transformer can output a field `dimensions` to define the its own output dimensions.
		* We also allow transformers to ignore the output `dimensions` field, and
		* inherit the upstream dimensions definition. It can reduce the burden of handling
		* dimensions in transformers.
		*
		* See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.
		*/
		if (firstUpSource && resultIndex === 0 && !result.dimensions) {
			var startIndex = firstUpSource.startIndex;
			if (startIndex) result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
			resultMetaRawOption = {
				seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
				sourceHeader: startIndex,
				dimensions: firstUpSource.metaRawOption.dimensions
			};
		} else resultMetaRawOption = {
			seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
			sourceHeader: 0,
			dimensions: result.dimensions
		};
		return createSource(result.data, resultMetaRawOption, null);
	});
}
function isSupportedSourceFormat(sourceFormat) {
	return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}

//#endregion
//#region node_modules/echarts/lib/data/DataStore.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
/**
* Multi dimensional data store
*/
var dataCtors = {
	"float": CtorFloat64Array,
	"int": CtorInt32Array$1,
	"ordinal": Array,
	"number": Array,
	"time": CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
	return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
	return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
	var Ctor = originalChunk.constructor;
	return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end, append) {
	var DataCtor = dataCtors[dimType || "float"];
	if (append) {
		var oldStore = store[dimIdx];
		var oldLen = oldStore && oldStore.length;
		if (!(oldLen === end)) {
			var newStore = new DataCtor(end);
			for (var j = 0; j < oldLen; j++) newStore[j] = oldStore[j];
			store[dimIdx] = newStore;
		}
	} else store[dimIdx] = new DataCtor(end);
}
/**
* Basically, DataStore API keep immutable.
*/
var DataStore = function() {
	function DataStore$1() {
		this._chunks = [];
		this._rawExtent = [];
		this._extent = [];
		this._count = 0;
		this._rawCount = 0;
		this._calcDimNameToIdx = createHashMap();
	}
	/**
	* Initialize from data
	*/
	DataStore$1.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
		assert(isFunction(provider.getItem) && isFunction(provider.count), "Invalid data provider.");
		this._provider = provider;
		this._chunks = [];
		this._indices = null;
		this.getRawIndex = this._getRawIdxIdentity;
		var source = provider.getSource();
		var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
		this._dimValueGetter = dimValueGetter || defaultGetter;
		this._rawExtent = [];
		var willRetrieveDataByName = shouldRetrieveDataByName(source);
		this._dimensions = map$1(inputDimensions, function(dim) {
			if (willRetrieveDataByName) assert(dim.property != null);
			return {
				type: dim.type,
				property: dim.property
			};
		});
		this._initDataFromProvider(0, provider.count());
	};
	DataStore$1.prototype.getProvider = function() {
		return this._provider;
	};
	/**
	* Caution: even when a `source` instance owned by a series, the created data store
	* may still be shared by different sereis (the source hash does not use all `source`
	* props, see `sourceManager`). In this case, the `source` props that are not used in
	* hash (like `source.dimensionDefine`) probably only belongs to a certain series and
	* thus should not be fetch here.
	*/
	DataStore$1.prototype.getSource = function() {
		return this._provider.getSource();
	};
	/**
	* @caution Only used in dataStack.
	*/
	DataStore$1.prototype.ensureCalculationDimension = function(dimName, type) {
		var calcDimNameToIdx = this._calcDimNameToIdx;
		var dimensions = this._dimensions;
		var calcDimIdx = calcDimNameToIdx.get(dimName);
		if (calcDimIdx != null) {
			if (dimensions[calcDimIdx].type === type) return calcDimIdx;
		} else calcDimIdx = dimensions.length;
		dimensions[calcDimIdx] = { type };
		calcDimNameToIdx.set(dimName, calcDimIdx);
		this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
		this._rawExtent[calcDimIdx] = getInitialExtent();
		return calcDimIdx;
	};
	DataStore$1.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
		var chunk = this._chunks[dimIdx];
		var dim = this._dimensions[dimIdx];
		var rawExtents = this._rawExtent;
		var offset = dim.ordinalOffset || 0;
		var len = chunk.length;
		if (offset === 0) rawExtents[dimIdx] = getInitialExtent();
		var dimRawExtent = rawExtents[dimIdx];
		for (var i = offset; i < len; i++) {
			var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);
			if (!isNaN(val)) {
				dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
				dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
			}
		}
		dim.ordinalMeta = ordinalMeta;
		dim.ordinalOffset = len;
		dim.type = "ordinal";
	};
	DataStore$1.prototype.getOrdinalMeta = function(dimIdx) {
		return this._dimensions[dimIdx].ordinalMeta;
	};
	DataStore$1.prototype.getDimensionProperty = function(dimIndex) {
		var item = this._dimensions[dimIndex];
		return item && item.property;
	};
	/**
	* Caution: Can be only called on raw data (before `this._indices` created).
	*/
	DataStore$1.prototype.appendData = function(data) {
		assert(!this._indices, "appendData can only be called on raw data.");
		var provider = this._provider;
		var start = this.count();
		provider.appendData(data);
		var end = provider.count();
		if (!provider.persistent) end += start;
		if (start < end) this._initDataFromProvider(start, end, true);
		return [start, end];
	};
	DataStore$1.prototype.appendValues = function(values, minFillLen) {
		var chunks = this._chunks;
		var dimensions = this._dimensions;
		var dimLen = dimensions.length;
		var rawExtent = this._rawExtent;
		var start = this.count();
		var end = start + Math.max(values.length, minFillLen || 0);
		for (var i = 0; i < dimLen; i++) {
			var dim = dimensions[i];
			prepareStore(chunks, i, dim.type, end, true);
		}
		var emptyDataItem = [];
		for (var idx = start; idx < end; idx++) {
			var sourceIdx = idx - start;
			for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
				var dim = dimensions[dimIdx];
				var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
				chunks[dimIdx][idx] = val;
				var dimRawExtent = rawExtent[dimIdx];
				val < dimRawExtent[0] && (dimRawExtent[0] = val);
				val > dimRawExtent[1] && (dimRawExtent[1] = val);
			}
		}
		this._rawCount = this._count = end;
		return {
			start,
			end
		};
	};
	DataStore$1.prototype._initDataFromProvider = function(start, end, append) {
		var provider = this._provider;
		var chunks = this._chunks;
		var dimensions = this._dimensions;
		var dimLen = dimensions.length;
		var rawExtent = this._rawExtent;
		var dimNames = map$1(dimensions, function(dim$1) {
			return dim$1.property;
		});
		for (var i = 0; i < dimLen; i++) {
			var dim = dimensions[i];
			if (!rawExtent[i]) rawExtent[i] = getInitialExtent();
			prepareStore(chunks, i, dim.type, end, append);
		}
		if (provider.fillStorage) provider.fillStorage(start, end, chunks, rawExtent);
		else {
			var dataItem = [];
			for (var idx = start; idx < end; idx++) {
				dataItem = provider.getItem(idx, dataItem);
				for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
					var dimStorage = chunks[dimIdx];
					var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
					dimStorage[idx] = val;
					var dimRawExtent = rawExtent[dimIdx];
					val < dimRawExtent[0] && (dimRawExtent[0] = val);
					val > dimRawExtent[1] && (dimRawExtent[1] = val);
				}
			}
		}
		if (!provider.persistent && provider.clean) provider.clean();
		this._rawCount = this._count = end;
		this._extent = [];
	};
	DataStore$1.prototype.count = function() {
		return this._count;
	};
	/**
	* Get value. Return NaN if idx is out of range.
	*/
	DataStore$1.prototype.get = function(dim, idx) {
		if (!(idx >= 0 && idx < this._count)) return NaN;
		var dimStore = this._chunks[dim];
		return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
	};
	DataStore$1.prototype.getValues = function(dimensions, idx) {
		var values = [];
		var dimArr = [];
		if (idx == null) {
			idx = dimensions;
			dimensions = [];
			for (var i = 0; i < this._dimensions.length; i++) dimArr.push(i);
		} else dimArr = dimensions;
		for (var i = 0, len = dimArr.length; i < len; i++) values.push(this.get(dimArr[i], idx));
		return values;
	};
	/**
	* @param dim concrete dim
	*/
	DataStore$1.prototype.getByRawIndex = function(dim, rawIdx) {
		if (!(rawIdx >= 0 && rawIdx < this._rawCount)) return NaN;
		var dimStore = this._chunks[dim];
		return dimStore ? dimStore[rawIdx] : NaN;
	};
	/**
	* Get sum of data in one dimension
	*/
	DataStore$1.prototype.getSum = function(dim) {
		var dimData = this._chunks[dim];
		var sum = 0;
		if (dimData) for (var i = 0, len = this.count(); i < len; i++) {
			var value = this.get(dim, i);
			if (!isNaN(value)) sum += value;
		}
		return sum;
	};
	/**
	* Get median of data in one dimension
	*/
	DataStore$1.prototype.getMedian = function(dim) {
		var dimDataArray = [];
		this.each([dim], function(val) {
			if (!isNaN(val)) dimDataArray.push(val);
		});
		var sortedDimDataArray = dimDataArray.sort(function(a, b) {
			return a - b;
		});
		var len = this.count();
		return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
	};
	/**
	* Retrieve the index with given raw data index.
	*/
	DataStore$1.prototype.indexOfRawIndex = function(rawIndex) {
		if (rawIndex >= this._rawCount || rawIndex < 0) return -1;
		if (!this._indices) return rawIndex;
		var indices = this._indices;
		var rawDataIndex = indices[rawIndex];
		if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) return rawIndex;
		var left = 0;
		var right = this._count - 1;
		while (left <= right) {
			var mid = (left + right) / 2 | 0;
			if (indices[mid] < rawIndex) left = mid + 1;
			else if (indices[mid] > rawIndex) right = mid - 1;
			else return mid;
		}
		return -1;
	};
	DataStore$1.prototype.getIndices = function() {
		var newIndices;
		var indices = this._indices;
		if (indices) {
			var Ctor = indices.constructor;
			var thisCount = this._count;
			if (Ctor === Array) {
				newIndices = new Ctor(thisCount);
				for (var i = 0; i < thisCount; i++) newIndices[i] = indices[i];
			} else newIndices = new Ctor(indices.buffer, 0, thisCount);
		} else {
			var Ctor = getIndicesCtor(this._rawCount);
			newIndices = new Ctor(this.count());
			for (var i = 0; i < newIndices.length; i++) newIndices[i] = i;
		}
		return newIndices;
	};
	/**
	* Data filter.
	*/
	DataStore$1.prototype.filter = function(dims, cb) {
		if (!this._count) return this;
		var newStore = this.clone();
		var count = newStore.count();
		var newIndices = new (getIndicesCtor(newStore._rawCount))(count);
		var value = [];
		var dimSize = dims.length;
		var offset = 0;
		var dim0 = dims[0];
		var chunks = newStore._chunks;
		for (var i = 0; i < count; i++) {
			var keep = void 0;
			var rawIdx = newStore.getRawIndex(i);
			if (dimSize === 0) keep = cb(i);
			else if (dimSize === 1) {
				var val = chunks[dim0][rawIdx];
				keep = cb(val, i);
			} else {
				var k = 0;
				for (; k < dimSize; k++) value[k] = chunks[dims[k]][rawIdx];
				value[k] = i;
				keep = cb.apply(null, value);
			}
			if (keep) newIndices[offset++] = rawIdx;
		}
		if (offset < count) newStore._indices = newIndices;
		newStore._count = offset;
		newStore._extent = [];
		newStore._updateGetRawIdx();
		return newStore;
	};
	/**
	* Select data in range. (For optimization of filter)
	* (Manually inline code, support 5 million data filtering in data zoom.)
	*/
	DataStore$1.prototype.selectRange = function(range) {
		var newStore = this.clone();
		var len = newStore._count;
		if (!len) return this;
		var dims = keys(range);
		var dimSize = dims.length;
		if (!dimSize) return this;
		var originalCount = newStore.count();
		var newIndices = new (getIndicesCtor(newStore._rawCount))(originalCount);
		var offset = 0;
		var dim0 = dims[0];
		var min$1 = range[dim0][0];
		var max$1 = range[dim0][1];
		var storeArr = newStore._chunks;
		var quickFinished = false;
		if (!newStore._indices) {
			var idx = 0;
			if (dimSize === 1) {
				var dimStorage = storeArr[dims[0]];
				for (var i = 0; i < len; i++) {
					var val = dimStorage[i];
					if (val >= min$1 && val <= max$1 || isNaN(val)) newIndices[offset++] = idx;
					idx++;
				}
				quickFinished = true;
			} else if (dimSize === 2) {
				var dimStorage = storeArr[dims[0]];
				var dimStorage2 = storeArr[dims[1]];
				var min2 = range[dims[1]][0];
				var max2 = range[dims[1]][1];
				for (var i = 0; i < len; i++) {
					var val = dimStorage[i];
					var val2 = dimStorage2[i];
					if ((val >= min$1 && val <= max$1 || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) newIndices[offset++] = idx;
					idx++;
				}
				quickFinished = true;
			}
		}
		if (!quickFinished) if (dimSize === 1) for (var i = 0; i < originalCount; i++) {
			var rawIndex = newStore.getRawIndex(i);
			var val = storeArr[dims[0]][rawIndex];
			if (val >= min$1 && val <= max$1 || isNaN(val)) newIndices[offset++] = rawIndex;
		}
		else for (var i = 0; i < originalCount; i++) {
			var keep = true;
			var rawIndex = newStore.getRawIndex(i);
			for (var k = 0; k < dimSize; k++) {
				var dimk = dims[k];
				var val = storeArr[dimk][rawIndex];
				if (val < range[dimk][0] || val > range[dimk][1]) keep = false;
			}
			if (keep) newIndices[offset++] = newStore.getRawIndex(i);
		}
		if (offset < originalCount) newStore._indices = newIndices;
		newStore._count = offset;
		newStore._extent = [];
		newStore._updateGetRawIdx();
		return newStore;
	};
	/**
	* Data mapping to a new List with given dimensions
	*/
	DataStore$1.prototype.map = function(dims, cb) {
		var target = this.clone(dims);
		this._updateDims(target, dims, cb);
		return target;
	};
	/**
	* @caution Danger!! Only used in dataStack.
	*/
	DataStore$1.prototype.modify = function(dims, cb) {
		this._updateDims(this, dims, cb);
	};
	DataStore$1.prototype._updateDims = function(target, dims, cb) {
		var targetChunks = target._chunks;
		var tmpRetValue = [];
		var dimSize = dims.length;
		var dataCount = target.count();
		var values = [];
		var rawExtent = target._rawExtent;
		for (var i = 0; i < dims.length; i++) rawExtent[dims[i]] = getInitialExtent();
		for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
			var rawIndex = target.getRawIndex(dataIndex);
			for (var k = 0; k < dimSize; k++) values[k] = targetChunks[dims[k]][rawIndex];
			values[dimSize] = dataIndex;
			var retValue = cb && cb.apply(null, values);
			if (retValue != null) {
				if (typeof retValue !== "object") {
					tmpRetValue[0] = retValue;
					retValue = tmpRetValue;
				}
				for (var i = 0; i < retValue.length; i++) {
					var dim = dims[i];
					var val = retValue[i];
					var rawExtentOnDim = rawExtent[dim];
					var dimStore = targetChunks[dim];
					if (dimStore) dimStore[rawIndex] = val;
					if (val < rawExtentOnDim[0]) rawExtentOnDim[0] = val;
					if (val > rawExtentOnDim[1]) rawExtentOnDim[1] = val;
				}
			}
		}
	};
	/**
	* Large data down sampling using largest-triangle-three-buckets
	* @param {string} valueDimension
	* @param {number} targetCount
	*/
	DataStore$1.prototype.lttbDownSample = function(valueDimension, rate) {
		var target = this.clone([valueDimension], true);
		var dimStore = target._chunks[valueDimension];
		var len = this.count();
		var sampledIndex = 0;
		var frameSize = Math.floor(1 / rate);
		var currentRawIndex = this.getRawIndex(0);
		var maxArea;
		var area;
		var nextRawIndex;
		var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len));
		newIndices[sampledIndex++] = currentRawIndex;
		for (var i = 1; i < len - 1; i += frameSize) {
			var nextFrameStart = Math.min(i + frameSize, len - 1);
			var nextFrameEnd = Math.min(i + frameSize * 2, len);
			var avgX = (nextFrameEnd + nextFrameStart) / 2;
			var avgY = 0;
			for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
				var rawIndex = this.getRawIndex(idx);
				var y = dimStore[rawIndex];
				if (isNaN(y)) continue;
				avgY += y;
			}
			avgY /= nextFrameEnd - nextFrameStart;
			var frameStart = i;
			var frameEnd = Math.min(i + frameSize, len);
			var pointAX = i - 1;
			var pointAY = dimStore[currentRawIndex];
			maxArea = -1;
			nextRawIndex = frameStart;
			var firstNaNIndex = -1;
			var countNaN = 0;
			for (var idx = frameStart; idx < frameEnd; idx++) {
				var rawIndex = this.getRawIndex(idx);
				var y = dimStore[rawIndex];
				if (isNaN(y)) {
					countNaN++;
					if (firstNaNIndex < 0) firstNaNIndex = rawIndex;
					continue;
				}
				area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
				if (area > maxArea) {
					maxArea = area;
					nextRawIndex = rawIndex;
				}
			}
			if (countNaN > 0 && countNaN < frameEnd - frameStart) {
				newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
				nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
			}
			newIndices[sampledIndex++] = nextRawIndex;
			currentRawIndex = nextRawIndex;
		}
		newIndices[sampledIndex++] = this.getRawIndex(len - 1);
		target._count = sampledIndex;
		target._indices = newIndices;
		target.getRawIndex = this._getRawIdx;
		return target;
	};
	/**
	* Large data down sampling using min-max
	* @param {string} valueDimension
	* @param {number} rate
	*/
	DataStore$1.prototype.minmaxDownSample = function(valueDimension, rate) {
		var target = this.clone([valueDimension], true);
		var targetStorage = target._chunks;
		var frameSize = Math.floor(1 / rate);
		var dimStore = targetStorage[valueDimension];
		var len = this.count();
		var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize) * 2);
		var offset = 0;
		for (var i = 0; i < len; i += frameSize) {
			var minIndex = i;
			var minValue = dimStore[this.getRawIndex(minIndex)];
			var maxIndex = i;
			var maxValue = dimStore[this.getRawIndex(maxIndex)];
			var thisFrameSize = frameSize;
			if (i + frameSize > len) thisFrameSize = len - i;
			for (var k = 0; k < thisFrameSize; k++) {
				var value = dimStore[this.getRawIndex(i + k)];
				if (value < minValue) {
					minValue = value;
					minIndex = i + k;
				}
				if (value > maxValue) {
					maxValue = value;
					maxIndex = i + k;
				}
			}
			var rawMinIndex = this.getRawIndex(minIndex);
			var rawMaxIndex = this.getRawIndex(maxIndex);
			if (minIndex < maxIndex) {
				newIndices[offset++] = rawMinIndex;
				newIndices[offset++] = rawMaxIndex;
			} else {
				newIndices[offset++] = rawMaxIndex;
				newIndices[offset++] = rawMinIndex;
			}
		}
		target._count = offset;
		target._indices = newIndices;
		target._updateGetRawIdx();
		return target;
	};
	/**
	* Large data down sampling on given dimension
	* @param sampleIndex Sample index for name and id
	*/
	DataStore$1.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
		var target = this.clone([dimension], true);
		var targetStorage = target._chunks;
		var frameValues = [];
		var frameSize = Math.floor(1 / rate);
		var dimStore = targetStorage[dimension];
		var len = this.count();
		var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
		var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));
		var offset = 0;
		for (var i = 0; i < len; i += frameSize) {
			if (frameSize > len - i) {
				frameSize = len - i;
				frameValues.length = frameSize;
			}
			for (var k = 0; k < frameSize; k++) frameValues[k] = dimStore[this.getRawIndex(i + k)];
			var value = sampleValue(frameValues);
			var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));
			dimStore[sampleFrameIdx] = value;
			if (value < rawExtentOnDim[0]) rawExtentOnDim[0] = value;
			if (value > rawExtentOnDim[1]) rawExtentOnDim[1] = value;
			newIndices[offset++] = sampleFrameIdx;
		}
		target._count = offset;
		target._indices = newIndices;
		target._updateGetRawIdx();
		return target;
	};
	/**
	* Data iteration
	* @param ctx default this
	* @example
	*  list.each('x', function (x, idx) {});
	*  list.each(['x', 'y'], function (x, y, idx) {});
	*  list.each(function (idx) {})
	*/
	DataStore$1.prototype.each = function(dims, cb) {
		if (!this._count) return;
		var dimSize = dims.length;
		var chunks = this._chunks;
		for (var i = 0, len = this.count(); i < len; i++) {
			var rawIdx = this.getRawIndex(i);
			switch (dimSize) {
				case 0:
					cb(i);
					break;
				case 1:
					cb(chunks[dims[0]][rawIdx], i);
					break;
				case 2:
					cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
					break;
				default:
					var k = 0;
					var value = [];
					for (; k < dimSize; k++) value[k] = chunks[dims[k]][rawIdx];
					value[k] = i;
					cb.apply(null, value);
			}
		}
	};
	/**
	* Get extent of data in one dimension
	*/
	DataStore$1.prototype.getDataExtent = function(dim) {
		var dimData = this._chunks[dim];
		var initialExtent = getInitialExtent();
		if (!dimData) return initialExtent;
		var currEnd = this.count();
		var useRaw = !this._indices;
		var dimExtent;
		if (useRaw) return this._rawExtent[dim].slice();
		dimExtent = this._extent[dim];
		if (dimExtent) return dimExtent.slice();
		dimExtent = initialExtent;
		var min$1 = dimExtent[0];
		var max$1 = dimExtent[1];
		for (var i = 0; i < currEnd; i++) {
			var value = dimData[this.getRawIndex(i)];
			value < min$1 && (min$1 = value);
			value > max$1 && (max$1 = value);
		}
		dimExtent = [min$1, max$1];
		this._extent[dim] = dimExtent;
		return dimExtent;
	};
	/**
	* Get raw data item
	*/
	DataStore$1.prototype.getRawDataItem = function(idx) {
		var rawIdx = this.getRawIndex(idx);
		if (!this._provider.persistent) {
			var val = [];
			var chunks = this._chunks;
			for (var i = 0; i < chunks.length; i++) val.push(chunks[i][rawIdx]);
			return val;
		} else return this._provider.getItem(rawIdx);
	};
	/**
	* Clone shallow.
	*
	* @param clonedDims Determine which dims to clone. Will share the data if not specified.
	*/
	DataStore$1.prototype.clone = function(clonedDims, ignoreIndices) {
		var target = new DataStore$1();
		var chunks = this._chunks;
		var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj, dimIdx) {
			obj[dimIdx] = true;
			return obj;
		}, {});
		if (clonedDimsMap) for (var i = 0; i < chunks.length; i++) target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
		else target._chunks = chunks;
		this._copyCommonProps(target);
		if (!ignoreIndices) target._indices = this._cloneIndices();
		target._updateGetRawIdx();
		return target;
	};
	DataStore$1.prototype._copyCommonProps = function(target) {
		target._count = this._count;
		target._rawCount = this._rawCount;
		target._provider = this._provider;
		target._dimensions = this._dimensions;
		target._extent = clone(this._extent);
		target._rawExtent = clone(this._rawExtent);
	};
	DataStore$1.prototype._cloneIndices = function() {
		if (this._indices) {
			var Ctor = this._indices.constructor;
			var indices = void 0;
			if (Ctor === Array) {
				var thisCount = this._indices.length;
				indices = new Ctor(thisCount);
				for (var i = 0; i < thisCount; i++) indices[i] = this._indices[i];
			} else indices = new Ctor(this._indices);
			return indices;
		}
		return null;
	};
	DataStore$1.prototype._getRawIdxIdentity = function(idx) {
		return idx;
	};
	DataStore$1.prototype._getRawIdx = function(idx) {
		if (idx < this._count && idx >= 0) return this._indices[idx];
		return -1;
	};
	DataStore$1.prototype._updateGetRawIdx = function() {
		this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
	};
	DataStore$1.internalField = function() {
		function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
			return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
		}
		defaultDimValueGetters = {
			arrayRows: getDimValueSimply,
			objectRows: function(dataItem, property, dataIndex, dimIndex) {
				return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
			},
			keyedColumns: getDimValueSimply,
			original: function(dataItem, property, dataIndex, dimIndex) {
				var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
				return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
			},
			typedArray: function(dataItem, property, dataIndex, dimIndex) {
				return dataItem[dimIndex];
			}
		};
	}();
	return DataStore$1;
}();
var DataStore_default = DataStore;

//#endregion
//#region node_modules/echarts/lib/data/helper/sourceManager.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* [REQUIREMENT_MEMO]:
* (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.
* (1) Keep support the feature: `metaRawOption` can be specified both on `series` and
* `root-dataset`. Them on `series` has higher priority.
* (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might
* confuse users: whether those props indicate how to visit the upstream source or visit
* the transform result source, and some transforms has nothing to do with these props,
* and some transforms might have multiple upstream.
* (3) Transforms should specify `metaRawOption` in each output, just like they can be
* declared in `root-dataset`.
* (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.
* That is for reducing complexity in transforms.
* PENDING: Whether to provide transposition transform?
*
* [IMPLEMENTAION_MEMO]:
* "sourceVisitConfig" are calculated from `metaRawOption` and `data`.
* They will not be calculated until `source` is about to be visited (to prevent from
* duplicate calcuation). `source` is visited only in series and input to transforms.
*
* [DIMENSION_INHERIT_RULE]:
* By default the dimensions are inherited from ancestors, unless a transform return
* a new dimensions definition.
* Consider the case:
* ```js
* dataset: [{
*     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]
* }, {
*     transform: { type: 'filter', ... }
* }]
* dataset: [{
*     dimension: ['Product', 'Sales', 'Prise'],
*     source: [ ['Cookies', 321, 44.21], ...]
* }, {
*     transform: { type: 'filter', ... }
* }]
* ```
* The two types of option should have the same behavior after transform.
*
*
* [SCENARIO]:
* (1) Provide source data directly:
* ```js
* series: {
*     encode: {...},
*     dimensions: [...]
*     seriesLayoutBy: 'row',
*     data: [[...]]
* }
* ```
* (2) Series refer to dataset.
* ```js
* series: [{
*     encode: {...}
*     // Ignore datasetIndex means `datasetIndex: 0`
*     // and the dimensions defination in dataset is used
* }, {
*     encode: {...},
*     seriesLayoutBy: 'column',
*     datasetIndex: 1
* }]
* ```
* (3) dataset transform
* ```js
* dataset: [{
*     source: [...]
* }, {
*     source: [...]
* }, {
*     // By default from 0.
*     transform: { type: 'filter', config: {...} }
* }, {
*     // Piped.
*     transform: [
*         { type: 'filter', config: {...} },
*         { type: 'sort', config: {...} }
*     ]
* }, {
*     id: 'regressionData',
*     fromDatasetIndex: 1,
*     // Third-party transform
*     transform: { type: 'ecStat:regression', config: {...} }
* }, {
*     // retrieve the extra result.
*     id: 'regressionFormula',
*     fromDatasetId: 'regressionData',
*     fromTransformResult: 1
* }]
* ```
*/
var SourceManager = function() {
	function SourceManager$1(sourceHost) {
		this._sourceList = [];
		this._storeList = [];
		this._upstreamSignList = [];
		this._versionSignBase = 0;
		this._dirty = true;
		this._sourceHost = sourceHost;
	}
	/**
	* Mark dirty.
	*/
	SourceManager$1.prototype.dirty = function() {
		this._setLocalSource([], []);
		this._storeList = [];
		this._dirty = true;
	};
	SourceManager$1.prototype._setLocalSource = function(sourceList, upstreamSignList) {
		this._sourceList = sourceList;
		this._upstreamSignList = upstreamSignList;
		this._versionSignBase++;
		if (this._versionSignBase > 9e10) this._versionSignBase = 0;
	};
	/**
	* For detecting whether the upstream source is dirty, so that
	* the local cached source (in `_sourceList`) should be discarded.
	*/
	SourceManager$1.prototype._getVersionSign = function() {
		return this._sourceHost.uid + "_" + this._versionSignBase;
	};
	/**
	* Always return a source instance. Otherwise throw error.
	*/
	SourceManager$1.prototype.prepareSource = function() {
		if (this._isDirty()) {
			this._createSource();
			this._dirty = false;
		}
	};
	SourceManager$1.prototype._createSource = function() {
		this._setLocalSource([], []);
		var sourceHost = this._sourceHost;
		var upSourceMgrList = this._getUpstreamSourceManagers();
		var hasUpstream = !!upSourceMgrList.length;
		var resultSourceList;
		var upstreamSignList;
		if (isSeries(sourceHost)) {
			var seriesModel = sourceHost;
			var data = void 0;
			var sourceFormat = void 0;
			var upSource = void 0;
			if (hasUpstream) {
				var upSourceMgr = upSourceMgrList[0];
				upSourceMgr.prepareSource();
				upSource = upSourceMgr.getSource();
				data = upSource.data;
				sourceFormat = upSource.sourceFormat;
				upstreamSignList = [upSourceMgr._getVersionSign()];
			} else {
				data = seriesModel.get("data", true);
				sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
				upstreamSignList = [];
			}
			var newMetaRawOption = this._getSourceMetaRawOption() || {};
			var upMetaRawOption = upSource && upSource.metaRawOption || {};
			var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
			var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
			var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
			resultSourceList = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions ? [createSource(data, {
				seriesLayoutBy,
				sourceHeader,
				dimensions
			}, sourceFormat)] : [];
		} else {
			var datasetModel = sourceHost;
			if (hasUpstream) {
				var result = this._applyTransform(upSourceMgrList);
				resultSourceList = result.sourceList;
				upstreamSignList = result.upstreamSignList;
			} else {
				resultSourceList = [createSource(datasetModel.get("source", true), this._getSourceMetaRawOption(), null)];
				upstreamSignList = [];
			}
		}
		assert(resultSourceList && upstreamSignList);
		this._setLocalSource(resultSourceList, upstreamSignList);
	};
	SourceManager$1.prototype._applyTransform = function(upMgrList) {
		var datasetModel = this._sourceHost;
		var transformOption = datasetModel.get("transform", true);
		var fromTransformResult = datasetModel.get("fromTransformResult", true);
		assert(fromTransformResult != null || transformOption != null);
		if (fromTransformResult != null) {
			var errMsg = "";
			if (upMgrList.length !== 1) {
				errMsg = "When using `fromTransformResult`, there should be only one upstream dataset";
				doThrow(errMsg);
			}
		}
		var sourceList;
		var upSourceList = [];
		var upstreamSignList = [];
		each(upMgrList, function(upMgr) {
			upMgr.prepareSource();
			var upSource = upMgr.getSource(fromTransformResult || 0);
			var errMsg$1 = "";
			if (fromTransformResult != null && !upSource) {
				errMsg$1 = "Can not retrieve result by `fromTransformResult`: " + fromTransformResult;
				doThrow(errMsg$1);
			}
			upSourceList.push(upSource);
			upstreamSignList.push(upMgr._getVersionSign());
		});
		if (transformOption) sourceList = applyDataTransform(transformOption, upSourceList, { datasetIndex: datasetModel.componentIndex });
		else if (fromTransformResult != null) sourceList = [cloneSourceShallow(upSourceList[0])];
		return {
			sourceList,
			upstreamSignList
		};
	};
	SourceManager$1.prototype._isDirty = function() {
		if (this._dirty) return true;
		var upSourceMgrList = this._getUpstreamSourceManagers();
		for (var i = 0; i < upSourceMgrList.length; i++) {
			var upSrcMgr = upSourceMgrList[i];
			if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) return true;
		}
	};
	/**
	* @param sourceIndex By default 0, means "main source".
	*                    In most cases there is only one source.
	*/
	SourceManager$1.prototype.getSource = function(sourceIndex) {
		sourceIndex = sourceIndex || 0;
		var source = this._sourceList[sourceIndex];
		if (!source) {
			var upSourceMgrList = this._getUpstreamSourceManagers();
			return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
		}
		return source;
	};
	/**
	*
	* Get a data store which can be shared across series.
	* Only available for series.
	*
	* @param seriesDimRequest Dimensions that are generated in series.
	*        Should have been sorted by `storeDimIndex` asc.
	*/
	SourceManager$1.prototype.getSharedDataStore = function(seriesDimRequest) {
		assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
		var schema = seriesDimRequest.makeStoreSchema();
		return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
	};
	SourceManager$1.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
		var sourceIndex = 0;
		var storeList = this._storeList;
		var cachedStoreMap = storeList[sourceIndex];
		if (!cachedStoreMap) cachedStoreMap = storeList[sourceIndex] = {};
		var cachedStore = cachedStoreMap[sourceReadKey];
		if (!cachedStore) {
			var upSourceMgr = this._getUpstreamSourceManagers()[0];
			if (isSeries(this._sourceHost) && upSourceMgr) cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
			else {
				cachedStore = new DataStore_default();
				cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
			}
			cachedStoreMap[sourceReadKey] = cachedStore;
		}
		return cachedStore;
	};
	/**
	* PENDING: Is it fast enough?
	* If no upstream, return empty array.
	*/
	SourceManager$1.prototype._getUpstreamSourceManagers = function() {
		var sourceHost = this._sourceHost;
		if (isSeries(sourceHost)) {
			var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
			return !datasetModel ? [] : [datasetModel.getSourceManager()];
		} else return map$1(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel$1) {
			return datasetModel$1.getSourceManager();
		});
	};
	SourceManager$1.prototype._getSourceMetaRawOption = function() {
		var sourceHost = this._sourceHost;
		var seriesLayoutBy;
		var sourceHeader;
		var dimensions;
		if (isSeries(sourceHost)) {
			seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
			sourceHeader = sourceHost.get("sourceHeader", true);
			dimensions = sourceHost.get("dimensions", true);
		} else if (!this._getUpstreamSourceManagers().length) {
			var model = sourceHost;
			seriesLayoutBy = model.get("seriesLayoutBy", true);
			sourceHeader = model.get("sourceHeader", true);
			dimensions = model.get("dimensions", true);
		}
		return {
			seriesLayoutBy,
			sourceHeader,
			dimensions
		};
	};
	return SourceManager$1;
}();
function disableTransformOptionMerge(datasetModel) {
	datasetModel.option.transform && setAsPrimitive(datasetModel.option.transform);
}
function isSeries(sourceHost) {
	return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
	throw new Error(errMsg);
}

//#endregion
//#region node_modules/echarts/lib/component/tooltip/tooltipMarkup.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipLineHeight(textStyle) {
	var lineHeight = textStyle.lineHeight;
	if (lineHeight == null) return TOOLTIP_LINE_HEIGHT_CSS;
	else return "line-height:" + encodeHTML(lineHeight + "") + "px";
}
function getTooltipTextStyle(textStyle, renderMode) {
	var nameFontColor = textStyle.color || tokens_default.color.tertiary;
	var nameFontSize = textStyle.fontSize || 12;
	var nameFontWeight = textStyle.fontWeight || "400";
	var valueFontColor = textStyle.color || tokens_default.color.secondary;
	var valueFontSize = textStyle.fontSize || 14;
	var valueFontWeight = textStyle.fontWeight || "900";
	if (renderMode === "html") return {
		nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
		valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
	};
	else return {
		nameStyle: {
			fontSize: nameFontSize,
			fill: nameFontColor,
			fontWeight: nameFontWeight
		},
		valueStyle: {
			fontSize: valueFontSize,
			fill: valueFontColor,
			fontWeight: valueFontWeight
		}
	};
}
var HTML_GAPS = [
	0,
	10,
	20,
	30
];
var RICH_TEXT_GAPS = [
	"",
	"\n",
	"\n\n",
	"\n\n\n"
];
function createTooltipMarkup(type, option) {
	option.type = type;
	return option;
}
function isSectionFragment(frag) {
	return frag.type === "section";
}
function getBuilder(frag) {
	return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
	if (isSectionFragment(frag)) {
		var gapLevel_1 = 0;
		var subBlockLen = frag.blocks.length;
		var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
		each(frag.blocks, function(subBlock) {
			var subGapLevel = getBlockGapLevel(subBlock);
			if (subGapLevel >= gapLevel_1) gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
		});
		return gapLevel_1;
	}
	return 0;
}
function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
	var noHeader = fragment.noHeader;
	var gaps = getGap(getBlockGapLevel(fragment));
	var subMarkupTextList = [];
	var subBlocks = fragment.blocks || [];
	assert(!subBlocks || isArray(subBlocks));
	subBlocks = subBlocks || [];
	var orderMode = ctx.orderMode;
	if (fragment.sortBlocks && orderMode) {
		subBlocks = subBlocks.slice();
		var orderMap = {
			valueAsc: "asc",
			valueDesc: "desc"
		};
		if (hasOwn(orderMap, orderMode)) {
			var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
			subBlocks.sort(function(a, b) {
				return comparator_1.evaluate(a.sortParam, b.sortParam);
			});
		} else if (orderMode === "seriesDesc") subBlocks.reverse();
	}
	each(subBlocks, function(subBlock, idx) {
		var valueFormatter = fragment.valueFormatter;
		var subMarkupText$1 = getBuilder(subBlock)(valueFormatter ? extend(extend({}, ctx), { valueFormatter }) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
		subMarkupText$1 != null && subMarkupTextList.push(subMarkupText$1);
	});
	var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(toolTipTextStyle, subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
	if (noHeader) return subMarkupText;
	var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
	var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
	var tooltipLineHeight = getTooltipLineHeight(toolTipTextStyle);
	if (ctx.renderMode === "richText") return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
	else return wrapBlockHTML(toolTipTextStyle, "<div style=\"" + nameStyle + ";" + tooltipLineHeight + ";\">" + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
}
function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
	var renderMode = ctx.renderMode;
	var noName = fragment.noName;
	var noValue = fragment.noValue;
	var noMarker = !fragment.markerType;
	var name = fragment.name;
	var useUTC = ctx.useUTC;
	var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value) {
		value = isArray(value) ? value : [value];
		return map$1(value, function(val, idx) {
			return makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
		});
	};
	if (noName && noValue) return;
	var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || tokens_default.color.secondary, renderMode);
	var readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
	var valueTypeOption = fragment.valueType;
	var readableValueList = noValue ? [] : valueFormatter(fragment.value, fragment.dataIndex);
	var valueAlignRight = !noMarker || !noName;
	var valueCloseToMarker = !noMarker && noName;
	var _a$1 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a$1.nameStyle, valueStyle = _a$1.valueStyle;
	return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML(toolTipTextStyle, (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
/**
* @return markupText. null/undefined means no content.
*/
function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
	if (!fragment) return;
	return getBuilder(fragment)({
		useUTC,
		renderMode,
		orderMode,
		markupStyleCreator,
		valueFormatter: fragment.valueFormatter
	}, fragment, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
	return {
		html: HTML_GAPS[gapLevel],
		richText: RICH_TEXT_GAPS[gapLevel]
	};
}
function wrapBlockHTML(textStyle, encodedContent, topGap) {
	var clearfix = "<div style=\"clear:both\"></div>";
	var marginCSS = "margin: " + topGap + "px 0 0";
	var tooltipLineHeight = getTooltipLineHeight(textStyle);
	return "<div style=\"" + marginCSS + ";" + tooltipLineHeight + ";\">" + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name, leftHasMarker, style) {
	var marginCss = leftHasMarker ? "margin-left:2px" : "";
	return "<span style=\"" + style + ";" + marginCss + "\">" + encodeHTML(name) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
	var alignCSS = alignRight ? "float:right;margin-left:" + (valueCloseToMarker ? "10px" : "20px") : "";
	valueList = isArray(valueList) ? valueList : [valueList];
	return "<span style=\"" + alignCSS + ";" + style + "\">" + map$1(valueList, function(value) {
		return encodeHTML(value);
	}).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name, style) {
	return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
}
function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
	var styles = [style];
	var paddingLeft = valueCloseToMarker ? 10 : 20;
	alignRight && styles.push({
		padding: [
			0,
			0,
			0,
			paddingLeft
		],
		align: "right"
	});
	return ctx.markupStyleCreator.wrapRichTextStyle(isArray(values) ? values.join("  ") : values, styles);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
	var color$2 = series.getData().getItemVisual(dataIndex, "style")[series.visualDrawType];
	return convertToColorString(color$2);
}
function getPaddingFromTooltipModel(model, renderMode) {
	var padding = model.get("padding");
	return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
/**
* The major feature is generate styles for `renderMode: 'richText'`.
* But it also serves `renderMode: 'html'` to provide
* "renderMode-independent" API.
*/
var TooltipMarkupStyleCreator = function() {
	function TooltipMarkupStyleCreator$1() {
		this.richTextStyles = {};
		this._nextStyleNameId = getRandomIdBase();
	}
	TooltipMarkupStyleCreator$1.prototype._generateStyleName = function() {
		return "__EC_aUTo_" + this._nextStyleNameId++;
	};
	TooltipMarkupStyleCreator$1.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
		var markerId = renderMode === "richText" ? this._generateStyleName() : null;
		var marker = getTooltipMarker({
			color: colorStr,
			type: markerType,
			renderMode,
			markerId
		});
		if (isString(marker)) return marker;
		else {
			assert(markerId);
			this.richTextStyles[markerId] = marker.style;
			return marker.content;
		}
	};
	/**
	* @usage
	* ```ts
	* const styledText = markupStyleCreator.wrapRichTextStyle([
	*     // The styles will be auto merged.
	*     {
	*         fontSize: 12,
	*         color: 'blue'
	*     },
	*     {
	*         padding: 20
	*     }
	* ]);
	* ```
	*/
	TooltipMarkupStyleCreator$1.prototype.wrapRichTextStyle = function(text, styles) {
		var finalStl = {};
		if (isArray(styles)) each(styles, function(stl) {
			return extend(finalStl, stl);
		});
		else extend(finalStl, styles);
		var styleName = this._generateStyleName();
		this.richTextStyles[styleName] = finalStl;
		return "{" + styleName + "|" + text + "}";
	};
	return TooltipMarkupStyleCreator$1;
}();

//#endregion
//#region node_modules/echarts/lib/component/tooltip/seriesFormatTooltip.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function defaultSeriesFormatTooltip(opt) {
	var series = opt.series;
	var dataIndex = opt.dataIndex;
	var multipleSeries = opt.multipleSeries;
	var data = series.getData();
	var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
	var tooltipDimLen = tooltipDims.length;
	var value = series.getRawValue(dataIndex);
	var isValueArr = isArray(value);
	var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
	var inlineValue;
	var inlineValueType;
	var subBlocks;
	var sortParam;
	if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
		var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
		inlineValue = formatArrResult.inlineValues;
		inlineValueType = formatArrResult.inlineValueTypes;
		subBlocks = formatArrResult.blocks;
		sortParam = formatArrResult.inlineValues[0];
	} else if (tooltipDimLen) {
		var dimInfo = data.getDimensionInfo(tooltipDims[0]);
		sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
		inlineValueType = dimInfo.type;
	} else sortParam = inlineValue = isValueArr ? value[0] : value;
	var seriesNameSpecified = isNameSpecified(series);
	var seriesName = seriesNameSpecified && series.name || "";
	var itemName = data.getName(dataIndex);
	var inlineName = multipleSeries ? seriesName : itemName;
	return createTooltipMarkup("section", {
		header: seriesName,
		noHeader: multipleSeries || !seriesNameSpecified,
		sortParam,
		blocks: [createTooltipMarkup("nameValue", {
			markerType: "item",
			markerColor,
			name: inlineName,
			noName: !trim(inlineName),
			value: inlineValue,
			valueType: inlineValueType,
			dataIndex
		})].concat(subBlocks || [])
	});
}
function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
	var data = series.getData();
	var isValueMultipleLine = reduce(value, function(isValueMultipleLine$1, val, idx) {
		var dimItem = data.getDimensionInfo(idx);
		return isValueMultipleLine$1 = isValueMultipleLine$1 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
	}, false);
	var inlineValues = [];
	var inlineValueTypes = [];
	var blocks = [];
	tooltipDims.length ? each(tooltipDims, function(dim) {
		setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
	}) : each(value, setEachItem);
	function setEachItem(val, dim) {
		var dimInfo = data.getDimensionInfo(dim);
		if (!dimInfo || dimInfo.otherDims.tooltip === false) return;
		if (isValueMultipleLine) blocks.push(createTooltipMarkup("nameValue", {
			markerType: "subItem",
			markerColor: colorStr,
			name: dimInfo.displayName,
			value: val,
			valueType: dimInfo.type
		}));
		else {
			inlineValues.push(val);
			inlineValueTypes.push(dimInfo.type);
		}
	}
	return {
		inlineValues,
		inlineValueTypes,
		blocks
	};
}

//#endregion
//#region node_modules/echarts/lib/model/Series.js
init_tslib_es6();
var inner$2 = makeInner();
function getSelectionKey(data, dataIndex) {
	return data.getName(dataIndex) || data.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel = function(_super) {
	__extends(SeriesModel$1, _super);
	function SeriesModel$1() {
		var _this = _super !== null && _super.apply(this, arguments) || this;
		_this._selectedDataIndicesMap = {};
		return _this;
	}
	SeriesModel$1.prototype.init = function(option, parentModel, ecModel) {
		this.seriesIndex = this.componentIndex;
		this.dataTask = createTask({
			count: dataTaskCount,
			reset: dataTaskReset
		});
		this.dataTask.context = { model: this };
		this.mergeDefaultAndTheme(option, ecModel);
		(inner$2(this).sourceManager = new SourceManager(this)).prepareSource();
		var data = this.getInitialData(option, ecModel);
		wrapData(data, this);
		this.dataTask.context.data = data;
		assert(data, "getInitialData returned invalid data.");
		inner$2(this).dataBeforeProcessed = data;
		autoSeriesName(this);
		this._initSelectedMapFromData(data);
	};
	/**
	* Util for merge default and theme to option
	*/
	SeriesModel$1.prototype.mergeDefaultAndTheme = function(option, ecModel) {
		var layoutMode = fetchLayoutMode(this);
		var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
		var themeSubType = this.subType;
		if (Component_default$1.hasClass(themeSubType)) themeSubType += "Series";
		merge(option, ecModel.getTheme().get(this.subType));
		merge(option, this.getDefaultOption());
		defaultEmphasis(option, "label", ["show"]);
		this.fillDataTextStyle(option.data);
		if (layoutMode) mergeLayoutParam(option, inputPositionParams, layoutMode);
	};
	SeriesModel$1.prototype.mergeOption = function(newSeriesOption, ecModel) {
		newSeriesOption = merge(this.option, newSeriesOption, true);
		this.fillDataTextStyle(newSeriesOption.data);
		var layoutMode = fetchLayoutMode(this);
		if (layoutMode) mergeLayoutParam(this.option, newSeriesOption, layoutMode);
		var sourceManager = inner$2(this).sourceManager;
		sourceManager.dirty();
		sourceManager.prepareSource();
		var data = this.getInitialData(newSeriesOption, ecModel);
		wrapData(data, this);
		this.dataTask.dirty();
		this.dataTask.context.data = data;
		inner$2(this).dataBeforeProcessed = data;
		autoSeriesName(this);
		this._initSelectedMapFromData(data);
	};
	SeriesModel$1.prototype.fillDataTextStyle = function(data) {
		if (data && !isTypedArray(data)) {
			var props = ["show"];
			for (var i = 0; i < data.length; i++) if (data[i] && data[i].label) defaultEmphasis(data[i], "label", props);
		}
	};
	/**
	* Init a data structure from data related option in series
	* Must be overridden.
	*/
	SeriesModel$1.prototype.getInitialData = function(option, ecModel) {};
	/**
	* Append data to list
	*/
	SeriesModel$1.prototype.appendData = function(params) {
		this.getRawData().appendData(params.data);
	};
	/**
	* Consider some method like `filter`, `map` need make new data,
	* We should make sure that `seriesModel.getData()` get correct
	* data in the stream procedure. So we fetch data from upstream
	* each time `task.perform` called.
	*/
	SeriesModel$1.prototype.getData = function(dataType) {
		var task = getCurrentTask(this);
		if (task) {
			var data = task.context.data;
			return dataType == null || !data.getLinkedData ? data : data.getLinkedData(dataType);
		} else return inner$2(this).data;
	};
	SeriesModel$1.prototype.getAllData = function() {
		var mainData = this.getData();
		return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{ data: mainData }];
	};
	SeriesModel$1.prototype.setData = function(data) {
		var task = getCurrentTask(this);
		if (task) {
			var context = task.context;
			context.outputData = data;
			if (task !== this.dataTask) context.data = data;
		}
		inner$2(this).data = data;
	};
	SeriesModel$1.prototype.getEncode = function() {
		var encode = this.get("encode", true);
		if (encode) return createHashMap(encode);
	};
	SeriesModel$1.prototype.getSourceManager = function() {
		return inner$2(this).sourceManager;
	};
	SeriesModel$1.prototype.getSource = function() {
		return this.getSourceManager().getSource();
	};
	/**
	* Get data before processed
	*/
	SeriesModel$1.prototype.getRawData = function() {
		return inner$2(this).dataBeforeProcessed;
	};
	SeriesModel$1.prototype.getColorBy = function() {
		return this.get("colorBy") || "series";
	};
	SeriesModel$1.prototype.isColorBySeries = function() {
		return this.getColorBy() === "series";
	};
	/**
	* Get base axis if has coordinate system and has axis.
	* By default use coordSys.getBaseAxis();
	* Can be overridden for some chart.
	* @return {type} description
	*/
	SeriesModel$1.prototype.getBaseAxis = function() {
		var coordSys = this.coordinateSystem;
		return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
	};
	/**
	* Retrieve the index of nearest value in the view coordinate.
	* Data position is compared with each axis's dataToCoord.
	*
	* @param axisDim axis dimension
	* @param dim data dimension
	* @param value
	* @param [maxDistance=Infinity] The maximum distance in view coordinate space
	* @return If and only if multiple indices has
	*         the same value, they are put to the result.
	*/
	SeriesModel$1.prototype.indicesOfNearest = function(axisDim, dim, value, maxDistance) {
		var data = this.getData();
		var coordSys = this.coordinateSystem;
		var axis = coordSys && coordSys.getAxis(axisDim);
		if (!coordSys || !axis) return [];
		var targetCoord = axis.dataToCoord(value);
		if (maxDistance == null) maxDistance = Infinity;
		var nearestIndices = [];
		var minDist = Infinity;
		var minDiff = -1;
		var nearestIndicesLen = 0;
		data.each(dim, function(dimValue, idx) {
			var diff = targetCoord - axis.dataToCoord(dimValue);
			var dist = Math.abs(diff);
			if (dist <= maxDistance) {
				if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {
					minDist = dist;
					minDiff = diff;
					nearestIndicesLen = 0;
				}
				if (diff === minDiff) nearestIndices[nearestIndicesLen++] = idx;
			}
		});
		nearestIndices.length = nearestIndicesLen;
		return nearestIndices;
	};
	/**
	* Default tooltip formatter
	*
	* @param dataIndex
	* @param multipleSeries
	* @param dataType
	* @param renderMode valid values: 'html'(by default) and 'richText'.
	*        'html' is used for rendering tooltip in extra DOM form, and the result
	*        string is used as DOM HTML content.
	*        'richText' is used for rendering tooltip in rich text form, for those where
	*        DOM operation is not supported.
	* @return formatted tooltip with `html` and `markers`
	*        Notice: The override method can also return string
	*/
	SeriesModel$1.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
		return defaultSeriesFormatTooltip({
			series: this,
			dataIndex,
			multipleSeries
		});
	};
	SeriesModel$1.prototype.isAnimationEnabled = function() {
		var ecModel = this.ecModel;
		if (env_default.node && !(ecModel && ecModel.ssr)) return false;
		var animationEnabled = this.getShallow("animation");
		if (animationEnabled) {
			if (this.getData().count() > this.getShallow("animationThreshold")) animationEnabled = false;
		}
		return !!animationEnabled;
	};
	SeriesModel$1.prototype.restoreData = function() {
		this.dataTask.dirty();
	};
	SeriesModel$1.prototype.getColorFromPalette = function(name, scope, requestColorNum) {
		var ecModel = this.ecModel;
		var color$2 = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
		if (!color$2) color$2 = ecModel.getColorFromPalette(name, scope, requestColorNum);
		return color$2;
	};
	/**
	* Use `data.mapDimensionsAll(coordDim)` instead.
	* @deprecated
	*/
	SeriesModel$1.prototype.coordDimToDataDim = function(coordDim) {
		return this.getRawData().mapDimensionsAll(coordDim);
	};
	/**
	* Get progressive rendering count each step
	*/
	SeriesModel$1.prototype.getProgressive = function() {
		return this.get("progressive");
	};
	/**
	* Get progressive rendering count each step
	*/
	SeriesModel$1.prototype.getProgressiveThreshold = function() {
		return this.get("progressiveThreshold");
	};
	SeriesModel$1.prototype.select = function(innerDataIndices, dataType) {
		this._innerSelect(this.getData(dataType), innerDataIndices);
	};
	SeriesModel$1.prototype.unselect = function(innerDataIndices, dataType) {
		var selectedMap = this.option.selectedMap;
		if (!selectedMap) return;
		var selectedMode = this.option.selectedMode;
		var data = this.getData(dataType);
		if (selectedMode === "series" || selectedMap === "all") {
			this.option.selectedMap = {};
			this._selectedDataIndicesMap = {};
			return;
		}
		for (var i = 0; i < innerDataIndices.length; i++) {
			var dataIndex = innerDataIndices[i];
			var nameOrId = getSelectionKey(data, dataIndex);
			selectedMap[nameOrId] = false;
			this._selectedDataIndicesMap[nameOrId] = -1;
		}
	};
	SeriesModel$1.prototype.toggleSelect = function(innerDataIndices, dataType) {
		var tmpArr = [];
		for (var i = 0; i < innerDataIndices.length; i++) {
			tmpArr[0] = innerDataIndices[i];
			this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);
		}
	};
	SeriesModel$1.prototype.getSelectedDataIndices = function() {
		if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
		var selectedDataIndicesMap = this._selectedDataIndicesMap;
		var nameOrIds = keys(selectedDataIndicesMap);
		var dataIndices = [];
		for (var i = 0; i < nameOrIds.length; i++) {
			var dataIndex = selectedDataIndicesMap[nameOrIds[i]];
			if (dataIndex >= 0) dataIndices.push(dataIndex);
		}
		return dataIndices;
	};
	SeriesModel$1.prototype.isSelected = function(dataIndex, dataType) {
		var selectedMap = this.option.selectedMap;
		if (!selectedMap) return false;
		var data = this.getData(dataType);
		return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
	};
	SeriesModel$1.prototype.isUniversalTransitionEnabled = function() {
		if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) return true;
		var universalTransitionOpt = this.option.universalTransition;
		if (!universalTransitionOpt) return false;
		if (universalTransitionOpt === true) return true;
		return universalTransitionOpt && universalTransitionOpt.enabled;
	};
	SeriesModel$1.prototype._innerSelect = function(data, innerDataIndices) {
		var _a$1, _b$1;
		var option = this.option;
		var selectedMode = option.selectedMode;
		var len = innerDataIndices.length;
		if (!selectedMode || !len) return;
		if (selectedMode === "series") option.selectedMap = "all";
		else if (selectedMode === "multiple") {
			if (!isObject$1(option.selectedMap)) option.selectedMap = {};
			var selectedMap = option.selectedMap;
			for (var i = 0; i < len; i++) {
				var dataIndex = innerDataIndices[i];
				var nameOrId = getSelectionKey(data, dataIndex);
				selectedMap[nameOrId] = true;
				this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
			}
		} else if (selectedMode === "single" || selectedMode === true) {
			var lastDataIndex = innerDataIndices[len - 1];
			var nameOrId = getSelectionKey(data, lastDataIndex);
			option.selectedMap = (_a$1 = {}, _a$1[nameOrId] = true, _a$1);
			this._selectedDataIndicesMap = (_b$1 = {}, _b$1[nameOrId] = data.getRawIndex(lastDataIndex), _b$1);
		}
	};
	SeriesModel$1.prototype._initSelectedMapFromData = function(data) {
		if (this.option.selectedMap) return;
		var dataIndices = [];
		if (data.hasItemOption) data.each(function(idx) {
			var rawItem = data.getRawDataItem(idx);
			if (rawItem && rawItem.selected) dataIndices.push(idx);
		});
		if (dataIndices.length > 0) this._innerSelect(data, dataIndices);
	};
	SeriesModel$1.registerClass = function(clz) {
		return Component_default$1.registerClass(clz);
	};
	SeriesModel$1.protoInitialize = function() {
		var proto = SeriesModel$1.prototype;
		proto.type = "series.__base__";
		proto.seriesIndex = 0;
		proto.ignoreStyleOnData = false;
		proto.hasSymbolVisual = false;
		proto.defaultSymbol = "circle";
		proto.visualStyleAccessPath = "itemStyle";
		proto.visualDrawType = "fill";
	}();
	return SeriesModel$1;
}(Component_default$1);
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, Component_default$1);
/**
* MUST be called after `prepareSource` called
* Here we need to make auto series, especially for auto legend. But we
* do not modify series.name in option to avoid side effects.
*/
function autoSeriesName(seriesModel) {
	var name = seriesModel.name;
	if (!isNameSpecified(seriesModel)) seriesModel.name = getSeriesAutoName(seriesModel) || name;
}
function getSeriesAutoName(seriesModel) {
	var data = seriesModel.getRawData();
	var dataDims = data.mapDimensionsAll("seriesName");
	var nameArr = [];
	each(dataDims, function(dataDim) {
		var dimInfo = data.getDimensionInfo(dataDim);
		dimInfo.displayName && nameArr.push(dimInfo.displayName);
	});
	return nameArr.join(" ");
}
function dataTaskCount(context) {
	return context.model.getRawData().count();
}
function dataTaskReset(context) {
	var seriesModel = context.model;
	seriesModel.setData(seriesModel.getRawData().cloneShallow());
	return dataTaskProgress;
}
function dataTaskProgress(param, context) {
	if (context.outputData && param.end > context.outputData.count()) context.model.getRawData().cloneShallow(context.outputData);
}
function wrapData(data, seriesModel) {
	each(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
		data.wrapMethod(methodName, curry(onDataChange, seriesModel));
	});
}
function onDataChange(seriesModel, newList) {
	var task = getCurrentTask(seriesModel);
	if (task) task.setOutputEnd((newList || this).count());
	return newList;
}
function getCurrentTask(seriesModel) {
	var scheduler = (seriesModel.ecModel || {}).scheduler;
	var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
	if (pipeline) {
		var task = pipeline.currentTask;
		if (task) {
			var agentStubMap = task.agentStubMap;
			if (agentStubMap) task = agentStubMap.get(seriesModel.uid);
		}
		return task;
	}
}
var Series_default = SeriesModel;

//#endregion
//#region node_modules/echarts/lib/view/Chart.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var inner$1 = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView = function() {
	function ChartView$1() {
		this.group = new Group_default();
		this.uid = getUID("viewChart");
		this.renderTask = createTask({
			plan: renderTaskPlan,
			reset: renderTaskReset
		});
		this.renderTask.context = { view: this };
	}
	ChartView$1.prototype.init = function(ecModel, api) {};
	ChartView$1.prototype.render = function(seriesModel, ecModel, api, payload) {
		throw new Error("render method must been implemented");
	};
	/**
	* Highlight series or specified data item.
	*/
	ChartView$1.prototype.highlight = function(seriesModel, ecModel, api, payload) {
		var data = seriesModel.getData(payload && payload.dataType);
		if (!data) {
			error("Unknown dataType " + payload.dataType);
			return;
		}
		toggleHighlight(data, payload, "emphasis");
	};
	/**
	* Downplay series or specified data item.
	*/
	ChartView$1.prototype.downplay = function(seriesModel, ecModel, api, payload) {
		var data = seriesModel.getData(payload && payload.dataType);
		if (!data) {
			error("Unknown dataType " + payload.dataType);
			return;
		}
		toggleHighlight(data, payload, "normal");
	};
	/**
	* Remove self.
	*/
	ChartView$1.prototype.remove = function(ecModel, api) {
		this.group.removeAll();
	};
	/**
	* Dispose self.
	*/
	ChartView$1.prototype.dispose = function(ecModel, api) {};
	ChartView$1.prototype.updateView = function(seriesModel, ecModel, api, payload) {
		this.render(seriesModel, ecModel, api, payload);
	};
	ChartView$1.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
		this.render(seriesModel, ecModel, api, payload);
	};
	ChartView$1.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
		this.render(seriesModel, ecModel, api, payload);
	};
	/**
	* Traverse the new rendered elements.
	*
	* It will traverse the new added element in progressive rendering.
	* And traverse all in normal rendering.
	*/
	ChartView$1.prototype.eachRendered = function(cb) {
		traverseElements(this.group, cb);
	};
	ChartView$1.markUpdateMethod = function(payload, methodName) {
		inner$1(payload).updateMethod = methodName;
	};
	ChartView$1.protoInitialize = function() {
		var proto = ChartView$1.prototype;
		proto.type = "chart";
	}();
	return ChartView$1;
}();
/**
* Set state of single element
*/
function elSetState(el, state, highlightDigit) {
	if (el && isHighDownDispatcher(el)) (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
}
function toggleHighlight(data, payload, state) {
	var dataIndex = queryDataIndex(data, payload);
	var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
	if (dataIndex != null) each(normalizeToArray(dataIndex), function(dataIdx) {
		elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
	});
	else data.eachItemGraphicEl(function(el) {
		elSetState(el, state, highlightDigit);
	});
}
enableClassExtend(ChartView, ["dispose"]);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
	return renderPlanner(context.model);
}
function renderTaskReset(context) {
	var seriesModel = context.model;
	var ecModel = context.ecModel;
	var api = context.api;
	var payload = context.payload;
	var progressiveRender = seriesModel.pipelineContext.progressiveRender;
	var view = context.view;
	var updateMethod = payload && inner$1(payload).updateMethod;
	var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
	if (methodName !== "render") view[methodName](seriesModel, ecModel, api, payload);
	return progressMethodMap[methodName];
}
var progressMethodMap = {
	incrementalPrepareRender: { progress: function(params, context) {
		context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
	} },
	render: {
		forceFirstProgress: true,
		progress: function(params, context) {
			context.view.render(context.model, context.ecModel, context.api, context.payload);
		}
	}
};
var Chart_default = ChartView;

//#endregion
//#region node_modules/echarts/lib/visual/style.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var inner = makeInner();
var defaultStyleMappers = {
	itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
	lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
	lineStyle: "stroke",
	itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
	var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
	if (!styleMapper) {
		console.warn("Unknown style type '" + stylePath + "'.");
		return defaultStyleMappers.itemStyle;
	}
	return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
	var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
	if (!colorKey) {
		console.warn("Unknown style type '" + stylePath + "'.");
		return "fill";
	}
	return colorKey;
}
var seriesStyleTask = {
	createOnAllSeries: true,
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		var data = seriesModel.getData();
		var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
		var styleModel = seriesModel.getModel(stylePath);
		var globalStyle = getStyleMapper(seriesModel, stylePath)(styleModel);
		var decalOption = styleModel.getShallow("decal");
		if (decalOption) {
			data.setVisual("decal", decalOption);
			decalOption.dirty = true;
		}
		var colorKey = getDefaultColorKey(seriesModel, stylePath);
		var color$2 = globalStyle[colorKey];
		var colorCallback = isFunction(color$2) ? color$2 : null;
		var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
		if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
			var colorPalette = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
			if (!globalStyle[colorKey]) {
				globalStyle[colorKey] = colorPalette;
				data.setVisual("colorFromPalette", true);
			}
			globalStyle.fill = globalStyle.fill === "auto" || isFunction(globalStyle.fill) ? colorPalette : globalStyle.fill;
			globalStyle.stroke = globalStyle.stroke === "auto" || isFunction(globalStyle.stroke) ? colorPalette : globalStyle.stroke;
		}
		data.setVisual("style", globalStyle);
		data.setVisual("drawType", colorKey);
		if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
			data.setVisual("colorFromPalette", false);
			return { dataEach: function(data$1, idx) {
				var dataParams = seriesModel.getDataParams(idx);
				var itemStyle = extend({}, globalStyle);
				itemStyle[colorKey] = colorCallback(dataParams);
				data$1.setItemVisual(idx, "style", itemStyle);
			} };
		}
	}
};
var sharedModel = new Model_default();
var dataStyleTask = {
	createOnAllSeries: true,
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) return;
		var data = seriesModel.getData();
		var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
		var getStyle = getStyleMapper(seriesModel, stylePath);
		var colorKey = data.getVisual("drawType");
		return { dataEach: data.hasItemOption ? function(data$1, idx) {
			var rawItem = data$1.getRawDataItem(idx);
			if (rawItem && rawItem[stylePath]) {
				sharedModel.option = rawItem[stylePath];
				var style = getStyle(sharedModel);
				extend(data$1.ensureUniqueItemVisual(idx, "style"), style);
				if (sharedModel.option.decal) {
					data$1.setItemVisual(idx, "decal", sharedModel.option.decal);
					sharedModel.option.decal.dirty = true;
				}
				if (colorKey in style) data$1.setItemVisual(idx, "colorFromPalette", false);
			}
		} : null };
	}
};
var dataColorPaletteTask = {
	performRawSeries: true,
	overallReset: function(ecModel) {
		var paletteScopeGroupByType = createHashMap();
		ecModel.eachSeries(function(seriesModel) {
			var colorBy = seriesModel.getColorBy();
			if (seriesModel.isColorBySeries()) return;
			var key$1 = seriesModel.type + "-" + colorBy;
			var colorScope = paletteScopeGroupByType.get(key$1);
			if (!colorScope) {
				colorScope = {};
				paletteScopeGroupByType.set(key$1, colorScope);
			}
			inner(seriesModel).scope = colorScope;
		});
		ecModel.eachSeries(function(seriesModel) {
			if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) return;
			var dataAll = seriesModel.getRawData();
			var idxMap = {};
			var data = seriesModel.getData();
			var colorScope = inner(seriesModel).scope;
			var colorKey = getDefaultColorKey(seriesModel, seriesModel.visualStyleAccessPath || "itemStyle");
			data.each(function(idx) {
				var rawIdx = data.getRawIndex(idx);
				idxMap[rawIdx] = idx;
			});
			dataAll.each(function(rawIdx) {
				var idx = idxMap[rawIdx];
				if (data.getItemVisual(idx, "colorFromPalette")) {
					var itemStyle = data.ensureUniqueItemVisual(idx, "style");
					var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
					var dataCount = dataAll.count();
					itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
				}
			});
		});
	}
};

//#endregion
//#region node_modules/echarts/lib/loading/default.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var PI = Math.PI;
/**
* @param {module:echarts/ExtensionAPI} api
* @param {Object} [opts]
* @param {string} [opts.text]
* @param {string} [opts.color]
* @param {string} [opts.textColor]
* @return {module:zrender/Element}
*/
function defaultLoading(api, opts) {
	opts = opts || {};
	defaults(opts, {
		text: "loading",
		textColor: tokens_default.color.primary,
		fontSize: 12,
		fontWeight: "normal",
		fontStyle: "normal",
		fontFamily: "sans-serif",
		maskColor: "rgba(255,255,255,0.8)",
		showSpinner: true,
		color: tokens_default.color.theme[0],
		spinnerRadius: 10,
		lineWidth: 5,
		zlevel: 0
	});
	var group = new Group_default();
	var mask = new Rect_default({
		style: { fill: opts.maskColor },
		zlevel: opts.zlevel,
		z: 1e4
	});
	group.add(mask);
	var textContent = new Text_default({
		style: {
			text: opts.text,
			fill: opts.textColor,
			fontSize: opts.fontSize,
			fontWeight: opts.fontWeight,
			fontStyle: opts.fontStyle,
			fontFamily: opts.fontFamily
		},
		zlevel: opts.zlevel,
		z: 10001
	});
	var labelRect = new Rect_default({
		style: { fill: "none" },
		textContent,
		textConfig: {
			position: "right",
			distance: 10
		},
		zlevel: opts.zlevel,
		z: 10001
	});
	group.add(labelRect);
	var arc;
	if (opts.showSpinner) {
		arc = new Arc_default({
			shape: {
				startAngle: -PI / 2,
				endAngle: -PI / 2 + .1,
				r: opts.spinnerRadius
			},
			style: {
				stroke: opts.color,
				lineCap: "round",
				lineWidth: opts.lineWidth
			},
			zlevel: opts.zlevel,
			z: 10001
		});
		arc.animateShape(true).when(1e3, { endAngle: PI * 3 / 2 }).start("circularInOut");
		arc.animateShape(true).when(1e3, { startAngle: PI * 3 / 2 }).delay(300).start("circularInOut");
		group.add(arc);
	}
	group.resize = function() {
		var textWidth = textContent.getBoundingRect().width;
		var r = opts.showSpinner ? opts.spinnerRadius : 0;
		var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
		var cy = api.getHeight() / 2;
		opts.showSpinner && arc.setShape({
			cx,
			cy
		});
		labelRect.setShape({
			x: cx - r,
			y: cy - r,
			width: r * 2,
			height: r * 2
		});
		mask.setShape({
			x: 0,
			y: 0,
			width: api.getWidth(),
			height: api.getHeight()
		});
	};
	group.resize();
	return group;
}

//#endregion
//#region node_modules/echarts/lib/core/Scheduler.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var Scheduler = function() {
	function Scheduler$1(ecInstance, api, dataProcessorHandlers, visualHandlers) {
		this._stageTaskMap = createHashMap();
		this.ecInstance = ecInstance;
		this.api = api;
		dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
		visualHandlers = this._visualHandlers = visualHandlers.slice();
		this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
	}
	Scheduler$1.prototype.restoreData = function(ecModel, payload) {
		ecModel.restoreData(payload);
		this._stageTaskMap.each(function(taskRecord) {
			var overallTask = taskRecord.overallTask;
			overallTask && overallTask.dirty();
		});
	};
	Scheduler$1.prototype.getPerformArgs = function(task, isBlock) {
		if (!task.__pipeline) return;
		var pipeline = this._pipelineMap.get(task.__pipeline.id);
		var pCtx = pipeline.context;
		var step = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex ? pipeline.step : null;
		var modDataCount = pCtx && pCtx.modDataCount;
		return {
			step,
			modBy: modDataCount != null ? Math.ceil(modDataCount / step) : null,
			modDataCount
		};
	};
	Scheduler$1.prototype.getPipeline = function(pipelineId) {
		return this._pipelineMap.get(pipelineId);
	};
	/**
	* Current, progressive rendering starts from visual and layout.
	* Always detect render mode in the same stage, avoiding that incorrect
	* detection caused by data filtering.
	* Caution:
	* `updateStreamModes` use `seriesModel.getData()`.
	*/
	Scheduler$1.prototype.updateStreamModes = function(seriesModel, view) {
		var pipeline = this._pipelineMap.get(seriesModel.uid);
		var dataLen = seriesModel.getData().count();
		var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
		var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
		seriesModel.pipelineContext = pipeline.context = {
			progressiveRender,
			modDataCount: seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null,
			large
		};
	};
	Scheduler$1.prototype.restorePipelines = function(ecModel) {
		var scheduler = this;
		var pipelineMap = scheduler._pipelineMap = createHashMap();
		ecModel.eachSeries(function(seriesModel) {
			var progressive = seriesModel.getProgressive();
			var pipelineId = seriesModel.uid;
			pipelineMap.set(pipelineId, {
				id: pipelineId,
				head: null,
				tail: null,
				threshold: seriesModel.getProgressiveThreshold(),
				progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
				blockIndex: -1,
				step: Math.round(progressive || 700),
				count: 0
			});
			scheduler._pipe(seriesModel, seriesModel.dataTask);
		});
	};
	Scheduler$1.prototype.prepareStageTasks = function() {
		var stageTaskMap = this._stageTaskMap;
		var ecModel = this.api.getModel();
		var api = this.api;
		each(this._allHandlers, function(handler) {
			var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
			var errMsg = "";
			errMsg = "\"reset\" and \"overallReset\" must not be both specified.";
			assert(!(handler.reset && handler.overallReset), errMsg);
			handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
			handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
		}, this);
	};
	Scheduler$1.prototype.prepareView = function(view, model, ecModel, api) {
		var renderTask = view.renderTask;
		var context = renderTask.context;
		context.model = model;
		context.ecModel = ecModel;
		context.api = api;
		renderTask.__block = !view.incrementalPrepareRender;
		this._pipe(model, renderTask);
	};
	Scheduler$1.prototype.performDataProcessorTasks = function(ecModel, payload) {
		this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, { block: true });
	};
	Scheduler$1.prototype.performVisualTasks = function(ecModel, payload, opt) {
		this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
	};
	Scheduler$1.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
		opt = opt || {};
		var unfinished = false;
		var scheduler = this;
		each(stageHandlers, function(stageHandler, idx) {
			if (opt.visualType && opt.visualType !== stageHandler.visualType) return;
			var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
			var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
			var overallTask = stageHandlerRecord.overallTask;
			if (overallTask) {
				var overallNeedDirty_1;
				var agentStubMap = overallTask.agentStubMap;
				agentStubMap.each(function(stub) {
					if (needSetDirty(opt, stub)) {
						stub.dirty();
						overallNeedDirty_1 = true;
					}
				});
				overallNeedDirty_1 && overallTask.dirty();
				scheduler.updatePayload(overallTask, payload);
				var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
				agentStubMap.each(function(stub) {
					stub.perform(performArgs_1);
				});
				if (overallTask.perform(performArgs_1)) unfinished = true;
			} else if (seriesTaskMap) seriesTaskMap.each(function(task, pipelineId) {
				if (needSetDirty(opt, task)) task.dirty();
				var performArgs = scheduler.getPerformArgs(task, opt.block);
				performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
				scheduler.updatePayload(task, payload);
				if (task.perform(performArgs)) unfinished = true;
			});
		});
		function needSetDirty(opt$1, task) {
			return opt$1.setDirty && (!opt$1.dirtyMap || opt$1.dirtyMap.get(task.__pipeline.id));
		}
		this.unfinished = unfinished || this.unfinished;
	};
	Scheduler$1.prototype.performSeriesTasks = function(ecModel) {
		var unfinished;
		ecModel.eachSeries(function(seriesModel) {
			unfinished = seriesModel.dataTask.perform() || unfinished;
		});
		this.unfinished = unfinished || this.unfinished;
	};
	Scheduler$1.prototype.plan = function() {
		this._pipelineMap.each(function(pipeline) {
			var task = pipeline.tail;
			do {
				if (task.__block) {
					pipeline.blockIndex = task.__idxInPipeline;
					break;
				}
				task = task.getUpstream();
			} while (task);
		});
	};
	Scheduler$1.prototype.updatePayload = function(task, payload) {
		payload !== "remain" && (task.context.payload = payload);
	};
	Scheduler$1.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
		var scheduler = this;
		var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
		var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
		var seriesType$1 = stageHandler.seriesType;
		var getTargetSeries = stageHandler.getTargetSeries;
		if (stageHandler.createOnAllSeries) ecModel.eachRawSeries(create$1);
		else if (seriesType$1) ecModel.eachRawSeriesByType(seriesType$1, create$1);
		else if (getTargetSeries) getTargetSeries(ecModel, api).each(create$1);
		function create$1(seriesModel) {
			var pipelineId = seriesModel.uid;
			var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
				plan: seriesTaskPlan,
				reset: seriesTaskReset,
				count: seriesTaskCount
			}));
			task.context = {
				model: seriesModel,
				ecModel,
				api,
				useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
				plan: stageHandler.plan,
				reset: stageHandler.reset,
				scheduler
			};
			scheduler._pipe(seriesModel, task);
		}
	};
	Scheduler$1.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
		var scheduler = this;
		var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({ reset: overallTaskReset });
		overallTask.context = {
			ecModel,
			api,
			overallReset: stageHandler.overallReset,
			scheduler
		};
		var oldAgentStubMap = overallTask.agentStubMap;
		var newAgentStubMap = overallTask.agentStubMap = createHashMap();
		var seriesType$1 = stageHandler.seriesType;
		var getTargetSeries = stageHandler.getTargetSeries;
		var overallProgress = true;
		var shouldOverallTaskDirty = false;
		var errMsg = "";
		errMsg = "\"createOnAllSeries\" is not supported for \"overallReset\", because it will block all streams.";
		assert(!stageHandler.createOnAllSeries, errMsg);
		if (seriesType$1) ecModel.eachRawSeriesByType(seriesType$1, createStub);
		else if (getTargetSeries) getTargetSeries(ecModel, api).each(createStub);
		else {
			overallProgress = false;
			each(ecModel.getSeries(), createStub);
		}
		function createStub(seriesModel) {
			var pipelineId = seriesModel.uid;
			var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({
				reset: stubReset,
				onDirty: stubOnDirty
			})));
			stub.context = {
				model: seriesModel,
				overallProgress
			};
			stub.agent = overallTask;
			stub.__block = overallProgress;
			scheduler._pipe(seriesModel, stub);
		}
		if (shouldOverallTaskDirty) overallTask.dirty();
	};
	Scheduler$1.prototype._pipe = function(seriesModel, task) {
		var pipelineId = seriesModel.uid;
		var pipeline = this._pipelineMap.get(pipelineId);
		!pipeline.head && (pipeline.head = task);
		pipeline.tail && pipeline.tail.pipe(task);
		pipeline.tail = task;
		task.__idxInPipeline = pipeline.count++;
		task.__pipeline = pipeline;
	};
	Scheduler$1.wrapStageHandler = function(stageHandler, visualType) {
		if (isFunction(stageHandler)) stageHandler = {
			overallReset: stageHandler,
			seriesType: detectSeriseType(stageHandler)
		};
		stageHandler.uid = getUID("stageHandler");
		visualType && (stageHandler.visualType = visualType);
		return stageHandler;
	};
	return Scheduler$1;
}();
function overallTaskReset(context) {
	context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
	return context.overallProgress && stubProgress;
}
function stubProgress() {
	this.agent.dirty();
	this.getDownstream().dirty();
}
function stubOnDirty() {
	this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
	return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
	if (context.useClearVisual) context.data.clearAllVisual();
	var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
	return resetDefines.length > 1 ? map$1(resetDefines, function(v, idx) {
		return makeSeriesTaskProgress(idx);
	}) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
	return function(params, context) {
		var data = context.data;
		var resetDefine = context.resetDefines[resetDefineIdx];
		if (resetDefine && resetDefine.dataEach) for (var i = params.start; i < params.end; i++) resetDefine.dataEach(data, i);
		else if (resetDefine && resetDefine.progress) resetDefine.progress(params, data);
	};
}
function seriesTaskCount(context) {
	return context.data.count();
}
/**
* Only some legacy stage handlers (usually in echarts extensions) are pure function.
* To ensure that they can work normally, they should work in block mode, that is,
* they should not be started util the previous tasks finished. So they cause the
* progressive rendering disabled. We try to detect the series type, to narrow down
* the block range to only the series type they concern, but not all series.
*/
function detectSeriseType(legacyFunc) {
	seriesType = null;
	try {
		legacyFunc(ecModelMock, apiMock);
	} catch (e$1) {}
	return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, Global_default);
mockMethods(apiMock, ExtensionAPI_default);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
	seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
	if (cond.mainType === "series" && cond.subType) seriesType = cond.subType;
};
function mockMethods(target, Clz) {
	for (var name_1 in Clz.prototype) target[name_1] = noop;
}
var Scheduler_default = Scheduler;

//#endregion
//#region node_modules/echarts/lib/theme/dark.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var color = tokens_default.darkColor;
var backgroundColor = color.background;
var axisCommon = function() {
	return {
		axisLine: { lineStyle: { color: color.axisLine } },
		splitLine: { lineStyle: { color: color.axisSplitLine } },
		splitArea: { areaStyle: { color: [color.backgroundTint, color.backgroundTransparent] } },
		minorSplitLine: { lineStyle: { color: color.axisMinorSplitLine } },
		axisLabel: { color: color.axisLabel },
		axisName: {}
	};
};
var matrixAxis = {
	label: { color: color.secondary },
	itemStyle: { borderColor: color.borderTint },
	dividerLineStyle: { color: color.border }
};
var theme = {
	darkMode: true,
	color: color.theme,
	backgroundColor,
	axisPointer: {
		lineStyle: { color: color.border },
		crossStyle: { color: color.borderShade },
		label: { color: color.tertiary }
	},
	legend: {
		textStyle: { color: color.secondary },
		pageTextStyle: { color: color.tertiary }
	},
	textStyle: { color: color.secondary },
	title: {
		textStyle: { color: color.primary },
		subtextStyle: { color: color.quaternary }
	},
	toolbox: { iconStyle: { borderColor: color.accent50 } },
	tooltip: {
		backgroundColor: color.neutral20,
		defaultBorderColor: color.border,
		textStyle: { color: color.tertiary }
	},
	dataZoom: {
		borderColor: color.accent10,
		textStyle: { color: color.tertiary },
		brushStyle: { color: color.backgroundTint },
		handleStyle: {
			color: color.neutral00,
			borderColor: color.accent20
		},
		moveHandleStyle: { color: color.accent40 },
		emphasis: { handleStyle: { borderColor: color.accent50 } },
		dataBackground: {
			lineStyle: { color: color.accent30 },
			areaStyle: { color: color.accent20 }
		},
		selectedDataBackground: {
			lineStyle: { color: color.accent50 },
			areaStyle: { color: color.accent30 }
		}
	},
	visualMap: {
		textStyle: { color: color.secondary },
		handleStyle: { borderColor: color.neutral30 }
	},
	timeline: {
		lineStyle: { color: color.accent10 },
		label: { color: color.tertiary },
		controlStyle: {
			color: color.accent30,
			borderColor: color.accent30
		}
	},
	calendar: {
		itemStyle: {
			color: color.neutral00,
			borderColor: color.neutral20
		},
		dayLabel: { color: color.tertiary },
		monthLabel: { color: color.secondary },
		yearLabel: { color: color.secondary }
	},
	matrix: {
		x: matrixAxis,
		y: matrixAxis,
		backgroundColor: { borderColor: color.axisLine },
		body: { itemStyle: { borderColor: color.borderTint } }
	},
	timeAxis: axisCommon(),
	logAxis: axisCommon(),
	valueAxis: axisCommon(),
	categoryAxis: axisCommon(),
	line: { symbol: "circle" },
	graph: { color: color.theme },
	gauge: {
		title: { color: color.secondary },
		axisLine: { lineStyle: { color: [[1, color.neutral05]] } },
		axisLabel: { color: color.axisLabel },
		detail: { color: color.primary }
	},
	candlestick: { itemStyle: {
		color: "#f64e56",
		color0: "#54ea92",
		borderColor: "#f64e56",
		borderColor0: "#54ea92"
	} },
	funnel: { itemStyle: { borderColor: color.background } },
	radar: function() {
		var radar = axisCommon();
		radar.axisName = { color: color.axisLabel };
		radar.axisLine.lineStyle.color = color.neutral20;
		return radar;
	}(),
	treemap: { breadcrumb: {
		itemStyle: {
			color: color.neutral20,
			textStyle: { color: color.secondary }
		},
		emphasis: { itemStyle: { color: color.neutral30 } }
	} },
	sunburst: { itemStyle: { borderColor: color.background } },
	map: {
		itemStyle: {
			borderColor: color.border,
			areaColor: color.neutral10
		},
		label: { color: color.tertiary },
		emphasis: {
			label: { color: color.primary },
			itemStyle: { areaColor: color.highlight }
		},
		select: {
			label: { color: color.primary },
			itemStyle: { areaColor: color.highlight }
		}
	},
	geo: {
		itemStyle: {
			borderColor: color.border,
			areaColor: color.neutral10
		},
		emphasis: {
			label: { color: color.primary },
			itemStyle: { areaColor: color.highlight }
		},
		select: {
			label: { color: color.primary },
			itemStyle: { color: color.highlight }
		}
	}
};
theme.categoryAxis.splitLine.show = false;
var dark_default = theme;

//#endregion
//#region node_modules/echarts/lib/util/ECEventProcessor.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Usage of query:
* `chart.on('click', query, handler);`
* The `query` can be:
* + The component type query string, only `mainType` or `mainType.subType`,
*   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.
* + The component query object, like:
*   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,
*   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.
* + The data query object, like:
*   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.
* + The other query object (cmponent customized query), like:
*   `{element: 'some'}` (only available in custom series).
*
* Caveat: If a prop in the `query` object is `null/undefined`, it is the
* same as there is no such prop in the `query` object.
*/
var ECEventProcessor = function() {
	function ECEventProcessor$1() {}
	ECEventProcessor$1.prototype.normalizeQuery = function(query) {
		var cptQuery = {};
		var dataQuery = {};
		var otherQuery = {};
		if (isString(query)) {
			var condCptType = parseClassType(query);
			cptQuery.mainType = condCptType.main || null;
			cptQuery.subType = condCptType.sub || null;
		} else {
			var suffixes_1 = [
				"Index",
				"Name",
				"Id"
			];
			var dataKeys_1 = {
				name: 1,
				dataIndex: 1,
				dataType: 1
			};
			each(query, function(val, key$1) {
				var reserved = false;
				for (var i = 0; i < suffixes_1.length; i++) {
					var propSuffix = suffixes_1[i];
					var suffixPos = key$1.lastIndexOf(propSuffix);
					if (suffixPos > 0 && suffixPos === key$1.length - propSuffix.length) {
						var mainType = key$1.slice(0, suffixPos);
						if (mainType !== "data") {
							cptQuery.mainType = mainType;
							cptQuery[propSuffix.toLowerCase()] = val;
							reserved = true;
						}
					}
				}
				if (dataKeys_1.hasOwnProperty(key$1)) {
					dataQuery[key$1] = val;
					reserved = true;
				}
				if (!reserved) otherQuery[key$1] = val;
			});
		}
		return {
			cptQuery,
			dataQuery,
			otherQuery
		};
	};
	ECEventProcessor$1.prototype.filter = function(eventType, query) {
		var eventInfo = this.eventInfo;
		if (!eventInfo) return true;
		var targetEl = eventInfo.targetEl;
		var packedEvent = eventInfo.packedEvent;
		var model = eventInfo.model;
		var view = eventInfo.view;
		if (!model || !view) return true;
		var cptQuery = query.cptQuery;
		var dataQuery = query.dataQuery;
		return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
		function check(query$1, host, prop, propOnHost) {
			return query$1[prop] == null || host[propOnHost || prop] === query$1[prop];
		}
	};
	ECEventProcessor$1.prototype.afterTrigger = function() {
		this.eventInfo = null;
	};
	return ECEventProcessor$1;
}();

//#endregion
//#region node_modules/echarts/lib/visual/symbol.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var SYMBOL_PROPS_WITH_CB = [
	"symbol",
	"symbolSize",
	"symbolRotate",
	"symbolOffset"
];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
var seriesSymbolTask = {
	createOnAllSeries: true,
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		var data = seriesModel.getData();
		if (seriesModel.legendIcon) data.setVisual("legendIcon", seriesModel.legendIcon);
		if (!seriesModel.hasSymbolVisual) return;
		var symbolOptions = {};
		var symbolOptionsCb = {};
		var hasCallback = false;
		for (var i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
			var symbolPropName = SYMBOL_PROPS_WITH_CB[i];
			var val = seriesModel.get(symbolPropName);
			if (isFunction(val)) {
				hasCallback = true;
				symbolOptionsCb[symbolPropName] = val;
			} else symbolOptions[symbolPropName] = val;
		}
		symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
		data.setVisual(extend({
			legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
			symbolKeepAspect: seriesModel.get("symbolKeepAspect")
		}, symbolOptions));
		if (ecModel.isSeriesFiltered(seriesModel)) return;
		var symbolPropsCb = keys(symbolOptionsCb);
		function dataEach(data$1, idx) {
			var rawValue = seriesModel.getRawValue(idx);
			var params = seriesModel.getDataParams(idx);
			for (var i$1 = 0; i$1 < symbolPropsCb.length; i$1++) {
				var symbolPropName$1 = symbolPropsCb[i$1];
				data$1.setItemVisual(idx, symbolPropName$1, symbolOptionsCb[symbolPropName$1](rawValue, params));
			}
		}
		return { dataEach: hasCallback ? dataEach : null };
	}
};
var dataSymbolTask = {
	createOnAllSeries: true,
	performRawSeries: true,
	reset: function(seriesModel, ecModel) {
		if (!seriesModel.hasSymbolVisual) return;
		if (ecModel.isSeriesFiltered(seriesModel)) return;
		var data = seriesModel.getData();
		function dataEach(data$1, idx) {
			var itemModel = data$1.getItemModel(idx);
			for (var i = 0; i < SYMBOL_PROPS.length; i++) {
				var symbolPropName = SYMBOL_PROPS[i];
				var val = itemModel.getShallow(symbolPropName, true);
				if (val != null) data$1.setItemVisual(idx, symbolPropName, val);
			}
		}
		return { dataEach: data.hasItemOption ? dataEach : null };
	}
};

//#endregion
//#region node_modules/echarts/lib/visual/helper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function getItemVisualFromData(data, dataIndex, key$1) {
	switch (key$1) {
		case "color": return data.getItemVisual(dataIndex, "style")[data.getVisual("drawType")];
		case "opacity": return data.getItemVisual(dataIndex, "style").opacity;
		case "symbol":
		case "symbolSize":
		case "liftZ": return data.getItemVisual(dataIndex, key$1);
		default: console.warn("Unknown visual type " + key$1);
	}
}
function getVisualFromData(data, key$1) {
	switch (key$1) {
		case "color": return data.getVisual("style")[data.getVisual("drawType")];
		case "opacity": return data.getVisual("style").opacity;
		case "symbol":
		case "symbolSize":
		case "liftZ": return data.getVisual(key$1);
		default: console.warn("Unknown visual type " + key$1);
	}
}
function setItemVisualFromData(data, dataIndex, key$1, value) {
	switch (key$1) {
		case "color":
			var style = data.ensureUniqueItemVisual(dataIndex, "style");
			style[data.getVisual("drawType")] = value;
			data.setItemVisual(dataIndex, "colorFromPalette", false);
			break;
		case "opacity":
			data.ensureUniqueItemVisual(dataIndex, "style").opacity = value;
			break;
		case "symbol":
		case "symbolSize":
		case "liftZ":
			data.setItemVisual(dataIndex, key$1, value);
			break;
		default: console.warn("Unknown visual type " + key$1);
	}
}

//#endregion
//#region node_modules/echarts/lib/legacy/dataSelectAction.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function createLegacyDataSelectAction(seriesType$1, ecRegisterAction) {
	function getSeriesIndices(ecModel, payload) {
		var seriesIndices = [];
		ecModel.eachComponent({
			mainType: "series",
			subType: seriesType$1,
			query: payload
		}, function(seriesModel) {
			seriesIndices.push(seriesModel.seriesIndex);
		});
		return seriesIndices;
	}
	each([
		[seriesType$1 + "ToggleSelect", "toggleSelect"],
		[seriesType$1 + "Select", "select"],
		[seriesType$1 + "UnSelect", "unselect"]
	], function(eventsMap) {
		ecRegisterAction(eventsMap[0], function(payload, ecModel, api) {
			payload = extend({}, payload);
			deprecateReplaceLog(payload.type, eventsMap[1]);
			api.dispatchAction(extend(payload, {
				type: eventsMap[1],
				seriesIndex: getSeriesIndices(ecModel, payload)
			}));
		});
	});
}
function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
	var legacyEventName = type + eventPostfix;
	if (!ecIns.isSilent(legacyEventName)) {
		deprecateLog("event " + legacyEventName + " is deprecated.");
		ecModel.eachComponent({
			mainType: "series",
			subType: "pie"
		}, function(seriesModel) {
			var seriesIndex = seriesModel.seriesIndex;
			var selectedMap = seriesModel.option.selectedMap;
			var selected = payload.selected;
			for (var i = 0; i < selected.length; i++) if (selected[i].seriesIndex === seriesIndex) {
				var data = seriesModel.getData();
				var dataIndex = queryDataIndex(data, payload.fromActionPayload);
				ecIns.trigger(legacyEventName, {
					type: legacyEventName,
					seriesId: seriesModel.id,
					name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
					selected: isString(selectedMap) ? selectedMap : extend({}, selectedMap)
				});
			}
		});
	}
}
function handleLegacySelectEvents(messageCenter, ecIns, api) {
	messageCenter.on("selectchanged", function(params) {
		var ecModel = api.getModel();
		if (params.isFromClick) {
			handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
			handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
		} else if (params.fromAction === "select") {
			handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
			handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
		} else if (params.fromAction === "unselect") {
			handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
			handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/util/event.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function findEventDispatcher(target, det, returnFirstMatch) {
	var found;
	while (target) {
		if (det(target)) {
			found = target;
			if (returnFirstMatch) break;
		}
		target = target.__hostTarget || target.parent;
	}
	return found;
}

//#endregion
//#region node_modules/zrender/lib/core/WeakMap.js
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap = function() {
	function WeakMap$1() {
		this._id = "__ec_inner_" + wmUniqueIndex++;
	}
	WeakMap$1.prototype.get = function(key$1) {
		return this._guard(key$1)[this._id];
	};
	WeakMap$1.prototype.set = function(key$1, value) {
		var target = this._guard(key$1);
		if (supportDefineProperty) Object.defineProperty(target, this._id, {
			value,
			enumerable: false,
			configurable: true
		});
		else target[this._id] = value;
		return this;
	};
	WeakMap$1.prototype["delete"] = function(key$1) {
		if (this.has(key$1)) {
			delete this._guard(key$1)[this._id];
			return true;
		}
		return false;
	};
	WeakMap$1.prototype.has = function(key$1) {
		return !!this._guard(key$1)[this._id];
	};
	WeakMap$1.prototype._guard = function(key$1) {
		if (key$1 !== Object(key$1)) throw TypeError("Value of WeakMap is not a non-null object.");
		return key$1;
	};
	return WeakMap$1;
}();
var WeakMap_default = WeakMap;

//#endregion
//#region node_modules/echarts/lib/util/decal.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var decalMap = new WeakMap_default();
var decalCache = new LRU_default(100);
var decalKeys = [
	"symbol",
	"symbolSize",
	"symbolKeepAspect",
	"color",
	"backgroundColor",
	"dashArrayX",
	"dashArrayY",
	"maxTileWidth",
	"maxTileHeight"
];
/**
* Create or update pattern image from decal options
*
* @param {InnerDecalObject | 'none'} decalObject decal options, 'none' if no decal
* @return {Pattern} pattern with generated image, null if no decal
*/
function createOrUpdatePatternFromDecal(decalObject, api) {
	if (decalObject === "none") return null;
	var dpr = api.getDevicePixelRatio();
	var zr = api.getZr();
	var isSVG = zr.painter.type === "svg";
	if (decalObject.dirty) decalMap["delete"](decalObject);
	var oldPattern = decalMap.get(decalObject);
	if (oldPattern) return oldPattern;
	var decalOpt = defaults(decalObject, {
		symbol: "rect",
		symbolSize: 1,
		symbolKeepAspect: true,
		color: "rgba(0, 0, 0, 0.2)",
		backgroundColor: null,
		dashArrayX: 5,
		dashArrayY: 5,
		rotation: 0,
		maxTileWidth: 512,
		maxTileHeight: 512
	});
	if (decalOpt.backgroundColor === "none") decalOpt.backgroundColor = null;
	var pattern = { repeat: "repeat" };
	setPatternnSource(pattern);
	pattern.rotation = decalOpt.rotation;
	pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr;
	decalMap.set(decalObject, pattern);
	decalObject.dirty = false;
	return pattern;
	function setPatternnSource(pattern$1) {
		var keys$1 = [dpr];
		var isValidKey = true;
		for (var i = 0; i < decalKeys.length; ++i) {
			var value = decalOpt[decalKeys[i]];
			if (value != null && !isArray(value) && !isString(value) && !isNumber(value) && typeof value !== "boolean") {
				isValidKey = false;
				break;
			}
			keys$1.push(value);
		}
		var cacheKey;
		if (isValidKey) {
			cacheKey = keys$1.join(",") + (isSVG ? "-svg" : "");
			var cache = decalCache.get(cacheKey);
			if (cache) isSVG ? pattern$1.svgElement = cache : pattern$1.image = cache;
		}
		var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
		var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
		var symbolArray = normalizeSymbolArray(decalOpt.symbol);
		var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
		var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
		var canvas = !isSVG && platformApi.createCanvas();
		var svgRoot = isSVG && {
			tag: "g",
			attrs: {},
			key: "dcl",
			children: []
		};
		var pSize = getPatternSize();
		var ctx;
		if (canvas) {
			canvas.width = pSize.width * dpr;
			canvas.height = pSize.height * dpr;
			ctx = canvas.getContext("2d");
		}
		brushDecal();
		if (isValidKey) decalCache.put(cacheKey, canvas || svgRoot);
		pattern$1.image = canvas;
		pattern$1.svgElement = svgRoot;
		pattern$1.svgWidth = pSize.width;
		pattern$1.svgHeight = pSize.height;
		/**
		* Get minimum length that can make a repeatable pattern.
		*
		* @return {Object} pattern width and height
		*/
		function getPatternSize() {
			/**
			* For example, if dash is [[3, 2], [2, 1]] for X, it looks like
			* |---  ---  ---  ---  --- ...
			* |-- -- -- -- -- -- -- -- ...
			* |---  ---  ---  ---  --- ...
			* |-- -- -- -- -- -- -- -- ...
			* So the minimum length of X is 15,
			* which is the least common multiple of `3 + 2` and `2 + 1`
			* |---  ---  ---  |---  --- ...
			* |-- -- -- -- -- |-- -- -- ...
			*/
			var width = 1;
			for (var i$1 = 0, xlen = lineBlockLengthsX.length; i$1 < xlen; ++i$1) width = getLeastCommonMultiple(width, lineBlockLengthsX[i$1]);
			var symbolRepeats = 1;
			for (var i$1 = 0, xlen = symbolArray.length; i$1 < xlen; ++i$1) symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i$1].length);
			width *= symbolRepeats;
			var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
			var warn$1 = function(attrName) {
				console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
			};
			if (width > decalOpt.maxTileWidth) warn$1("maxTileWidth");
			if (height > decalOpt.maxTileHeight) warn$1("maxTileHeight");
			return {
				width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
				height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
			};
		}
		function brushDecal() {
			if (ctx) {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				if (decalOpt.backgroundColor) {
					ctx.fillStyle = decalOpt.backgroundColor;
					ctx.fillRect(0, 0, canvas.width, canvas.height);
				}
			}
			var ySum = 0;
			for (var i$1 = 0; i$1 < dashArrayY.length; ++i$1) ySum += dashArrayY[i$1];
			if (ySum <= 0) return;
			var y = -lineBlockLengthY;
			var yId = 0;
			var yIdTotal = 0;
			var xId0 = 0;
			while (y < pSize.height) {
				if (yId % 2 === 0) {
					var symbolYId = yIdTotal / 2 % symbolArray.length;
					var x = 0;
					var xId1 = 0;
					var xId1Total = 0;
					while (x < pSize.width * 2) {
						var xSum = 0;
						for (var i$1 = 0; i$1 < dashArrayX[xId0].length; ++i$1) xSum += dashArrayX[xId0][i$1];
						if (xSum <= 0) break;
						if (xId1 % 2 === 0) {
							var size = (1 - decalOpt.symbolSize) * .5;
							var left = x + dashArrayX[xId0][xId1] * size;
							var top_1 = y + dashArrayY[yId] * size;
							var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
							var height = dashArrayY[yId] * decalOpt.symbolSize;
							var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
							brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
						}
						x += dashArrayX[xId0][xId1];
						++xId1Total;
						++xId1;
						if (xId1 === dashArrayX[xId0].length) xId1 = 0;
					}
					++xId0;
					if (xId0 === dashArrayX.length) xId0 = 0;
				}
				y += dashArrayY[yId];
				++yIdTotal;
				++yId;
				if (yId === dashArrayY.length) yId = 0;
			}
			function brushSymbol(x$1, y$1, width$1, height$1, symbolType) {
				var scale$2 = isSVG ? 1 : dpr;
				var symbol = createSymbol(symbolType, x$1 * scale$2, y$1 * scale$2, width$1 * scale$2, height$1 * scale$2, decalOpt.color, decalOpt.symbolKeepAspect);
				if (isSVG) {
					var symbolVNode = zr.painter.renderOneToVNode(symbol);
					if (symbolVNode) svgRoot.children.push(symbolVNode);
				} else brushSingle(ctx, symbol);
			}
		}
	}
}
/**
* Convert symbol array into normalized array
*
* @param {string | (string | string[])[]} symbol symbol input
* @return {string[][]} normolized symbol array
*/
function normalizeSymbolArray(symbol) {
	if (!symbol || symbol.length === 0) return [["rect"]];
	if (isString(symbol)) return [[symbol]];
	var isAllString = true;
	for (var i = 0; i < symbol.length; ++i) if (!isString(symbol[i])) {
		isAllString = false;
		break;
	}
	if (isAllString) return normalizeSymbolArray([symbol]);
	var result = [];
	for (var i = 0; i < symbol.length; ++i) if (isString(symbol[i])) result.push([symbol[i]]);
	else result.push(symbol[i]);
	return result;
}
/**
* Convert dash input into dashArray
*
* @param {DecalDashArrayX} dash dash input
* @return {number[][]} normolized dash array
*/
function normalizeDashArrayX(dash) {
	if (!dash || dash.length === 0) return [[0, 0]];
	if (isNumber(dash)) {
		var dashValue = Math.ceil(dash);
		return [[dashValue, dashValue]];
	}
	/**
	* [20, 5] should be normalized into [[20, 5]],
	* while [20, [5, 10]] should be normalized into [[20, 20], [5, 10]]
	*/
	var isAllNumber = true;
	for (var i = 0; i < dash.length; ++i) if (!isNumber(dash[i])) {
		isAllNumber = false;
		break;
	}
	if (isAllNumber) return normalizeDashArrayX([dash]);
	var result = [];
	for (var i = 0; i < dash.length; ++i) if (isNumber(dash[i])) {
		var dashValue = Math.ceil(dash[i]);
		result.push([dashValue, dashValue]);
	} else {
		var dashValue = map$1(dash[i], function(n) {
			return Math.ceil(n);
		});
		if (dashValue.length % 2 === 1) result.push(dashValue.concat(dashValue));
		else result.push(dashValue);
	}
	return result;
}
/**
* Convert dash input into dashArray
*
* @param {DecalDashArrayY} dash dash input
* @return {number[]} normolized dash array
*/
function normalizeDashArrayY(dash) {
	if (!dash || typeof dash === "object" && dash.length === 0) return [0, 0];
	if (isNumber(dash)) {
		var dashValue_1 = Math.ceil(dash);
		return [dashValue_1, dashValue_1];
	}
	var dashValue = map$1(dash, function(n) {
		return Math.ceil(n);
	});
	return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
/**
* Get block length of each line. A block is the length of dash line and space.
* For example, a line with [4, 1] has a dash line of 4 and a space of 1 after
* that, so the block length of this line is 5.
*
* @param {number[][]} dash dash array of X or Y
* @return {number[]} block length of each line
*/
function getLineBlockLengthX(dash) {
	return map$1(dash, function(line) {
		return getLineBlockLengthY(line);
	});
}
function getLineBlockLengthY(dash) {
	var blockLength = 0;
	for (var i = 0; i < dash.length; ++i) blockLength += dash[i];
	if (dash.length % 2 === 1) return blockLength * 2;
	return blockLength;
}

//#endregion
//#region node_modules/echarts/lib/visual/decal.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function decalVisual(ecModel, api) {
	ecModel.eachRawSeries(function(seriesModel) {
		if (ecModel.isSeriesFiltered(seriesModel)) return;
		var data = seriesModel.getData();
		if (data.hasItemVisual()) data.each(function(idx) {
			var decal$1 = data.getItemVisual(idx, "decal");
			if (decal$1) {
				var itemStyle = data.ensureUniqueItemVisual(idx, "style");
				itemStyle.decal = createOrUpdatePatternFromDecal(decal$1, api);
			}
		});
		var decal = data.getVisual("decal");
		if (decal) {
			var style = data.getVisual("style");
			style.decal = createOrUpdatePatternFromDecal(decal, api);
		}
	});
}

//#endregion
//#region node_modules/echarts/lib/core/lifecycle.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var lifecycle = new Eventful_default();
var lifecycle_default = lifecycle;

//#endregion
//#region node_modules/echarts/lib/core/impl.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var implsStore = {};
function registerImpl(name, impl) {
	if (implsStore[name]) error("Already has an implementation of " + name + ".");
	implsStore[name] = impl;
}
function getImpl(name) {
	if (!implsStore[name]) error("Implementation of " + name + " doesn't exists.");
	return implsStore[name];
}

//#endregion
//#region node_modules/echarts/lib/chart/custom/customSeriesRegister.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var customRenderers = {};
function registerCustomSeries(type, renderItem) {
	customRenderers[type] = renderItem;
}
function getCustomSeries(type) {
	return customRenderers[type];
}

//#endregion
//#region node_modules/echarts/lib/core/echarts.js
init_tslib_es6();
var version = "6.0.0";
var dependencies = { zrender: "6.0.0" };
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1e3;
var PRIORITY_PROCESSOR_DEFAULT = 2e3;
var PRIORITY_PROCESSOR_STATISTIC = 5e3;
var PRIORITY_VISUAL_LAYOUT = 1e3;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2e3;
var PRIORITY_VISUAL_CHART = 3e3;
var PRIORITY_VISUAL_COMPONENT = 4e3;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5e3;
var PRIORITY_VISUAL_ARIA = 6e3;
var PRIORITY_VISUAL_DECAL = 7e3;
var PRIORITY = {
	PROCESSOR: {
		FILTER: PRIORITY_PROCESSOR_FILTER,
		SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
		STATISTIC: PRIORITY_PROCESSOR_STATISTIC
	},
	VISUAL: {
		LAYOUT: PRIORITY_VISUAL_LAYOUT,
		PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
		GLOBAL: PRIORITY_VISUAL_GLOBAL,
		CHART: PRIORITY_VISUAL_CHART,
		POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
		COMPONENT: PRIORITY_VISUAL_COMPONENT,
		BRUSH: PRIORITY_VISUAL_BRUSH,
		CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
		ARIA: PRIORITY_VISUAL_ARIA,
		DECAL: PRIORITY_VISUAL_DECAL
	}
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var MAIN_PROCESS_VERSION_KEY = "__mainProcessVersion";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = "__connectUpdateStatus";
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(method) {
	return function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		if (this.isDisposed()) {
			disposedWarning(this.id);
			return;
		}
		return toLowercaseNameAndCallEventful(this, method, args);
	};
}
function createRegisterEventWithLowercaseMessageCenter(method) {
	return function() {
		var args = [];
		for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
		return toLowercaseNameAndCallEventful(this, method, args);
	};
}
function toLowercaseNameAndCallEventful(host, method, args) {
	args[0] = args[0] && args[0].toLowerCase();
	return Eventful_default.prototype[method].apply(host, args);
}
var MessageCenter = function(_super) {
	__extends(MessageCenter$1, _super);
	function MessageCenter$1() {
		return _super !== null && _super.apply(this, arguments) || this;
	}
	return MessageCenter$1;
}(Eventful_default);
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;
var updateMainProcessVersion;
var ECharts = function(_super) {
	__extends(ECharts$1, _super);
	function ECharts$1(dom, theme$1, opts) {
		var _this = _super.call(this, new ECEventProcessor()) || this;
		_this._chartsViews = [];
		_this._chartsMap = {};
		_this._componentsViews = [];
		_this._componentsMap = {};
		_this._pendingActions = [];
		opts = opts || {};
		_this._dom = dom;
		var defaultRenderer = "canvas";
		var defaultCoarsePointer = "auto";
		var defaultUseDirtyRect = false;
		_this[MAIN_PROCESS_VERSION_KEY] = 1;
		var root = env_default.hasGlobalWindow ? window : global;
		if (root) {
			defaultRenderer = retrieve2(root.__ECHARTS__DEFAULT__RENDERER__, defaultRenderer);
			defaultCoarsePointer = retrieve2(root.__ECHARTS__DEFAULT__COARSE_POINTER, defaultCoarsePointer);
			defaultUseDirtyRect = retrieve2(root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, defaultUseDirtyRect);
		}
		if (opts.ssr) registerSSRDataGetter(function(el) {
			var ecData = getECData(el);
			var dataIndex = ecData.dataIndex;
			if (dataIndex == null) return;
			var hashMap = createHashMap();
			hashMap.set("series_index", ecData.seriesIndex);
			hashMap.set("data_index", dataIndex);
			ecData.ssrType && hashMap.set("ssr_type", ecData.ssrType);
			return hashMap;
		});
		var zr = _this._zr = init$1(dom, {
			renderer: opts.renderer || defaultRenderer,
			devicePixelRatio: opts.devicePixelRatio,
			width: opts.width,
			height: opts.height,
			ssr: opts.ssr,
			useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
			useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
			pointerSize: opts.pointerSize
		});
		_this._ssr = opts.ssr;
		_this._throttledZrFlush = throttle(bind(zr.flush, zr), 17);
		_this._updateTheme(theme$1);
		_this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
		_this._coordSysMgr = new CoordinateSystem_default();
		var api = _this._api = createExtensionAPI(_this);
		function prioritySortFunc(a, b) {
			return a.__prio - b.__prio;
		}
		sort(visualFuncs, prioritySortFunc);
		sort(dataProcessorFuncs, prioritySortFunc);
		_this._scheduler = new Scheduler_default(_this, api, dataProcessorFuncs, visualFuncs);
		_this._messageCenter = new MessageCenter();
		_this._initEvents();
		_this.resize = bind(_this.resize, _this);
		zr.animation.on("frame", _this._onframe, _this);
		bindRenderedEvent(zr, _this);
		bindMouseEvent(zr, _this);
		setAsPrimitive(_this);
		return _this;
	}
	ECharts$1.prototype._onframe = function() {
		if (this._disposed) return;
		applyChangedStates(this);
		var scheduler = this._scheduler;
		if (this[PENDING_UPDATE]) {
			var silent = this[PENDING_UPDATE].silent;
			this[IN_MAIN_PROCESS_KEY] = true;
			updateMainProcessVersion(this);
			try {
				prepare(this);
				updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
			} catch (e$1) {
				this[IN_MAIN_PROCESS_KEY] = false;
				this[PENDING_UPDATE] = null;
				throw e$1;
			}
			this._zr.flush();
			this[IN_MAIN_PROCESS_KEY] = false;
			this[PENDING_UPDATE] = null;
			flushPendingActions.call(this, silent);
			triggerUpdatedEvent.call(this, silent);
		} else if (scheduler.unfinished) {
			var remainTime = TEST_FRAME_REMAIN_TIME;
			var ecModel = this._model;
			var api = this._api;
			scheduler.unfinished = false;
			do {
				var startTime = +/* @__PURE__ */ new Date();
				scheduler.performSeriesTasks(ecModel);
				scheduler.performDataProcessorTasks(ecModel);
				updateStreamModes(this, ecModel);
				scheduler.performVisualTasks(ecModel);
				renderSeries(this, this._model, api, "remain", {});
				remainTime -= +/* @__PURE__ */ new Date() - startTime;
			} while (remainTime > 0 && scheduler.unfinished);
			if (!scheduler.unfinished) this._zr.flush();
		}
	};
	ECharts$1.prototype.getDom = function() {
		return this._dom;
	};
	ECharts$1.prototype.getId = function() {
		return this.id;
	};
	ECharts$1.prototype.getZr = function() {
		return this._zr;
	};
	ECharts$1.prototype.isSSR = function() {
		return this._ssr;
	};
	ECharts$1.prototype.setOption = function(option, notMerge, lazyUpdate) {
		if (this[IN_MAIN_PROCESS_KEY]) {
			error("`setOption` should not be called during main process.");
			return;
		}
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var silent;
		var replaceMerge;
		var transitionOpt;
		if (isObject$1(notMerge)) {
			lazyUpdate = notMerge.lazyUpdate;
			silent = notMerge.silent;
			replaceMerge = notMerge.replaceMerge;
			transitionOpt = notMerge.transition;
			notMerge = notMerge.notMerge;
		}
		this[IN_MAIN_PROCESS_KEY] = true;
		updateMainProcessVersion(this);
		if (!this._model || notMerge) {
			var optionManager = new OptionManager_default(this._api);
			var theme$1 = this._theme;
			var ecModel = this._model = new Global_default();
			ecModel.scheduler = this._scheduler;
			ecModel.ssr = this._ssr;
			ecModel.init(null, null, null, theme$1, this._locale, optionManager);
		}
		this._model.setOption(option, { replaceMerge }, optionPreprocessorFuncs);
		var updateParams = {
			seriesTransition: transitionOpt,
			optionChanged: true
		};
		if (lazyUpdate) {
			this[PENDING_UPDATE] = {
				silent,
				updateParams
			};
			this[IN_MAIN_PROCESS_KEY] = false;
			this.getZr().wakeUp();
		} else {
			try {
				prepare(this);
				updateMethods.update.call(this, null, updateParams);
			} catch (e$1) {
				this[PENDING_UPDATE] = null;
				this[IN_MAIN_PROCESS_KEY] = false;
				throw e$1;
			}
			if (!this._ssr) this._zr.flush();
			this[PENDING_UPDATE] = null;
			this[IN_MAIN_PROCESS_KEY] = false;
			flushPendingActions.call(this, silent);
			triggerUpdatedEvent.call(this, silent);
		}
	};
	/**
	* Update theme with name or theme option and repaint the chart.
	* @param theme Theme name or theme option.
	* @param opts Optional settings
	*/
	ECharts$1.prototype.setTheme = function(theme$1, opts) {
		if (this[IN_MAIN_PROCESS_KEY]) {
			error("`setTheme` should not be called during main process.");
			return;
		}
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var ecModel = this._model;
		if (!ecModel) return;
		var silent = opts && opts.silent;
		var updateParams = null;
		if (this[PENDING_UPDATE]) {
			if (silent == null) silent = this[PENDING_UPDATE].silent;
			updateParams = this[PENDING_UPDATE].updateParams;
			this[PENDING_UPDATE] = null;
		}
		this[IN_MAIN_PROCESS_KEY] = true;
		updateMainProcessVersion(this);
		try {
			this._updateTheme(theme$1);
			ecModel.setTheme(this._theme);
			prepare(this);
			updateMethods.update.call(this, { type: "setTheme" }, updateParams);
		} catch (e$1) {
			this[IN_MAIN_PROCESS_KEY] = false;
			throw e$1;
		}
		this[IN_MAIN_PROCESS_KEY] = false;
		flushPendingActions.call(this, silent);
		triggerUpdatedEvent.call(this, silent);
	};
	ECharts$1.prototype._updateTheme = function(theme$1) {
		if (isString(theme$1)) theme$1 = themeStorage[theme$1];
		if (theme$1) {
			theme$1 = clone(theme$1);
			theme$1 && globalBackwardCompat(theme$1, true);
			this._theme = theme$1;
		}
	};
	ECharts$1.prototype.getModel = function() {
		return this._model;
	};
	ECharts$1.prototype.getOption = function() {
		return this._model && this._model.getOption();
	};
	ECharts$1.prototype.getWidth = function() {
		return this._zr.getWidth();
	};
	ECharts$1.prototype.getHeight = function() {
		return this._zr.getHeight();
	};
	ECharts$1.prototype.getDevicePixelRatio = function() {
		return this._zr.painter.dpr || env_default.hasGlobalWindow && window.devicePixelRatio || 1;
	};
	/**
	* Get canvas which has all thing rendered
	* @deprecated Use renderToCanvas instead.
	*/
	ECharts$1.prototype.getRenderedCanvas = function(opts) {
		deprecateReplaceLog("getRenderedCanvas", "renderToCanvas");
		return this.renderToCanvas(opts);
	};
	ECharts$1.prototype.renderToCanvas = function(opts) {
		opts = opts || {};
		var painter = this._zr.painter;
		if (painter.type !== "canvas") throw new Error("renderToCanvas can only be used in the canvas renderer.");
		return painter.getRenderedCanvas({
			backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
			pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
		});
	};
	ECharts$1.prototype.renderToSVGString = function(opts) {
		opts = opts || {};
		var painter = this._zr.painter;
		if (painter.type !== "svg") throw new Error("renderToSVGString can only be used in the svg renderer.");
		return painter.renderToString({ useViewBox: opts.useViewBox });
	};
	/**
	* Get svg data url
	*/
	ECharts$1.prototype.getSvgDataURL = function() {
		var zr = this._zr;
		each(zr.storage.getDisplayList(), function(el) {
			el.stopAnimation(null, true);
		});
		return zr.painter.toDataURL();
	};
	ECharts$1.prototype.getDataURL = function(opts) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		opts = opts || {};
		var excludeComponents = opts.excludeComponents;
		var ecModel = this._model;
		var excludesComponentViews = [];
		var self = this;
		each(excludeComponents, function(componentType) {
			ecModel.eachComponent({ mainType: componentType }, function(component) {
				var view = self._componentsMap[component.__viewId];
				if (!view.group.ignore) {
					excludesComponentViews.push(view);
					view.group.ignore = true;
				}
			});
		});
		var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
		each(excludesComponentViews, function(view) {
			view.group.ignore = false;
		});
		return url;
	};
	ECharts$1.prototype.getConnectedDataURL = function(opts) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var isSvg = opts.type === "svg";
		var groupId = this.group;
		var mathMin$3 = Math.min;
		var mathMax$3 = Math.max;
		var MAX_NUMBER = Infinity;
		if (connectedGroups[groupId]) {
			var left_1 = MAX_NUMBER;
			var top_1 = MAX_NUMBER;
			var right_1 = -MAX_NUMBER;
			var bottom_1 = -MAX_NUMBER;
			var canvasList_1 = [];
			var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
			each(instances, function(chart, id) {
				if (chart.group === groupId) {
					var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone(opts));
					var boundingRect = chart.getDom().getBoundingClientRect();
					left_1 = mathMin$3(boundingRect.left, left_1);
					top_1 = mathMin$3(boundingRect.top, top_1);
					right_1 = mathMax$3(boundingRect.right, right_1);
					bottom_1 = mathMax$3(boundingRect.bottom, bottom_1);
					canvasList_1.push({
						dom: canvas,
						left: boundingRect.left,
						top: boundingRect.top
					});
				}
			});
			left_1 *= dpr_1;
			top_1 *= dpr_1;
			right_1 *= dpr_1;
			bottom_1 *= dpr_1;
			var width = right_1 - left_1;
			var height = bottom_1 - top_1;
			var targetCanvas = platformApi.createCanvas();
			var zr_1 = init$1(targetCanvas, { renderer: isSvg ? "svg" : "canvas" });
			zr_1.resize({
				width,
				height
			});
			if (isSvg) {
				var content_1 = "";
				each(canvasList_1, function(item) {
					var x = item.left - left_1;
					var y = item.top - top_1;
					content_1 += "<g transform=\"translate(" + x + "," + y + ")\">" + item.dom + "</g>";
				});
				zr_1.painter.getSvgRoot().innerHTML = content_1;
				if (opts.connectedBackgroundColor) zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
				zr_1.refreshImmediately();
				return zr_1.painter.toDataURL();
			} else {
				if (opts.connectedBackgroundColor) zr_1.add(new Rect_default({
					shape: {
						x: 0,
						y: 0,
						width,
						height
					},
					style: { fill: opts.connectedBackgroundColor }
				}));
				each(canvasList_1, function(item) {
					var img = new Image_default({ style: {
						x: item.left * dpr_1 - left_1,
						y: item.top * dpr_1 - top_1,
						image: item.dom
					} });
					zr_1.add(img);
				});
				zr_1.refreshImmediately();
				return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
			}
		} else return this.getDataURL(opts);
	};
	ECharts$1.prototype.convertToPixel = function(finder, value, opt) {
		return doConvertPixel(this, "convertToPixel", finder, value, opt);
	};
	/**
	* Convert from logical coordinate system to pixel coordinate system.
	* See CoordinateSystem#convertToPixel.
	*
	* @see CoordinateSystem['dataToLayout'] for parameters and return.
	* @see CoordinateSystemDataCoord
	*/
	ECharts$1.prototype.convertToLayout = function(finder, value, opt) {
		return doConvertPixel(this, "convertToLayout", finder, value, opt);
	};
	ECharts$1.prototype.convertFromPixel = function(finder, value, opt) {
		return doConvertPixel(this, "convertFromPixel", finder, value, opt);
	};
	/**
	* Is the specified coordinate systems or components contain the given pixel point.
	* @param {Array|number} value
	* @return {boolean} result
	*/
	ECharts$1.prototype.containPixel = function(finder, value) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var ecModel = this._model;
		var result;
		each(parseFinder(ecModel, finder), function(models, key$1) {
			key$1.indexOf("Models") >= 0 && each(models, function(model) {
				var coordSys = model.coordinateSystem;
				if (coordSys && coordSys.containPoint) result = result || !!coordSys.containPoint(value);
				else if (key$1 === "seriesModels") {
					var view = this._chartsMap[model.__viewId];
					if (view && view.containPoint) result = result || view.containPoint(value, model);
					else warn(key$1 + ": " + (view ? "The found component do not support containPoint." : "No view mapping to the found component."));
				} else warn(key$1 + ": containPoint is not supported");
			}, this);
		}, this);
		return !!result;
	};
	/**
	* Get visual from series or data.
	* @param finder
	*        If string, e.g., 'series', means {seriesIndex: 0}.
	*        If Object, could contain some of these properties below:
	*        {
	*            seriesIndex / seriesId / seriesName,
	*            dataIndex / dataIndexInside
	*        }
	*        If dataIndex is not specified, series visual will be fetched,
	*        but not data item visual.
	*        If all of seriesIndex, seriesId, seriesName are not specified,
	*        visual will be fetched from first series.
	* @param visualType 'color', 'symbol', 'symbolSize'
	*/
	ECharts$1.prototype.getVisual = function(finder, visualType) {
		var ecModel = this._model;
		var parsedFinder = parseFinder(ecModel, finder, { defaultMainType: "series" });
		var seriesModel = parsedFinder.seriesModel;
		if (!seriesModel) warn("There is no specified series model");
		var data = seriesModel.getData();
		var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
		return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
	};
	/**
	* Get view of corresponding component model
	*/
	ECharts$1.prototype.getViewOfComponentModel = function(componentModel) {
		return this._componentsMap[componentModel.__viewId];
	};
	/**
	* Get view of corresponding series model
	*/
	ECharts$1.prototype.getViewOfSeriesModel = function(seriesModel) {
		return this._chartsMap[seriesModel.__viewId];
	};
	ECharts$1.prototype._initEvents = function() {
		var _this = this;
		each(MOUSE_EVENT_NAMES, function(eveName) {
			var handler = function(e$1) {
				var ecModel = _this.getModel();
				var el = e$1.target;
				var params;
				var isGlobalOut = eveName === "globalout";
				if (isGlobalOut) params = {};
				else el && findEventDispatcher(el, function(parent) {
					var ecData = getECData(parent);
					if (ecData && ecData.dataIndex != null) {
						var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
						params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType, el) || {};
						return true;
					} else if (ecData.eventData) {
						params = extend({}, ecData.eventData);
						return true;
					}
				}, true);
				if (params) {
					var componentType = params.componentType;
					var componentIndex = params.componentIndex;
					if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
						componentType = "series";
						componentIndex = params.seriesIndex;
					}
					var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
					var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
					if (!isGlobalOut && !(model && view)) warn("model or view can not be found by params");
					params.event = e$1;
					params.type = eveName;
					_this._$eventProcessor.eventInfo = {
						targetEl: el,
						packedEvent: params,
						model,
						view
					};
					_this.trigger(eveName, params);
				}
			};
			handler.zrEventfulCallAtLast = true;
			_this._zr.on(eveName, handler, _this);
		});
		var messageCenter = this._messageCenter;
		each(publicEventTypeMap, function(_, eventType) {
			messageCenter.on(eventType, function(event) {
				_this.trigger(eventType, event);
			});
		});
		handleLegacySelectEvents(messageCenter, this, this._api);
	};
	ECharts$1.prototype.isDisposed = function() {
		return this._disposed;
	};
	ECharts$1.prototype.clear = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this.setOption({ series: [] }, true);
	};
	ECharts$1.prototype.dispose = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._disposed = true;
		if (this.getDom()) setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
		var chart = this;
		var api = chart._api;
		var ecModel = chart._model;
		each(chart._componentsViews, function(component) {
			component.dispose(ecModel, api);
		});
		each(chart._chartsViews, function(chart$1) {
			chart$1.dispose(ecModel, api);
		});
		chart._zr.dispose();
		chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
		delete instances[chart.id];
	};
	/**
	* Resize the chart
	*/
	ECharts$1.prototype.resize = function(opts) {
		if (this[IN_MAIN_PROCESS_KEY]) {
			error("`resize` should not be called during main process.");
			return;
		}
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._zr.resize(opts);
		var ecModel = this._model;
		this._loadingFX && this._loadingFX.resize();
		if (!ecModel) return;
		var needPrepare = ecModel.resetOption("media");
		var silent = opts && opts.silent;
		if (this[PENDING_UPDATE]) {
			if (silent == null) silent = this[PENDING_UPDATE].silent;
			needPrepare = true;
			this[PENDING_UPDATE] = null;
		}
		this[IN_MAIN_PROCESS_KEY] = true;
		updateMainProcessVersion(this);
		try {
			needPrepare && prepare(this);
			updateMethods.update.call(this, {
				type: "resize",
				animation: extend({ duration: 0 }, opts && opts.animation)
			});
		} catch (e$1) {
			this[IN_MAIN_PROCESS_KEY] = false;
			throw e$1;
		}
		this[IN_MAIN_PROCESS_KEY] = false;
		flushPendingActions.call(this, silent);
		triggerUpdatedEvent.call(this, silent);
	};
	ECharts$1.prototype.showLoading = function(name, cfg) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		if (isObject$1(name)) {
			cfg = name;
			name = "";
		}
		name = name || "default";
		this.hideLoading();
		if (!loadingEffects[name]) {
			warn("Loading effects " + name + " not exists.");
			return;
		}
		var el = loadingEffects[name](this._api, cfg);
		var zr = this._zr;
		this._loadingFX = el;
		zr.add(el);
	};
	/**
	* Hide loading effect
	*/
	ECharts$1.prototype.hideLoading = function() {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		this._loadingFX && this._zr.remove(this._loadingFX);
		this._loadingFX = null;
	};
	ECharts$1.prototype.makeActionFromEvent = function(eventObj) {
		var payload = extend({}, eventObj);
		payload.type = connectionEventRevertMap[eventObj.type];
		return payload;
	};
	/**
	* @param opt If pass boolean, means opt.silent
	* @param opt.silent Default `false`. Whether trigger events.
	* @param opt.flush Default `undefined`.
	*        true: Flush immediately, and then pixel in canvas can be fetched
	*            immediately. Caution: it might affect performance.
	*        false: Not flush.
	*        undefined: Auto decide whether perform flush.
	*/
	ECharts$1.prototype.dispatchAction = function(payload, opt) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		if (!isObject$1(opt)) opt = { silent: !!opt };
		if (!actions[payload.type]) return;
		if (!this._model) return;
		if (this[IN_MAIN_PROCESS_KEY]) {
			this._pendingActions.push(payload);
			return;
		}
		var silent = opt.silent;
		doDispatchAction.call(this, payload, silent);
		var flush = opt.flush;
		if (flush) this._zr.flush();
		else if (flush !== false && env_default.browser.weChat) this._throttledZrFlush();
		flushPendingActions.call(this, silent);
		triggerUpdatedEvent.call(this, silent);
	};
	ECharts$1.prototype.updateLabelLayout = function() {
		lifecycle_default.trigger("series:layoutlabels", this._model, this._api, { updatedSeries: [] });
	};
	ECharts$1.prototype.appendData = function(params) {
		if (this._disposed) {
			disposedWarning(this.id);
			return;
		}
		var seriesIndex = params.seriesIndex;
		var seriesModel = this.getModel().getSeriesByIndex(seriesIndex);
		assert(params.data && seriesModel);
		seriesModel.appendData(params);
		this._scheduler.unfinished = true;
		this.getZr().wakeUp();
	};
	ECharts$1.internalField = function() {
		prepare = function(ecIns) {
			var scheduler = ecIns._scheduler;
			scheduler.restorePipelines(ecIns._model);
			scheduler.prepareStageTasks();
			prepareView(ecIns, true);
			prepareView(ecIns, false);
			scheduler.plan();
		};
		/**
		* Prepare view instances of charts and components
		*/
		prepareView = function(ecIns, isComponent) {
			var ecModel = ecIns._model;
			var scheduler = ecIns._scheduler;
			var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
			var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
			var zr = ecIns._zr;
			var api = ecIns._api;
			for (var i = 0; i < viewList.length; i++) viewList[i].__alive = false;
			isComponent ? ecModel.eachComponent(function(componentType, model) {
				componentType !== "series" && doPrepare(model);
			}) : ecModel.eachSeries(doPrepare);
			function doPrepare(model) {
				var requireNewView = model.__requireNewView;
				model.__requireNewView = false;
				var viewId = "_ec_" + model.id + "_" + model.type;
				var view$1 = !requireNewView && viewMap[viewId];
				if (!view$1) {
					var classType = parseClassType(model.type);
					var Clazz = isComponent ? Component_default.getClass(classType.main, classType.sub) : Chart_default.getClass(classType.sub);
					assert(Clazz, classType.sub + " does not exist.");
					view$1 = new Clazz();
					view$1.init(ecModel, api);
					viewMap[viewId] = view$1;
					viewList.push(view$1);
					zr.add(view$1.group);
				}
				model.__viewId = view$1.__id = viewId;
				view$1.__alive = true;
				view$1.__model = model;
				view$1.group.__ecComponentInfo = {
					mainType: model.mainType,
					index: model.componentIndex
				};
				!isComponent && scheduler.prepareView(view$1, model, ecModel, api);
			}
			for (var i = 0; i < viewList.length;) {
				var view = viewList[i];
				if (!view.__alive) {
					!isComponent && view.renderTask.dispose();
					zr.remove(view.group);
					view.dispose(ecModel, api);
					viewList.splice(i, 1);
					if (viewMap[view.__id] === view) delete viewMap[view.__id];
					view.__id = view.group.__ecComponentInfo = null;
				} else i++;
			}
		};
		updateDirectly = function(ecIns, method, payload, mainType, subType) {
			var ecModel = ecIns._model;
			ecModel.setUpdatePayload(payload);
			if (!mainType) {
				each([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
				return;
			}
			var query = {};
			query[mainType + "Id"] = payload[mainType + "Id"];
			query[mainType + "Index"] = payload[mainType + "Index"];
			query[mainType + "Name"] = payload[mainType + "Name"];
			var condition = {
				mainType,
				query
			};
			subType && (condition.subType = subType);
			var excludeSeriesId = payload.excludeSeriesId;
			var excludeSeriesIdMap;
			if (excludeSeriesId != null) {
				excludeSeriesIdMap = createHashMap();
				each(normalizeToArray(excludeSeriesId), function(id) {
					var modelId = convertOptionIdName(id, null);
					if (modelId != null) excludeSeriesIdMap.set(modelId, true);
				});
			}
			ecModel && ecModel.eachComponent(condition, function(model) {
				if (excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null) return;
				if (isHighDownPayload(payload)) if (model instanceof Series_default) {
					if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) blurSeriesFromHighlightPayload(model, payload, ecIns._api);
				} else {
					var _a$1 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a$1.focusSelf, dispatchers = _a$1.dispatchers;
					if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) blurComponent(model.mainType, model.componentIndex, ecIns._api);
					if (dispatchers) each(dispatchers, function(dispatcher) {
						payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
					});
				}
				else if (isSelectChangePayload(payload)) {
					if (model instanceof Series_default) {
						toggleSelectionFromPayload(model, payload, ecIns._api);
						updateSeriesElementSelection(model);
						markStatusToUpdate(ecIns);
					}
				}
			}, ecIns);
			ecModel && ecModel.eachComponent(condition, function(model) {
				if (excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null) return;
				callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
			}, ecIns);
			function callView(view) {
				view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
			}
		};
		updateMethods = {
			prepareAndUpdate: function(payload) {
				prepare(this);
				updateMethods.update.call(this, payload, payload && { optionChanged: payload.newOption != null });
			},
			update: function(payload, updateParams) {
				var ecModel = this._model;
				var api = this._api;
				var zr = this._zr;
				var coordSysMgr = this._coordSysMgr;
				var scheduler = this._scheduler;
				if (!ecModel) return;
				ecModel.setUpdatePayload(payload);
				scheduler.restoreData(ecModel, payload);
				scheduler.performSeriesTasks(ecModel);
				coordSysMgr.create(ecModel, api);
				scheduler.performDataProcessorTasks(ecModel, payload);
				updateStreamModes(this, ecModel);
				coordSysMgr.update(ecModel, api);
				clearColorPalette(ecModel);
				scheduler.performVisualTasks(ecModel, payload);
				var backgroundColor$1 = ecModel.get("backgroundColor") || "transparent";
				zr.setBackgroundColor(backgroundColor$1);
				var darkMode = ecModel.get("darkMode");
				if (darkMode != null && darkMode !== "auto") zr.setDarkMode(darkMode);
				render(this, ecModel, api, payload, updateParams);
				lifecycle_default.trigger("afterupdate", ecModel, api);
			},
			updateTransform: function(payload) {
				var _this = this;
				var ecModel = this._model;
				var api = this._api;
				if (!ecModel) return;
				ecModel.setUpdatePayload(payload);
				var componentDirtyList = [];
				ecModel.eachComponent(function(componentType, componentModel) {
					if (componentType === "series") return;
					var componentView = _this.getViewOfComponentModel(componentModel);
					if (componentView && componentView.__alive) if (componentView.updateTransform) {
						var result = componentView.updateTransform(componentModel, ecModel, api, payload);
						result && result.update && componentDirtyList.push(componentView);
					} else componentDirtyList.push(componentView);
				});
				var seriesDirtyMap = createHashMap();
				ecModel.eachSeries(function(seriesModel) {
					var chartView = _this._chartsMap[seriesModel.__viewId];
					if (chartView.updateTransform) {
						var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
						result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
					} else seriesDirtyMap.set(seriesModel.uid, 1);
				});
				clearColorPalette(ecModel);
				this._scheduler.performVisualTasks(ecModel, payload, {
					setDirty: true,
					dirtyMap: seriesDirtyMap
				});
				renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
				lifecycle_default.trigger("afterupdate", ecModel, api);
			},
			updateView: function(payload) {
				var ecModel = this._model;
				if (!ecModel) return;
				ecModel.setUpdatePayload(payload);
				Chart_default.markUpdateMethod(payload, "updateView");
				clearColorPalette(ecModel);
				this._scheduler.performVisualTasks(ecModel, payload, { setDirty: true });
				render(this, ecModel, this._api, payload, {});
				lifecycle_default.trigger("afterupdate", ecModel, this._api);
			},
			updateVisual: function(payload) {
				var _this = this;
				var ecModel = this._model;
				if (!ecModel) return;
				ecModel.setUpdatePayload(payload);
				ecModel.eachSeries(function(seriesModel) {
					seriesModel.getData().clearAllVisual();
				});
				Chart_default.markUpdateMethod(payload, "updateVisual");
				clearColorPalette(ecModel);
				this._scheduler.performVisualTasks(ecModel, payload, {
					visualType: "visual",
					setDirty: true
				});
				ecModel.eachComponent(function(componentType, componentModel) {
					if (componentType !== "series") {
						var componentView = _this.getViewOfComponentModel(componentModel);
						componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
					}
				});
				ecModel.eachSeries(function(seriesModel) {
					_this._chartsMap[seriesModel.__viewId].updateVisual(seriesModel, ecModel, _this._api, payload);
				});
				lifecycle_default.trigger("afterupdate", ecModel, this._api);
			},
			updateLayout: function(payload) {
				updateMethods.update.call(this, payload);
			}
		};
		function doConvertPixelImpl(ecIns, methodName, finder, value, opt) {
			if (ecIns._disposed) {
				disposedWarning(ecIns.id);
				return;
			}
			var ecModel = ecIns._model;
			var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
			var result;
			var parsedFinder = parseFinder(ecModel, finder);
			for (var i = 0; i < coordSysList.length; i++) {
				var coordSys = coordSysList[i];
				if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value, opt)) != null) return result;
			}
			warn("No coordinate system that supports " + methodName + " found by the given finder.");
		}
		doConvertPixel = doConvertPixelImpl;
		updateStreamModes = function(ecIns, ecModel) {
			var chartsMap = ecIns._chartsMap;
			var scheduler = ecIns._scheduler;
			ecModel.eachSeries(function(seriesModel) {
				scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
			});
		};
		doDispatchAction = function(payload, silent) {
			var _this = this;
			var ecModel = this.getModel();
			var payloadType = payload.type;
			var escapeConnect = payload.escapeConnect;
			var actionInfo = actions[payloadType];
			var cptTypeTmp = (actionInfo.update || "update").split(":");
			var updateMethod = cptTypeTmp.pop();
			var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
			this[IN_MAIN_PROCESS_KEY] = true;
			updateMainProcessVersion(this);
			var payloads = [payload];
			var batched = false;
			if (payload.batch) {
				batched = true;
				payloads = map$1(payload.batch, function(item) {
					item = defaults(extend({}, item), payload);
					item.batch = null;
					return item;
				});
			}
			var eventObjBatch = [];
			var eventObj;
			var actionResultBatch = [];
			var nonRefinedEventType = actionInfo.nonRefinedEventType;
			var isSelectChange = isSelectChangePayload(payload);
			var isHighDown = isHighDownPayload(payload);
			if (isHighDown) allLeaveBlur(this._api);
			each(payloads, function(batchItem) {
				var actionResult = actionInfo.action(batchItem, ecModel, _this._api);
				if (actionInfo.refineEvent) actionResultBatch.push(actionResult);
				else eventObj = actionResult;
				eventObj = eventObj || extend({}, batchItem);
				eventObj.type = nonRefinedEventType;
				eventObjBatch.push(eventObj);
				if (isHighDown) {
					var _a$1 = preParseFinder(payload), queryOptionMap = _a$1.queryOptionMap;
					var componentMainType = _a$1.mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
					updateDirectly(_this, updateMethod, batchItem, componentMainType);
					markStatusToUpdate(_this);
				} else if (isSelectChange) {
					updateDirectly(_this, updateMethod, batchItem, "series");
					markStatusToUpdate(_this);
				} else if (cptType) updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
			});
			if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) try {
				if (this[PENDING_UPDATE]) {
					prepare(this);
					updateMethods.update.call(this, payload);
					this[PENDING_UPDATE] = null;
				} else updateMethods[updateMethod].call(this, payload);
			} catch (e$1) {
				this[IN_MAIN_PROCESS_KEY] = false;
				throw e$1;
			}
			if (batched) eventObj = {
				type: nonRefinedEventType,
				escapeConnect,
				batch: eventObjBatch
			};
			else eventObj = eventObjBatch[0];
			this[IN_MAIN_PROCESS_KEY] = false;
			if (!silent) {
				var refinedEvent = void 0;
				if (actionInfo.refineEvent) {
					var eventContent = actionInfo.refineEvent(actionResultBatch, payload, ecModel, this._api).eventContent;
					assert(isObject$1(eventContent));
					refinedEvent = defaults({ type: actionInfo.refinedEventType }, eventContent);
					refinedEvent.fromAction = payload.type;
					refinedEvent.fromActionPayload = payload;
					refinedEvent.escapeConnect = true;
				}
				var messageCenter = this._messageCenter;
				messageCenter.trigger(eventObj.type, eventObj);
				if (refinedEvent) messageCenter.trigger(refinedEvent.type, refinedEvent);
			}
		};
		flushPendingActions = function(silent) {
			var pendingActions = this._pendingActions;
			while (pendingActions.length) {
				var payload = pendingActions.shift();
				doDispatchAction.call(this, payload, silent);
			}
		};
		triggerUpdatedEvent = function(silent) {
			!silent && this.trigger("updated");
		};
		/**
		* Event `rendered` is triggered when zr
		* rendered. It is useful for realtime
		* snapshot (reflect animation).
		*
		* Event `finished` is triggered when:
		* (1) zrender rendering finished.
		* (2) initial animation finished.
		* (3) progressive rendering finished.
		* (4) no pending action.
		* (5) no delayed setOption needs to be processed.
		*/
		bindRenderedEvent = function(zr, ecIns) {
			zr.on("rendered", function(params) {
				ecIns.trigger("rendered", params);
				if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) ecIns.trigger("finished");
			});
		};
		bindMouseEvent = function(zr, ecIns) {
			zr.on("mouseover", function(e$1) {
				var el = e$1.target;
				var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
				if (dispatcher) {
					handleGlobalMouseOverForHighDown(dispatcher, e$1, ecIns._api);
					markStatusToUpdate(ecIns);
				}
			}).on("mouseout", function(e$1) {
				var el = e$1.target;
				var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
				if (dispatcher) {
					handleGlobalMouseOutForHighDown(dispatcher, e$1, ecIns._api);
					markStatusToUpdate(ecIns);
				}
			}).on("click", function(e$1) {
				var el = e$1.target;
				var dispatcher = findEventDispatcher(el, function(target) {
					return getECData(target).dataIndex != null;
				}, true);
				if (dispatcher) {
					var actionType = dispatcher.selected ? "unselect" : "select";
					var ecData = getECData(dispatcher);
					ecIns._api.dispatchAction({
						type: actionType,
						dataType: ecData.dataType,
						dataIndexInside: ecData.dataIndex,
						seriesIndex: ecData.seriesIndex,
						isFromClick: true
					});
				}
			});
		};
		function clearColorPalette(ecModel) {
			ecModel.clearColorPalette();
			ecModel.eachSeries(function(seriesModel) {
				seriesModel.clearColorPalette();
			});
		}
		function allocateZlevels(ecModel) {
			var componentZLevels = [];
			var seriesZLevels = [];
			var hasSeparateZLevel = false;
			ecModel.eachComponent(function(componentType, componentModel) {
				var zlevel = componentModel.get("zlevel") || 0;
				var z = componentModel.get("z") || 0;
				var zlevelKey = componentModel.getZLevelKey();
				hasSeparateZLevel = hasSeparateZLevel || !!zlevelKey;
				(componentType === "series" ? seriesZLevels : componentZLevels).push({
					zlevel,
					z,
					idx: componentModel.componentIndex,
					type: componentType,
					key: zlevelKey
				});
			});
			if (hasSeparateZLevel) {
				var zLevels = componentZLevels.concat(seriesZLevels);
				var lastSeriesZLevel_1;
				var lastSeriesKey_1;
				sort(zLevels, function(a, b) {
					if (a.zlevel === b.zlevel) return a.z - b.z;
					return a.zlevel - b.zlevel;
				});
				each(zLevels, function(item) {
					var componentModel = ecModel.getComponent(item.type, item.idx);
					var zlevel = item.zlevel;
					var key$1 = item.key;
					if (lastSeriesZLevel_1 != null) zlevel = Math.max(lastSeriesZLevel_1, zlevel);
					if (key$1) {
						if (zlevel === lastSeriesZLevel_1 && key$1 !== lastSeriesKey_1) zlevel++;
						lastSeriesKey_1 = key$1;
					} else if (lastSeriesKey_1) {
						if (zlevel === lastSeriesZLevel_1) zlevel++;
						lastSeriesKey_1 = "";
					}
					lastSeriesZLevel_1 = zlevel;
					componentModel.setZLevel(zlevel);
				});
			}
		}
		render = function(ecIns, ecModel, api, payload, updateParams) {
			allocateZlevels(ecModel);
			renderComponents(ecIns, ecModel, api, payload, updateParams);
			each(ecIns._chartsViews, function(chart) {
				chart.__alive = false;
			});
			renderSeries(ecIns, ecModel, api, payload, updateParams);
			each(ecIns._chartsViews, function(chart) {
				if (!chart.__alive) chart.remove(ecModel, api);
			});
		};
		renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
			each(dirtyList || ecIns._componentsViews, function(componentView) {
				var componentModel = componentView.__model;
				clearStates(componentModel, componentView);
				componentView.render(componentModel, ecModel, api, payload);
				updateZ(componentModel, componentView);
				updateStates(componentModel, componentView);
			});
		};
		/**
		* Render each chart and component
		*/
		renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
			var scheduler = ecIns._scheduler;
			updateParams = extend(updateParams || {}, { updatedSeries: ecModel.getSeries() });
			lifecycle_default.trigger("series:beforeupdate", ecModel, api, updateParams);
			var unfinished = false;
			ecModel.eachSeries(function(seriesModel) {
				var chartView = ecIns._chartsMap[seriesModel.__viewId];
				chartView.__alive = true;
				var renderTask = chartView.renderTask;
				scheduler.updatePayload(renderTask, payload);
				clearStates(seriesModel, chartView);
				if (dirtyMap && dirtyMap.get(seriesModel.uid)) renderTask.dirty();
				if (renderTask.perform(scheduler.getPerformArgs(renderTask))) unfinished = true;
				chartView.group.silent = !!seriesModel.get("silent");
				updateBlend(seriesModel, chartView);
				updateSeriesElementSelection(seriesModel);
			});
			scheduler.unfinished = unfinished || scheduler.unfinished;
			lifecycle_default.trigger("series:layoutlabels", ecModel, api, updateParams);
			lifecycle_default.trigger("series:transition", ecModel, api, updateParams);
			ecModel.eachSeries(function(seriesModel) {
				var chartView = ecIns._chartsMap[seriesModel.__viewId];
				updateZ(seriesModel, chartView);
				updateStates(seriesModel, chartView);
			});
			updateHoverLayerStatus(ecIns, ecModel);
			lifecycle_default.trigger("series:afterupdate", ecModel, api, updateParams);
		};
		markStatusToUpdate = function(ecIns) {
			ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
			ecIns.getZr().wakeUp();
		};
		updateMainProcessVersion = function(ecIns) {
			ecIns[MAIN_PROCESS_VERSION_KEY] = (ecIns[MAIN_PROCESS_VERSION_KEY] + 1) % 1e3;
		};
		applyChangedStates = function(ecIns) {
			if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) return;
			ecIns.getZr().storage.traverse(function(el) {
				if (isElementRemoved(el)) return;
				applyElementStates(el);
			});
			ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
		};
		function applyElementStates(el) {
			var newStates = [];
			var oldStates = el.currentStates;
			for (var i = 0; i < oldStates.length; i++) {
				var stateName = oldStates[i];
				if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) newStates.push(stateName);
			}
			if (el.selected && el.states.select) newStates.push("select");
			if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) newStates.push("emphasis");
			else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) newStates.push("blur");
			el.useStates(newStates);
		}
		function updateHoverLayerStatus(ecIns, ecModel) {
			var storage = ecIns._zr.storage;
			var elCount = 0;
			storage.traverse(function(el) {
				if (!el.isGroup) elCount++;
			});
			if (elCount > ecModel.get("hoverLayerThreshold") && !env_default.node && !env_default.worker) ecModel.eachSeries(function(seriesModel) {
				if (seriesModel.preventUsingHoverLayer) return;
				var chartView = ecIns._chartsMap[seriesModel.__viewId];
				if (chartView.__alive) chartView.eachRendered(function(el) {
					if (el.states.emphasis) el.states.emphasis.hoverLayer = true;
				});
			});
		}
		/**
		* Update chart and blend.
		*/
		function updateBlend(seriesModel, chartView) {
			var blendMode = seriesModel.get("blendMode") || null;
			chartView.eachRendered(function(el) {
				if (!el.isGroup) el.style.blend = blendMode;
			});
		}
		function updateZ(model, view) {
			if (model.preventAutoZ) return;
			var zInfo = retrieveZInfo(model);
			view.eachRendered(function(el) {
				traverseUpdateZ(el, zInfo.z, zInfo.zlevel);
				return true;
			});
		}
		function clearStates(model, view) {
			view.eachRendered(function(el) {
				if (isElementRemoved(el)) return;
				var textContent = el.getTextContent();
				var textGuide = el.getTextGuideLine();
				if (el.stateTransition) el.stateTransition = null;
				if (textContent && textContent.stateTransition) textContent.stateTransition = null;
				if (textGuide && textGuide.stateTransition) textGuide.stateTransition = null;
				if (el.hasState()) {
					el.prevStates = el.currentStates;
					el.clearStates();
				} else if (el.prevStates) el.prevStates = null;
			});
		}
		function updateStates(model, view) {
			var stateAnimationModel = model.getModel("stateAnimation");
			var enableAnimation = model.isAnimationEnabled();
			var duration = stateAnimationModel.get("duration");
			var stateTransition = duration > 0 ? {
				duration,
				delay: stateAnimationModel.get("delay"),
				easing: stateAnimationModel.get("easing")
			} : null;
			view.eachRendered(function(el) {
				if (el.states && el.states.emphasis) {
					if (isElementRemoved(el)) return;
					if (el instanceof Path_default) savePathStates(el);
					if (el.__dirty) {
						var prevStates = el.prevStates;
						if (prevStates) el.useStates(prevStates);
					}
					if (enableAnimation) {
						el.stateTransition = stateTransition;
						var textContent = el.getTextContent();
						var textGuide = el.getTextGuideLine();
						if (textContent) textContent.stateTransition = stateTransition;
						if (textGuide) textGuide.stateTransition = stateTransition;
					}
					if (el.__dirty) applyElementStates(el);
				}
			});
		}
		createExtensionAPI = function(ecIns) {
			return new (function(_super$1) {
				__extends(class_1, _super$1);
				function class_1() {
					return _super$1 !== null && _super$1.apply(this, arguments) || this;
				}
				class_1.prototype.getCoordinateSystems = function() {
					return ecIns._coordSysMgr.getCoordinateSystems();
				};
				class_1.prototype.getComponentByElement = function(el) {
					while (el) {
						var modelInfo = el.__ecComponentInfo;
						if (modelInfo != null) return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
						el = el.parent;
					}
				};
				class_1.prototype.enterEmphasis = function(el, highlightDigit) {
					enterEmphasis(el, highlightDigit);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
					leaveEmphasis(el, highlightDigit);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.enterBlur = function(el) {
					enterBlur(el);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.leaveBlur = function(el) {
					leaveBlur(el);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.enterSelect = function(el) {
					enterSelect(el);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.leaveSelect = function(el) {
					leaveSelect(el);
					markStatusToUpdate(ecIns);
				};
				class_1.prototype.getModel = function() {
					return ecIns.getModel();
				};
				class_1.prototype.getViewOfComponentModel = function(componentModel) {
					return ecIns.getViewOfComponentModel(componentModel);
				};
				class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
					return ecIns.getViewOfSeriesModel(seriesModel);
				};
				class_1.prototype.getMainProcessVersion = function() {
					return ecIns[MAIN_PROCESS_VERSION_KEY];
				};
				return class_1;
			}(ExtensionAPI_default))(ecIns);
		};
		enableConnect = function(chart) {
			function updateConnectedChartsStatus(charts, status) {
				for (var i = 0; i < charts.length; i++) {
					var otherChart = charts[i];
					otherChart[CONNECT_STATUS_KEY] = status;
				}
			}
			each(connectionEventRevertMap, function(_, eventType) {
				chart._messageCenter.on(eventType, function(event) {
					if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
						if (event && event.escapeConnect) return;
						var action_1 = chart.makeActionFromEvent(event);
						var otherCharts_1 = [];
						each(instances, function(otherChart) {
							if (otherChart !== chart && otherChart.group === chart.group) otherCharts_1.push(otherChart);
						});
						updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
						each(otherCharts_1, function(otherChart) {
							if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) otherChart.dispatchAction(action_1);
						});
						updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
					}
				});
			});
		};
	}();
	return ECharts$1;
}(Eventful_default);
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
/**
* @deprecated
*/
echartsProto.one = function(eventName, cb, ctx) {
	var self = this;
	deprecateLog("ECharts#one is deprecated.");
	function wrapped() {
		var args2 = [];
		for (var _i = 0; _i < arguments.length; _i++) args2[_i] = arguments[_i];
		cb && cb.apply && cb.apply(this, args2);
		self.off(eventName, wrapped);
	}
	this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = [
	"click",
	"dblclick",
	"mouseover",
	"mouseout",
	"mousemove",
	"mousedown",
	"mouseup",
	"globalout",
	"contextmenu"
];
function disposedWarning(id) {
	warn("Instance " + id + " has been disposed");
}
var actions = {};
/**
* Map event type to action type for reproducing action from event for `connect`.
*/
var connectionEventRevertMap = {};
/**
* To remove duplication.
*/
var publicEventTypeMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var idBase = +/* @__PURE__ */ new Date() - 0;
var groupIdBase = +/* @__PURE__ */ new Date() - 0;
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
/**
* @param opts.devicePixelRatio Use window.devicePixelRatio by default
* @param opts.renderer Can choose 'canvas' or 'svg' to render the chart.
* @param opts.width Use clientWidth of the input `dom` by default.
*        Can be 'auto' (the same as null/undefined)
* @param opts.height Use clientHeight of the input `dom` by default.
*        Can be 'auto' (the same as null/undefined)
* @param opts.locale Specify the locale.
* @param opts.useDirtyRect Enable dirty rectangle rendering or not.
*/
function init(dom, theme$1, opts) {
	var isClient = !(opts && opts.ssr);
	if (isClient) {
		if (!dom) throw new Error("Initialize failed: invalid dom.");
		var existInstance = getInstanceByDom(dom);
		if (existInstance) {
			warn("There is a chart instance already initialized on the dom.");
			return existInstance;
		}
		if (isDom(dom) && dom.nodeName.toUpperCase() !== "CANVAS" && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
	}
	var chart = new ECharts(dom, theme$1, opts);
	chart.id = "ec_" + idBase++;
	instances[chart.id] = chart;
	isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
	enableConnect(chart);
	lifecycle_default.trigger("afterinit", chart);
	return chart;
}
/**
* @usage
* (A)
* ```js
* let chart1 = echarts.init(dom1);
* let chart2 = echarts.init(dom2);
* chart1.group = 'xxx';
* chart2.group = 'xxx';
* echarts.connect('xxx');
* ```
* (B)
* ```js
* let chart1 = echarts.init(dom1);
* let chart2 = echarts.init(dom2);
* echarts.connect('xxx', [chart1, chart2]);
* ```
*/
function connect(groupId) {
	if (isArray(groupId)) {
		var charts = groupId;
		groupId = null;
		each(charts, function(chart) {
			if (chart.group != null) groupId = chart.group;
		});
		groupId = groupId || "g_" + groupIdBase++;
		each(charts, function(chart) {
			chart.group = groupId;
		});
	}
	connectedGroups[groupId] = true;
	return groupId;
}
function disconnect(groupId) {
	connectedGroups[groupId] = false;
}
/**
* Alias and backward compatibility
* @deprecated
*/
var disConnect = disconnect;
/**
* Dispose a chart instance
*/
function dispose(chart) {
	if (isString(chart)) chart = instances[chart];
	else if (!(chart instanceof ECharts)) chart = getInstanceByDom(chart);
	if (chart instanceof ECharts && !chart.isDisposed()) chart.dispose();
}
function getInstanceByDom(dom) {
	return instances[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(key$1) {
	return instances[key$1];
}
/**
* Register theme
*/
function registerTheme(name, theme$1) {
	themeStorage[name] = theme$1;
}
/**
* Register option preprocessor
*/
function registerPreprocessor(preprocessorFunc) {
	if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) optionPreprocessorFuncs.push(preprocessorFunc);
}
function registerProcessor(priority, processor) {
	normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
/**
* Register postIniter
* @param {Function} postInitFunc
*/
function registerPostInit(postInitFunc) {
	registerUpdateLifecycle("afterinit", postInitFunc);
}
/**
* Register postUpdater
* @param {Function} postUpdateFunc
*/
function registerPostUpdate(postUpdateFunc) {
	registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name, cb) {
	lifecycle_default.on(name, cb);
}
function registerAction(arg0, arg1, action) {
	var actionType;
	var publicEventType;
	var refineEvent;
	var update;
	var publishNonRefinedEvent;
	if (isFunction(arg1)) {
		action = arg1;
		arg1 = "";
	}
	if (isObject$1(arg0)) {
		actionType = arg0.type;
		publicEventType = arg0.event;
		update = arg0.update;
		publishNonRefinedEvent = arg0.publishNonRefinedEvent;
		if (!action) action = arg0.action;
		refineEvent = arg0.refineEvent;
	} else {
		actionType = arg0;
		publicEventType = arg1;
	}
	function createEventType(actionOrEventType) {
		return actionOrEventType.toLowerCase();
	}
	publicEventType = createEventType(publicEventType || actionType);
	var nonRefinedEventType = refineEvent ? createEventType(actionType) : publicEventType;
	if (actions[actionType]) return;
	assert(ACTION_REG.test(actionType) && ACTION_REG.test(publicEventType));
	if (refineEvent) assert(publicEventType !== actionType);
	actions[actionType] = {
		actionType,
		refinedEventType: publicEventType,
		nonRefinedEventType,
		update,
		action,
		refineEvent
	};
	publicEventTypeMap[publicEventType] = 1;
	if (refineEvent && publishNonRefinedEvent) publicEventTypeMap[nonRefinedEventType] = 1;
	if (connectionEventRevertMap[nonRefinedEventType]) error(nonRefinedEventType + " must not be shared; use \"refineEvent\" if you intend to share an event name.");
	connectionEventRevertMap[nonRefinedEventType] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
	CoordinateSystem_default.register(type, coordSysCreator);
}
/**
* Get dimensions of specified coordinate system.
* @param {string} type
* @return {Array.<string|Object>}
*/
function getCoordinateSystemDimensions(type) {
	var coordSysCreator = CoordinateSystem_default.get(type);
	if (coordSysCreator) return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
}
function registerCustomSeries$1(seriesType$1, renderItem) {
	registerCustomSeries(seriesType$1, renderItem);
}
function registerLayout(priority, layoutTask) {
	normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
	normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
	if (isFunction(priority) || isObject$1(priority)) {
		fn = priority;
		priority = defaultPriority;
	}
	if (isNaN(priority) || priority == null) throw new Error("Illegal priority");
	each(targetList, function(wrap) {
		assert(wrap.__raw !== fn);
	});
	if (indexOf(registeredTasks, fn) >= 0) return;
	registeredTasks.push(fn);
	var stageHandler = Scheduler_default.wrapStageHandler(fn, visualType);
	stageHandler.__prio = priority;
	stageHandler.__raw = fn;
	targetList.push(stageHandler);
}
function registerLoading(name, loadingFx) {
	loadingEffects[name] = loadingFx;
}
/**
* ZRender need a canvas context to do measureText.
* But in node environment canvas may be created by node-canvas.
* So we need to specify how to create a canvas instead of using document.createElement('canvas')
*
*
* @deprecated use setPlatformAPI({ createCanvas }) instead.
*
* @example
*     let Canvas = require('canvas');
*     let echarts = require('echarts');
*     echarts.setCanvasCreator(function () {
*         // Small size is enough.
*         return new Canvas(32, 32);
*     });
*/
function setCanvasCreator(creator) {
	deprecateLog("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead.");
	setPlatformAPI({ createCanvas: creator });
}
/**
* The parameters and usage: see `geoSourceManager.registerMap`.
* Compatible with previous `echarts.registerMap`.
*/
function registerMap(mapName, geoJson, specialAreas) {
	var registerMap$1 = getImpl("registerMap");
	registerMap$1 && registerMap$1(mapName, geoJson, specialAreas);
}
function getMap(mapName) {
	var getMap$1 = getImpl("getMap");
	return getMap$1 && getMap$1(mapName);
}
var registerTransform = registerExternalTransform;
/**
* Globa dispatchAction to a specified chart instance.
*/
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
registerLoading("default", defaultLoading);
registerAction({
	type: HIGHLIGHT_ACTION_TYPE,
	event: HIGHLIGHT_ACTION_TYPE,
	update: HIGHLIGHT_ACTION_TYPE
}, noop);
registerAction({
	type: DOWNPLAY_ACTION_TYPE,
	event: DOWNPLAY_ACTION_TYPE,
	update: DOWNPLAY_ACTION_TYPE
}, noop);
registerAction({
	type: SELECT_ACTION_TYPE,
	event: SELECT_CHANGED_EVENT_TYPE,
	update: SELECT_ACTION_TYPE,
	action: noop,
	refineEvent: makeSelectChangedEvent,
	publishNonRefinedEvent: true
});
registerAction({
	type: UNSELECT_ACTION_TYPE,
	event: SELECT_CHANGED_EVENT_TYPE,
	update: UNSELECT_ACTION_TYPE,
	action: noop,
	refineEvent: makeSelectChangedEvent,
	publishNonRefinedEvent: true
});
registerAction({
	type: TOGGLE_SELECT_ACTION_TYPE,
	event: SELECT_CHANGED_EVENT_TYPE,
	update: TOGGLE_SELECT_ACTION_TYPE,
	action: noop,
	refineEvent: makeSelectChangedEvent,
	publishNonRefinedEvent: true
});
function makeSelectChangedEvent(actionResultBatch, payload, ecModel, api) {
	return { eventContent: {
		selected: getAllSelectedIndices(ecModel),
		isFromClick: payload.isFromClick || false
	} };
}
registerTheme("default", {});
registerTheme("dark", dark_default);
var dataTool = {};

//#endregion
//#region node_modules/echarts/lib/extension.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var extensions = [];
var extensionRegisters = {
	registerPreprocessor,
	registerProcessor,
	registerPostInit,
	registerPostUpdate,
	registerUpdateLifecycle,
	registerAction,
	registerCoordinateSystem,
	registerLayout,
	registerVisual,
	registerTransform,
	registerLoading,
	registerMap,
	registerImpl,
	PRIORITY,
	ComponentModel: Component_default$1,
	ComponentView: Component_default,
	SeriesModel: Series_default,
	ChartView: Chart_default,
	registerComponentModel: function(ComponentModelClass) {
		Component_default$1.registerClass(ComponentModelClass);
	},
	registerComponentView: function(ComponentViewClass) {
		Component_default.registerClass(ComponentViewClass);
	},
	registerSeriesModel: function(SeriesModelClass) {
		Series_default.registerClass(SeriesModelClass);
	},
	registerChartView: function(ChartViewClass) {
		Chart_default.registerClass(ChartViewClass);
	},
	registerCustomSeries: function(seriesType$1, renderItem) {
		registerCustomSeries(seriesType$1, renderItem);
	},
	registerSubTypeDefaulter: function(componentType, defaulter) {
		Component_default$1.registerSubTypeDefaulter(componentType, defaulter);
	},
	registerPainter: function(painterType, PainterCtor) {
		registerPainter(painterType, PainterCtor);
	}
};
function use(ext) {
	if (isArray(ext)) {
		each(ext, function(singleExt) {
			use(singleExt);
		});
		return;
	}
	if (indexOf(extensions, ext) >= 0) return;
	extensions.push(ext);
	if (isFunction(ext)) ext = { install: ext };
	ext.install(extensionRegisters);
}

//#endregion
//#region node_modules/zrender/lib/contain/polygon.js
var EPSILON = 1e-8;
function isAroundEqual(a, b) {
	return Math.abs(a - b) < EPSILON;
}
function contain(points$1, x, y) {
	var w = 0;
	var p = points$1[0];
	if (!p) return false;
	for (var i = 1; i < points$1.length; i++) {
		var p2 = points$1[i];
		w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
		p = p2;
	}
	var p0 = points$1[0];
	if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
	return w !== 0;
}

//#endregion
//#region node_modules/echarts/lib/coord/geo/Region.js
init_tslib_es6();
var TMP_TRANSFORM = [];
function transformPoints(points$1, transform) {
	for (var p = 0; p < points$1.length; p++) applyTransform$1(points$1[p], points$1[p], transform);
}
function updateBBoxFromPoints(points$1, min$1, max$1, projection) {
	for (var i = 0; i < points$1.length; i++) {
		var p = points$1[i];
		if (projection) p = projection.project(p);
		if (p && isFinite(p[0]) && isFinite(p[1])) {
			min(min$1, min$1, p);
			max(max$1, max$1, p);
		}
	}
}
function centroid(points$1) {
	var signedArea = 0;
	var cx = 0;
	var cy = 0;
	var len = points$1.length;
	var x0 = points$1[len - 1][0];
	var y0 = points$1[len - 1][1];
	for (var i = 0; i < len; i++) {
		var x1 = points$1[i][0];
		var y1 = points$1[i][1];
		var a = x0 * y1 - x1 * y0;
		signedArea += a;
		cx += (x0 + x1) * a;
		cy += (y0 + y1) * a;
		x0 = x1;
		y0 = y1;
	}
	return signedArea ? [
		cx / signedArea / 3,
		cy / signedArea / 3,
		signedArea
	] : [points$1[0][0] || 0, points$1[0][1] || 0];
}
var Region = function() {
	function Region$1(name) {
		this.name = name;
	}
	Region$1.prototype.setCenter = function(center) {
		this._center = center;
	};
	/**
	* Get center point in data unit. That is,
	* for GeoJSONRegion, the unit is lat/lng,
	* for GeoSVGRegion, the unit is SVG local coord.
	*/
	Region$1.prototype.getCenter = function() {
		var center = this._center;
		if (!center) center = this._center = this.calcCenter();
		return center;
	};
	return Region$1;
}();
var GeoJSONPolygonGeometry = function() {
	function GeoJSONPolygonGeometry$1(exterior, interiors) {
		this.type = "polygon";
		this.exterior = exterior;
		this.interiors = interiors;
	}
	return GeoJSONPolygonGeometry$1;
}();
var GeoJSONLineStringGeometry = function() {
	function GeoJSONLineStringGeometry$1(points$1) {
		this.type = "linestring";
		this.points = points$1;
	}
	return GeoJSONLineStringGeometry$1;
}();
var GeoJSONRegion = function(_super) {
	__extends(GeoJSONRegion$1, _super);
	function GeoJSONRegion$1(name, geometries, cp) {
		var _this = _super.call(this, name) || this;
		_this.type = "geoJSON";
		_this.geometries = geometries;
		_this._center = cp && [cp[0], cp[1]];
		return _this;
	}
	GeoJSONRegion$1.prototype.calcCenter = function() {
		var geometries = this.geometries;
		var largestGeo;
		var largestGeoSize = 0;
		for (var i = 0; i < geometries.length; i++) {
			var geo = geometries[i];
			var exterior = geo.exterior;
			var size = exterior && exterior.length;
			if (size > largestGeoSize) {
				largestGeo = geo;
				largestGeoSize = size;
			}
		}
		if (largestGeo) return centroid(largestGeo.exterior);
		var rect = this.getBoundingRect();
		return [rect.x + rect.width / 2, rect.y + rect.height / 2];
	};
	GeoJSONRegion$1.prototype.getBoundingRect = function(projection) {
		var rect = this._rect;
		if (rect && !projection) return rect;
		var min$1 = [Infinity, Infinity];
		var max$1 = [-Infinity, -Infinity];
		var geometries = this.geometries;
		each(geometries, function(geo) {
			if (geo.type === "polygon") updateBBoxFromPoints(geo.exterior, min$1, max$1, projection);
			else each(geo.points, function(points$1) {
				updateBBoxFromPoints(points$1, min$1, max$1, projection);
			});
		});
		if (!(isFinite(min$1[0]) && isFinite(min$1[1]) && isFinite(max$1[0]) && isFinite(max$1[1]))) min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0;
		rect = new BoundingRect_default(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]);
		if (!projection) this._rect = rect;
		return rect;
	};
	GeoJSONRegion$1.prototype.contain = function(coord) {
		var rect = this.getBoundingRect();
		var geometries = this.geometries;
		if (!rect.contain(coord[0], coord[1])) return false;
		loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {
			var geo = geometries[i];
			if (geo.type !== "polygon") continue;
			var exterior = geo.exterior;
			var interiors = geo.interiors;
			if (contain(exterior, coord[0], coord[1])) {
				for (var k = 0; k < (interiors ? interiors.length : 0); k++) if (contain(interiors[k], coord[0], coord[1])) continue loopGeo;
				return true;
			}
		}
		return false;
	};
	/**
	* Transform the raw coords to target bounding.
	* @param x
	* @param y
	* @param width
	* @param height
	*/
	GeoJSONRegion$1.prototype.transformTo = function(x, y, width, height) {
		var rect = this.getBoundingRect();
		var aspect = rect.width / rect.height;
		if (!width) width = aspect * height;
		else if (!height) height = width / aspect;
		var target = new BoundingRect_default(x, y, width, height);
		var transform = rect.calculateTransform(target);
		var geometries = this.geometries;
		for (var i = 0; i < geometries.length; i++) {
			var geo = geometries[i];
			if (geo.type === "polygon") {
				transformPoints(geo.exterior, transform);
				each(geo.interiors, function(interior) {
					transformPoints(interior, transform);
				});
			} else each(geo.points, function(points$1) {
				transformPoints(points$1, transform);
			});
		}
		rect = this._rect;
		rect.copy(target);
		this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
	};
	GeoJSONRegion$1.prototype.cloneShallow = function(name) {
		name ??= this.name;
		var newRegion = new GeoJSONRegion$1(name, this.geometries, this._center);
		newRegion._rect = this._rect;
		newRegion.transformTo = null;
		return newRegion;
	};
	return GeoJSONRegion$1;
}(Region);
var GeoSVGRegion = function(_super) {
	__extends(GeoSVGRegion$1, _super);
	function GeoSVGRegion$1(name, elOnlyForCalculate) {
		var _this = _super.call(this, name) || this;
		_this.type = "geoSVG";
		_this._elOnlyForCalculate = elOnlyForCalculate;
		return _this;
	}
	GeoSVGRegion$1.prototype.calcCenter = function() {
		var el = this._elOnlyForCalculate;
		var rect = el.getBoundingRect();
		var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
		var mat = identity(TMP_TRANSFORM);
		var target = el;
		while (target && !target.isGeoSVGGraphicRoot) {
			mul(mat, target.getLocalTransform(), mat);
			target = target.parent;
		}
		invert(mat, mat);
		applyTransform$1(center, center, mat);
		return center;
	};
	return GeoSVGRegion$1;
}(Region);

//#endregion
//#region node_modules/echarts/lib/coord/geo/parseGeoJson.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
/**
* Parse and decode geo json
*/
function decode(json) {
	if (!json.UTF8Encoding) return json;
	var jsonCompressed = json;
	var encodeScale = jsonCompressed.UTF8Scale;
	if (encodeScale == null) encodeScale = 1024;
	var features = jsonCompressed.features;
	each(features, function(feature) {
		var geometry = feature.geometry;
		var encodeOffsets = geometry.encodeOffsets;
		var coordinates = geometry.coordinates;
		if (!encodeOffsets) return;
		switch (geometry.type) {
			case "LineString":
				geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
				break;
			case "Polygon":
				decodeRings(coordinates, encodeOffsets, encodeScale);
				break;
			case "MultiLineString":
				decodeRings(coordinates, encodeOffsets, encodeScale);
				break;
			case "MultiPolygon": each(coordinates, function(rings, idx) {
				return decodeRings(rings, encodeOffsets[idx], encodeScale);
			});
		}
	});
	jsonCompressed.UTF8Encoding = false;
	return jsonCompressed;
}
function decodeRings(rings, encodeOffsets, encodeScale) {
	for (var c = 0; c < rings.length; c++) rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
}
function decodeRing(coordinate, encodeOffsets, encodeScale) {
	var result = [];
	var prevX = encodeOffsets[0];
	var prevY = encodeOffsets[1];
	for (var i = 0; i < coordinate.length; i += 2) {
		var x = coordinate.charCodeAt(i) - 64;
		var y = coordinate.charCodeAt(i + 1) - 64;
		x = x >> 1 ^ -(x & 1);
		y = y >> 1 ^ -(y & 1);
		x += prevX;
		y += prevY;
		prevX = x;
		prevY = y;
		result.push([x / encodeScale, y / encodeScale]);
	}
	return result;
}
function parseGeoJSON(geoJson, nameProperty) {
	geoJson = decode(geoJson);
	return map$1(filter(geoJson.features, function(featureObj) {
		return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
	}), function(featureObj) {
		var properties = featureObj.properties;
		var geo = featureObj.geometry;
		var geometries = [];
		switch (geo.type) {
			case "Polygon":
				var coordinates = geo.coordinates;
				geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
				break;
			case "MultiPolygon":
				each(geo.coordinates, function(item) {
					if (item[0]) geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
				});
				break;
			case "LineString":
				geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
				break;
			case "MultiLineString": geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
		}
		var region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
		region.properties = properties;
		return region;
	});
}

//#endregion
//#region node_modules/echarts/lib/data/DataDiffer.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
	return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
	return item;
}
var DataDiffer = function() {
	/**
	* @param context Can be visited by this.context in callback.
	*/
	function DataDiffer$1(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
		this._old = oldArr;
		this._new = newArr;
		this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
		this._newKeyGetter = newKeyGetter || defaultKeyGetter;
		this.context = context;
		this._diffModeMultiple = diffMode === "multiple";
	}
	/**
	* Callback function when add a data
	*/
	DataDiffer$1.prototype.add = function(func) {
		this._add = func;
		return this;
	};
	/**
	* Callback function when update a data
	*/
	DataDiffer$1.prototype.update = function(func) {
		this._update = func;
		return this;
	};
	/**
	* Callback function when update a data and only work in `cbMode: 'byKey'`.
	*/
	DataDiffer$1.prototype.updateManyToOne = function(func) {
		this._updateManyToOne = func;
		return this;
	};
	/**
	* Callback function when update a data and only work in `cbMode: 'byKey'`.
	*/
	DataDiffer$1.prototype.updateOneToMany = function(func) {
		this._updateOneToMany = func;
		return this;
	};
	/**
	* Callback function when update a data and only work in `cbMode: 'byKey'`.
	*/
	DataDiffer$1.prototype.updateManyToMany = function(func) {
		this._updateManyToMany = func;
		return this;
	};
	/**
	* Callback function when remove a data
	*/
	DataDiffer$1.prototype.remove = function(func) {
		this._remove = func;
		return this;
	};
	DataDiffer$1.prototype.execute = function() {
		this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
	};
	DataDiffer$1.prototype._executeOneToOne = function() {
		var oldArr = this._old;
		var newArr = this._new;
		var newDataIndexMap = {};
		var oldDataKeyArr = new Array(oldArr.length);
		var newDataKeyArr = new Array(newArr.length);
		this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
		this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
		for (var i = 0; i < oldArr.length; i++) {
			var oldKey = oldDataKeyArr[i];
			var newIdxMapVal = newDataIndexMap[oldKey];
			var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
			if (newIdxMapValLen > 1) {
				var newIdx = newIdxMapVal.shift();
				if (newIdxMapVal.length === 1) newDataIndexMap[oldKey] = newIdxMapVal[0];
				this._update && this._update(newIdx, i);
			} else if (newIdxMapValLen === 1) {
				newDataIndexMap[oldKey] = null;
				this._update && this._update(newIdxMapVal, i);
			} else this._remove && this._remove(i);
		}
		this._performRestAdd(newDataKeyArr, newDataIndexMap);
	};
	/**
	* For example, consider the case:
	* oldData: [o0, o1, o2, o3, o4, o5, o6, o7],
	* newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],
	* Where:
	*     o0, o1, n0 has key 'a' (many to one)
	*     o5, n4, n5, n6 has key 'b' (one to many)
	*     o2, n1 has key 'c' (one to one)
	*     n2, n3 has key 'd' (add)
	*     o3, o4 has key 'e' (remove)
	*     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)
	* Then:
	*     (The order of the following directives are not ensured.)
	*     this._updateManyToOne(n0, [o0, o1]);
	*     this._updateOneToMany([n4, n5, n6], o5);
	*     this._update(n1, o2);
	*     this._remove(o3);
	*     this._remove(o4);
	*     this._remove(o6);
	*     this._remove(o7);
	*     this._add(n2);
	*     this._add(n3);
	*     this._add(n7);
	*     this._add(n8);
	*/
	DataDiffer$1.prototype._executeMultiple = function() {
		var oldArr = this._old;
		var newArr = this._new;
		var oldDataIndexMap = {};
		var newDataIndexMap = {};
		var oldDataKeyArr = [];
		var newDataKeyArr = [];
		this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
		this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
		for (var i = 0; i < oldDataKeyArr.length; i++) {
			var oldKey = oldDataKeyArr[i];
			var oldIdxMapVal = oldDataIndexMap[oldKey];
			var newIdxMapVal = newDataIndexMap[oldKey];
			var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
			var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
			if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
				this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
				newDataIndexMap[oldKey] = null;
			} else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
				this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
				newDataIndexMap[oldKey] = null;
			} else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
				this._update && this._update(newIdxMapVal, oldIdxMapVal);
				newDataIndexMap[oldKey] = null;
			} else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
				this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
				newDataIndexMap[oldKey] = null;
			} else if (oldIdxMapValLen > 1) for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) this._remove && this._remove(oldIdxMapVal[i_1]);
			else this._remove && this._remove(oldIdxMapVal);
		}
		this._performRestAdd(newDataKeyArr, newDataIndexMap);
	};
	DataDiffer$1.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
		for (var i = 0; i < newDataKeyArr.length; i++) {
			var newKey = newDataKeyArr[i];
			var newIdxMapVal = newDataIndexMap[newKey];
			var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
			if (idxMapValLen > 1) for (var j = 0; j < idxMapValLen; j++) this._add && this._add(newIdxMapVal[j]);
			else if (idxMapValLen === 1) this._add && this._add(newIdxMapVal);
			newDataIndexMap[newKey] = null;
		}
	};
	DataDiffer$1.prototype._initIndexMap = function(arr, map$2, keyArr, keyGetterName) {
		var cbModeMultiple = this._diffModeMultiple;
		for (var i = 0; i < arr.length; i++) {
			var key$1 = "_ec_" + this[keyGetterName](arr[i], i);
			if (!cbModeMultiple) keyArr[i] = key$1;
			if (!map$2) continue;
			var idxMapVal = map$2[key$1];
			var idxMapValLen = dataIndexMapValueLength(idxMapVal);
			if (idxMapValLen === 0) {
				map$2[key$1] = i;
				if (cbModeMultiple) keyArr.push(key$1);
			} else if (idxMapValLen === 1) map$2[key$1] = [idxMapVal, i];
			else idxMapVal.push(i);
		}
	};
	return DataDiffer$1;
}();
var DataDiffer_default = DataDiffer;

//#endregion
//#region node_modules/echarts/lib/data/helper/dimensionHelper.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var DimensionUserOuput = function() {
	function DimensionUserOuput$1(encode, dimRequest) {
		this._encode = encode;
		this._schema = dimRequest;
	}
	DimensionUserOuput$1.prototype.get = function() {
		return {
			fullDimensions: this._getFullDimensionNames(),
			encode: this._encode
		};
	};
	/**
	* Get all data store dimension names.
	* Theoretically a series data store is defined both by series and used dataset (if any).
	* If some dimensions are omitted for performance reason in `this.dimensions`,
	* the dimension name may not be auto-generated if user does not specify a dimension name.
	* In this case, the dimension name is `null`/`undefined`.
	*/
	DimensionUserOuput$1.prototype._getFullDimensionNames = function() {
		if (!this._cachedDimNames) this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
		return this._cachedDimNames;
	};
	return DimensionUserOuput$1;
}();
function summarizeDimensions(data, schema) {
	var summary = {};
	var encode = summary.encode = {};
	var notExtraCoordDimMap = createHashMap();
	var defaultedLabel = [];
	var defaultedTooltip = [];
	var userOutputEncode = {};
	each(data.dimensions, function(dimName) {
		var dimItem = data.getDimensionInfo(dimName);
		var coordDim = dimItem.coordDim;
		if (coordDim) {
			assert(VISUAL_DIMENSIONS.get(coordDim) == null);
			var coordDimIndex = dimItem.coordDimIndex;
			getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
			if (!dimItem.isExtraCoord) {
				notExtraCoordDimMap.set(coordDim, 1);
				if (mayLabelDimType(dimItem.type)) defaultedLabel[0] = dimName;
				getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
			}
			if (dimItem.defaultTooltip) defaultedTooltip.push(dimName);
		}
		VISUAL_DIMENSIONS.each(function(v, otherDim) {
			var encodeArr = getOrCreateEncodeArr(encode, otherDim);
			var dimIndex = dimItem.otherDims[otherDim];
			if (dimIndex != null && dimIndex !== false) encodeArr[dimIndex] = dimItem.name;
		});
	});
	var dataDimsOnCoord = [];
	var encodeFirstDimNotExtra = {};
	notExtraCoordDimMap.each(function(v, coordDim) {
		var dimArr = encode[coordDim];
		encodeFirstDimNotExtra[coordDim] = dimArr[0];
		dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
	});
	summary.dataDimsOnCoord = dataDimsOnCoord;
	summary.dataDimIndicesOnCoord = map$1(dataDimsOnCoord, function(dimName) {
		return data.getDimensionInfo(dimName).storeDimIndex;
	});
	summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
	var encodeLabel = encode.label;
	if (encodeLabel && encodeLabel.length) defaultedLabel = encodeLabel.slice();
	var encodeTooltip = encode.tooltip;
	if (encodeTooltip && encodeTooltip.length) defaultedTooltip = encodeTooltip.slice();
	else if (!defaultedTooltip.length) defaultedTooltip = defaultedLabel.slice();
	encode.defaultedLabel = defaultedLabel;
	encode.defaultedTooltip = defaultedTooltip;
	summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
	return summary;
}
function getOrCreateEncodeArr(encode, dim) {
	if (!encode.hasOwnProperty(dim)) encode[dim] = [];
	return encode[dim];
}
function getDimensionTypeByAxis(axisType) {
	return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
	return !(dimType === "ordinal" || dimType === "time");
}

//#endregion
//#region node_modules/echarts/lib/data/SeriesDimensionDefine.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var SeriesDimensionDefine = function() {
	/**
	* @param opt All of the fields will be shallow copied.
	*/
	function SeriesDimensionDefine$1(opt) {
		/**
		* The format of `otherDims` is:
		* ```js
		* {
		*     tooltip?: number
		*     label?: number
		*     itemName?: number
		*     seriesName?: number
		* }
		* ```
		*
		* A `series.encode` can specified these fields:
		* ```js
		* encode: {
		*     // "3, 1, 5" is the index of data dimension.
		*     tooltip: [3, 1, 5],
		*     label: [0, 3],
		*     ...
		* }
		* ```
		* `otherDims` is the parse result of the `series.encode` above, like:
		* ```js
		* // Suppose the index of this data dimension is `3`.
		* this.otherDims = {
		*     // `3` is at the index `0` of the `encode.tooltip`
		*     tooltip: 0,
		*     // `3` is at the index `1` of the `encode.label`
		*     label: 1
		* };
		* ```
		*
		* This prop should never be `null`/`undefined` after initialized.
		*/
		this.otherDims = {};
		if (opt != null) extend(this, opt);
	}
	return SeriesDimensionDefine$1;
}();
var SeriesDimensionDefine_default = SeriesDimensionDefine;

//#endregion
//#region node_modules/echarts/lib/data/SeriesData.js
/**
* AUTO-GENERATED FILE. DO NOT MODIFY.
*/
var isObject = isObject$1;
var map = map$1;
var CtorInt32Array = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\0\0";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = [
	"hasItemOption",
	"_nameList",
	"_idList",
	"_invertedIndicesMap",
	"_dimSummary",
	"userOutput",
	"_rawData",
	"_dimValueGetter",
	"_nameDimIdx",
	"_idDimIdx",
	"_nameRepeatCount"
];
var CLONE_PROPERTIES = ["_approximateExtent"];
var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData = function() {
	/**
	* @param dimensionsInput.dimensions
	*        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
	*        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
	*/
	function SeriesData$1(dimensionsInput, hostModel) {
		this.type = "list";
		this._dimOmitted = false;
		this._nameList = [];
		this._idList = [];
		this._visual = {};
		this._layout = {};
		this._itemVisuals = [];
		this._itemLayouts = [];
		this._graphicEls = [];
		this._approximateExtent = {};
		this._calculationInfo = {};
		this.hasItemOption = false;
		this.TRANSFERABLE_METHODS = [
			"cloneShallow",
			"downSample",
			"minmaxDownSample",
			"lttbDownSample",
			"map"
		];
		this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
		this.DOWNSAMPLE_METHODS = [
			"downSample",
			"minmaxDownSample",
			"lttbDownSample"
		];
		var dimensions;
		var assignStoreDimIdx = false;
		if (isSeriesDataSchema(dimensionsInput)) {
			dimensions = dimensionsInput.dimensions;
			this._dimOmitted = dimensionsInput.isDimensionOmitted();
			this._schema = dimensionsInput;
		} else {
			assignStoreDimIdx = true;
			dimensions = dimensionsInput;
		}
		dimensions = dimensions || ["x", "y"];
		var dimensionInfos = {};
		var dimensionNames = [];
		var invertedIndicesMap = {};
		var needsHasOwn = false;
		var emptyObj = {};
		for (var i = 0; i < dimensions.length; i++) {
			var dimInfoInput = dimensions[i];
			var dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine_default({ name: dimInfoInput }) : !(dimInfoInput instanceof SeriesDimensionDefine_default) ? new SeriesDimensionDefine_default(dimInfoInput) : dimInfoInput;
			var dimensionName = dimensionInfo.name;
			dimensionInfo.type = dimensionInfo.type || "float";
			if (!dimensionInfo.coordDim) {
				dimensionInfo.coordDim = dimensionName;
				dimensionInfo.coordDimIndex = 0;
			}
			var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
			dimensionNames.push(dimensionName);
			dimensionInfos[dimensionName] = dimensionInfo;
			if (emptyObj[dimensionName] != null) needsHasOwn = true;
			if (dimensionInfo.createInvertedIndices) invertedIndicesMap[dimensionName] = [];
			var dimIdx = i;
			if (isNumber(dimensionInfo.storeDimIndex)) dimIdx = dimensionInfo.storeDimIndex;
			if (otherDims.itemName === 0) this._nameDimIdx = dimIdx;
			if (otherDims.itemId === 0) this._idDimIdx = dimIdx;
			assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
			if (assignStoreDimIdx) dimensionInfo.storeDimIndex = i;
		}
		this.dimensions = dimensionNames;
		this._dimInfos = dimensionInfos;
		this._initGetDimensionInfo(needsHasOwn);
		this.hostModel = hostModel;
		this._invertedIndicesMap = invertedIndicesMap;
		if (this._dimOmitted) {
			var dimIdxToName_1 = this._dimIdxToName = createHashMap();
			each(dimensionNames, function(dimName) {
				dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
			});
		}
	}
	/**
	*
	* Get concrete dimension name by dimension name or dimension index.
	* If input a dimension name, do not validate whether the dimension name exits.
	*
	* @caution
	* @param dim Must make sure the dimension is `SeriesDimensionLoose`.
	* Because only those dimensions will have auto-generated dimension names if not
	* have a user-specified name, and other dimensions will get a return of null/undefined.
	*
	* @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:
	* ```js
	* const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);
	* ```
	*
	* @return Concrete dim name.
	*/
	SeriesData$1.prototype.getDimension = function(dim) {
		var dimIdx = this._recognizeDimIndex(dim);
		if (dimIdx == null) return dim;
		dimIdx = dim;
		if (!this._dimOmitted) return this.dimensions[dimIdx];
		var dimName = this._dimIdxToName.get(dimIdx);
		if (dimName != null) return dimName;
		var sourceDimDef = this._schema.getSourceDimension(dimIdx);
		if (sourceDimDef) return sourceDimDef.name;
	};
	/**
	* Get dimension index in data store. Return -1 if not found.
	* Can be used to index value from getRawValue.
	*/
	SeriesData$1.prototype.getDimensionIndex = function(dim) {
		var dimIdx = this._recognizeDimIndex(dim);
		if (dimIdx != null) return dimIdx;
		if (dim == null) return -1;
		var dimInfo = this._getDimInfo(dim);
		return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
	};
	/**
	* The meanings of the input parameter `dim`:
	*
	* + If dim is a number (e.g., `1`), it means the index of the dimension.
	*   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.
	* + If dim is a number-like string (e.g., `"1"`):
	*     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,
	*        it means that concrete name.
	*     + If not, it will be converted to a number, which means the index of the dimension.
	*        (why? because of the backward compatibility. We have been tolerating number-like string in
	*        dimension setting, although now it seems that it is not a good idea.)
	*     For example, `visualMap[i].dimension: "1"` is the same meaning as `visualMap[i].dimension: 1`,
	*     if no dimension name is defined as `"1"`.
	* + If dim is a not-number-like string, it means the concrete dim name.
	*   For example, it can be be default name `"x"`, `"y"`, `"z"`, `"lng"`, `"lat"`, `"angle"`, `"radius"`,
	*   or customized in `dimensions` property of option like `"age"`.
	*
	* @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).
	*/
	SeriesData$1.prototype._recognizeDimIndex = function(dim) {
		if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) return +dim;
	};
	SeriesData$1.prototype._getStoreDimIndex = function(dim) {
		var dimIdx = this.getDimensionIndex(dim);
		if (dimIdx == null) throw new Error("Unknown dimension " + dim);
		return dimIdx;
	};
	/**
	* Get type and calculation info of particular dimension
	* @param dim
	*        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
	*        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
	*/
	SeriesData$1.prototype.getDimensionInfo = function(dim) {
		return this._getDimInfo(this.getDimension(dim));
	};
	SeriesData$1.prototype._initGetDimensionInfo = function(needsHasOwn) {
		var dimensionInfos = this._dimInfos;
		this._getDimInfo = needsHasOwn ? function(dimName) {
			return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
		} : function(dimName) {
			return dimensionInfos[dimName];
		};
	};
	/**
	* concrete dimension name list on coord.
	*/
	SeriesData$1.prototype.getDimensionsOnCoord = function() {
		return this._dimSummary.dataDimsOnCoord.slice();
	};
	SeriesData$1.prototype.mapDimension = function(coordDim, idx) {
		var dimensionsSummary = this._dimSummary;
		if (idx == null) return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
		var dims = dimensionsSummary.encode[coordDim];
		return dims ? dims[idx] : null;
	};
	SeriesData$1.prototype.mapDimensionsAll = function(coordDim) {
		return (this._dimSummary.encode[coordDim] || []).slice();
	};
	SeriesData$1.prototype.getStore = function() {
		return this._store;
	};
	/**
	* Initialize from data
	* @param data source or data or data store.
	* @param nameList The name of a datum is used on data diff and
	*        default label/tooltip.
	*        A name can be specified in encode.itemName,
	*        or dataItem.name (only for series option data),
	*        or provided in nameList from outside.
	*/
	SeriesData$1.prototype.initData = function(data, nameList, dimValueGetter) {
		var _this = this;
		var store;
		if (data instanceof DataStore_default) store = data;
		if (!store) {
			var dimensions = this.dimensions;
			var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
			store = new DataStore_default();
			var dimensionInfos = map(dimensions, function(dimName) {
				return {
					type: _this._dimInfos[dimName].type,
					property: dimName
				};
			});
			store.initData(provider, dimensionInfos, dimValueGetter);
		}
		this._store = store;
		this._nameList = (nameList || []).slice();
		this._idList = [];
		this._nameRepeatCount = {};
		this._doInit(0, store.count());
		this._dimSummary = summarizeDimensions(this, this._schema);
		this.userOutput = this._dimSummary.userOutput;
	};
	/**
	* Caution: Can be only called on raw data (before `this._indices` created).
	*/
	SeriesData$1.prototype.appendData = function(data) {
		var range = this._store.appendData(data);
		this._doInit(range[0], range[1]);
	};
	/**
	* Caution: Can be only called on raw data (before `this._indices` created).
	* This method does not modify `rawData` (`dataProvider`), but only
	* add values to store.
	*
	* The final count will be increased by `Math.max(values.length, names.length)`.
	*
	* @param values That is the SourceType: 'arrayRows', like
	*        [
	*            [12, 33, 44],
	*            [NaN, 43, 1],
	*            ['-', 'asdf', 0]
	*        ]
	*        Each item is exactly corresponding to a dimension.
	*/
	SeriesData$1.prototype.appendValues = function(values, names) {
		var _a$1 = this._store.appendValues(values, names && names.length), start = _a$1.start, end = _a$1.end;
		var shouldMakeIdFromName = this._shouldMakeIdFromName();
		this._updateOrdinalMeta();
		if (names) for (var idx = start; idx < end; idx++) {
			var sourceIdx = idx - start;
			this._nameList[idx] = names[sourceIdx];
			if (shouldMakeIdFromName) makeIdFromName(this, idx);
		}
	};
	SeriesData$1.prototype._updateOrdinalMeta = function() {
		var store = this._store;
		var dimensions = this.dimensions;
		for (var i = 0; i < dimensions.length; i++) {
			var dimInfo = this._dimInfos[dimensions[i]];
			if (dimInfo.ordinalMeta) store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
		}
	};
	SeriesData$1.prototype._shouldMakeIdFromName = function() {
		var provider = this._store.getProvider();
		return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
	};
	SeriesData$1.prototype._doInit = function(start, end) {
		if (start >= end) return;
		var provider = this._store.getProvider();
		this._updateOrdinalMeta();
		var nameList = this._nameList;
		var idList = this._idList;
		if (provider.getSource().sourceFormat === SOURCE_FORMAT_ORIGINAL && !provider.pure) {
			var sharedDataItem = [];
			for (var idx = start; idx < end; idx++) {
				var dataItem = provider.getItem(idx, sharedDataItem);
				if (!this.hasItemOption && isDataItemOption(dataItem)) this.hasItemOption = true;
				if (dataItem) {
					var itemName = dataItem.name;
					if (nameList[idx] == null && itemName != null) nameList[idx] = convertOptionIdName(itemName, null);
					var itemId = dataItem.id;
					if (idList[idx] == null && itemId != null) idList[idx] = convertOptionIdName(itemId, null);
				}
			}
		}
		if (this._shouldMakeIdFromName()) for (var idx = start; idx < end; idx++) makeIdFromName(this, idx);
		prepareInvertedIndex(this);
	};
	/**
	* PENDING: In fact currently this function is only used to short-circuit
	* the calling of `scale.unionExtentFromData` when data have been filtered by modules
	* like "dataZoom". `scale.unionExtentFromData` is used to calculate data extent for series on
	* an axis, but if a "axis related data filter module" is used, the extent of the axis have
	* been fixed and no need to calling `scale.unionExtentFromData` actually.
	* But if we add "custom data filter" in future, which is not "axis related", this method may
	* be still needed.
	*
	* Optimize for the scenario that data is filtered by a given extent.
	* Consider that if data amount is more than hundreds of thousand,
	* extent calculation will cost more than 10ms and the cache will
	* be erased because of the filtering.
	*/
	SeriesData$1.prototype.getApproximateExtent = function(dim) {
		return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
	};
	/**
	* Calculate extent on a filtered data might be time consuming.
	* Approximate extent is only used for: calculate extent of filtered data outside.
	*/
	SeriesData$1.prototype.setApproximateExtent = function(extent, dim) {
		dim = this.getDimension(dim);
		this._approximateExtent[dim] = extent.slice();
	};
	SeriesData$1.prototype.getCalculationInfo = function(key$1) {
		return this._calculationInfo[key$1];
	};
	SeriesData$1.prototype.setCalculationInfo = function(key$1, value) {
		isObject(key$1) ? extend(this._calculationInfo, key$1) : this._calculationInfo[key$1] = value;
	};
	/**
	* @return Never be null/undefined. `number` will be converted to string. Because:
	* In most cases, name is used in display, where returning a string is more convenient.
	* In other cases, name is used in query (see `indexOfName`), where we can keep the
	* rule that name `2` equals to name `'2'`.
	*/
	SeriesData$1.prototype.getName = function(idx) {
		var rawIndex = this.getRawIndex(idx);
		var name = this._nameList[rawIndex];
		if (name == null && this._nameDimIdx != null) name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
		if (name == null) name = "";
		return name;
	};
	SeriesData$1.prototype._getCategory = function(dimIdx, idx) {
		var ordinal = this._store.get(dimIdx, idx);
		var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
		if (ordinalMeta) return ordinalMeta.categories[ordinal];
		return ordinal;
	};
	/**
	* @return Never null/undefined. `number` will be converted to string. Because:
	* In all cases having encountered at present, id is used in making diff comparison, which
	* are usually based on hash map. We can keep the rule that the internal id are always string
	* (treat `2` is the same as `'2'`) to make the related logic simple.
	*/
	SeriesData$1.prototype.getId = function(idx) {
		return getId(this, this.getRawIndex(idx));
	};
	SeriesData$1.prototype.count = function() {
		return this._store.count();
	};
	/**
	* Get value. Return NaN if idx is out of range.
	*
	* @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.
	*/
	SeriesData$1.prototype.get = function(dim, idx) {
		var store = this._store;
		var dimInfo = this._dimInfos[dim];
		if (dimInfo) return store.get(dimInfo.storeDimIndex, idx);
	};
	/**
	* @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.
	*/
	SeriesData$1.prototype.getByRawIndex = function(dim, rawIdx) {
		var store = this._store;
		var dimInfo = this._dimInfos[dim];
		if (dimInfo) return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
	};
	SeriesData$1.prototype.getIndices = function() {
		return this._store.getIndices();
	};
	SeriesData$1.prototype.getDataExtent = function(dim) {
		return this._store.getDataExtent(this._getStoreDimIndex(dim));
	};
	SeriesData$1.prototype.getSum = function(dim) {
		return this._store.getSum(this._getStoreDimIndex(dim));
	};
	SeriesData$1.prototype.getMedian = function(dim) {
		return this._store.getMedian(this._getStoreDimIndex(dim));
	};
	SeriesData$1.prototype.getValues = function(dimensions, idx) {
		var _this = this;
		var store = this._store;
		return isArray(dimensions) ? store.getValues(map(dimensions, function(dim) {
			return _this._getStoreDimIndex(dim);
		}), idx) : store.getValues(dimensions);
	};
	/**
	* If value is NaN. Including '-'
	* Only check the coord dimensions.
	*/
	SeriesData$1.prototype.hasValue = function(idx) {
		var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
		for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) return false;
		return true;
	};
	/**
	* Retrieve the index with given name
	*/
	SeriesData$1.prototype.indexOfName = function(name) {
		for (var i = 0, len = this._store.count(); i < len; i++) if (this.getName(i) === name) return i;
		return -1;
	};
	SeriesData$1.prototype.getRawIndex = function(idx) {
		return this._store.getRawIndex(idx);
	};
	SeriesData$1.prototype.indexOfRawIndex = function(rawIndex) {
		return this._store.indexOfRawIndex(rawIndex);
	};
	/**
	* Only support the dimension which inverted index created.
	* Do not support other cases until required.
	* @param dim concrete dim
	* @param value ordinal index
	* @return rawIndex
	*/
	SeriesData$1.prototype.rawIndexOf = function(dim, value) {
		var invertedIndices = dim && this._invertedIndicesMap[dim];
		if (!invertedIndices) throw new Error("Do not supported yet");
		var rawIndex = invertedIndices && invertedIndices[value];
		if (rawIndex == null || isNaN(rawIndex)) return INDEX_NOT_FOUND;
		return rawIndex;
	};
	SeriesData$1.prototype.each = function(dims, cb, ctx) {
		if (isFunction(dims)) {
			ctx = cb;
			cb = dims;
			dims = [];
		}
		var fCtx = ctx || this;
		var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
		this._store.each(dimIndices, fCtx ? bind(cb, fCtx) : cb);
	};
	SeriesData$1.prototype.filterSelf = function(dims, cb, ctx) {
		if (isFunction(dims)) {
			ctx = cb;
			cb = dims;
			dims = [];
		}
		var fCtx = ctx || this;
		var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
		this._store = this._store.filter(dimIndices, fCtx ? bind(cb, fCtx) : cb);
		return this;
	};
	/**
	* Select data in range. (For optimization of filter)
	* (Manually inline code, support 5 million data filtering in data zoom.)
	*/
	SeriesData$1.prototype.selectRange = function(range) {
		var _this = this;
		var innerRange = {};
		var dims = keys(range);
		var dimIndices = [];
		each(dims, function(dim) {
			var dimIdx = _this._getStoreDimIndex(dim);
			innerRange[dimIdx] = range[dim];
			dimIndices.push(dimIdx);
		});
		this._store = this._store.selectRange(innerRange);
		return this;
	};
	SeriesData$1.prototype.mapArray = function(dims, cb, ctx) {
		if (isFunction(dims)) {
			ctx = cb;
			cb = dims;
			dims = [];
		}
		ctx = ctx || this;
		var result = [];
		this.each(dims, function() {
			result.push(cb && cb.apply(this, arguments));
		}, ctx);
		return result;
	};
	SeriesData$1.prototype.map = function(dims, cb, ctx, ctxCompat) {
		var fCtx = ctx || ctxCompat || this;
		var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
		var list = cloneListForMapAndSample(this);
		list._store = this._store.map(dimIndices, fCtx ? bind(cb, fCtx) : cb);
		return list;
	};
	SeriesData$1.prototype.modify = function(dims, cb, ctx, ctxCompat) {
		var _this = this;
		var fCtx = ctx || ctxCompat || this;
		each(normalizeDimensions(dims), function(dim) {
			if (!_this.getDimensionInfo(dim).isCalculationCoord) console.error("Danger: only stack dimension can be modified");
		});
		var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
		this._store.modify(dimIndices, fCtx ? bind(cb, fCtx) : cb);
	};
	/**
	* Large data down sampling on given dimension
	* @param sampleIndex Sample index for name and id
	*/
	SeriesData$1.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
		var list = cloneListForMapAndSample(this);
		list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
		return list;
	};
	/**
	* Large data down sampling using min-max
	* @param {string} valueDimension
	* @param {number} rate
	*/
	SeriesData$1.prototype.minmaxDownSample = function(valueDimension, rate) {
		var list = cloneListForMapAndSample(this);
		list._store = this._store.minmaxDownSample(this._getStoreDimIndex(valueDimension), rate);
		return list;
	};
	/**
	* Large data down sampling using largest-triangle-three-buckets
	* @param {string} valueDimension
	* @param {number} targetCount
	*/
	SeriesData$1.prototype.lttbDownSample = function(valueDimension, rate) {
		var list = cloneListForMapAndSample(this);
		list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
		return list;
	};
	SeriesData$1.prototype.getRawDataItem = function(idx) {
		return this._store.getRawDataItem(idx);
	};
	/**
	* Get model of one data item.
	*/
	SeriesData$1.prototype.getItemModel = function(idx) {
		var hostModel = this.hostModel;
		return new Model_default(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
	};
	/**
	* Create a data differ
	*/
	SeriesData$1.prototype.diff = function(otherList) {
		var thisList = this;
		return new DataDiffer_default(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
			return getId(otherList, idx);
		}, function(idx) {
			return getId(thisList, idx);
		});
	};
	/**
	* Get visual property.
	*/
	SeriesData$1.prototype.getVisual = function(key$1) {
		var visual = this._visual;
		return visual && visual[key$1];
	};
	SeriesData$1.prototype.setVisual = function(kvObj, val) {
		this._visual = this._visual || {};
		if (isObject(kvObj)) extend(this._visual, kvObj);
		else this._visual[kvObj] = val;
	};
	/**
	* Get visual property of single data item
	*/
	SeriesData$1.prototype.getItemVisual = function(idx, key$1) {
		var itemVisual = this._itemVisuals[idx];
		var val = itemVisual && itemVisual[key$1];
		if (val == null) return this.getVisual(key$1);
		return val;
	};
	/**
	* If exists visual property of single data item
	*/
	SeriesData$1.prototype.hasItemVisual = function() {
		return this._itemVisuals.length > 0;
	};
	/**
	* Make sure itemVisual property is unique
	*/
	SeriesData$1.prototype.ensureUniqueItemVisual = function(idx, key$1) {
		var itemVisuals = this._itemVisuals;
		var itemVisual = itemVisuals[idx];
		if (!itemVisual) itemVisual = itemVisuals[idx] = {};
		var val = itemVisual[key$1];
		if (val == null) {
			val = this.getVisual(key$1);
			if (isArray(val)) val = val.slice();
			else if (isObject(val)) val = extend({}, val);
			itemVisual[key$1] = val;
		}
		return val;
	};
	SeriesData$1.prototype.setItemVisual = function(idx, key$1, value) {
		var itemVisual = this._itemVisuals[idx] || {};
		this._itemVisuals[idx] = itemVisual;
		if (isObject(key$1)) extend(itemVisual, key$1);
		else itemVisual[key$1] = value;
	};
	/**
	* Clear itemVisuals and list visual.
	*/
	SeriesData$1.prototype.clearAllVisual = function() {
		this._visual = {};
		this._itemVisuals = [];
	};
	SeriesData$1.prototype.setLayout = function(key$1, val) {
		isObject(key$1) ? extend(this._layout, key$1) : this._layout[key$1] = val;
	};
	/**
	* Get layout property.
	*/
	SeriesData$1.prototype.getLayout = function(key$1) {
		return this._layout[key$1];
	};
	/**
	* Get layout of single data item
	*/
	SeriesData$1.prototype.getItemLayout = function(idx) {
		return this._itemLayouts[idx];
	};
	/**
	* Set layout of single data item
	*/
	SeriesData$1.prototype.setItemLayout = function(idx, layout$1, merge$1) {
		this._itemLayouts[idx] = merge$1 ? extend(this._itemLayouts[idx] || {}, layout$1) : layout$1;
	};
	/**
	* Clear all layout of single data item
	*/
	SeriesData$1.prototype.clearItemLayouts = function() {
		this._itemLayouts.length = 0;
	};
	/**
	* Set graphic element relative to data. It can be set as null
	*/
	SeriesData$1.prototype.setItemGraphicEl = function(idx, el) {
		setCommonECData(this.hostModel && this.hostModel.seriesIndex, this.dataType, idx, el);
		this._graphicEls[idx] = el;
	};
	SeriesData$1.prototype.getItemGraphicEl = function(idx) {
		return this._graphicEls[idx];
	};
	SeriesData$1.prototype.eachItemGraphicEl = function(cb, context) {
		each(this._graphicEls, function(el, idx) {
			if (el) cb && cb.call(context, el, idx);
		});
	};
	/**
	* Shallow clone a new list except visual and layout properties, and graph elements.
	* New list only change the indices.
	*/
	SeriesData$1.prototype.cloneShallow = function(list) {
		if (!list) list = new SeriesData$1(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);
		transferProperties(list, this);
		list._store = this._store;
		return list;
	};
	/**
	* Wrap some method to add more feature
	*/
	SeriesData$1.prototype.wrapMethod = function(methodName, injectFunction) {
		var originalMethod = this[methodName];
		if (!isFunction(originalMethod)) return;
		this.__wrappedMethods = this.__wrappedMethods || [];
		this.__wrappedMethods.push(methodName);
		this[methodName] = function() {
			var res = originalMethod.apply(this, arguments);
			return injectFunction.apply(this, [res].concat(slice(arguments)));
		};
	};
	SeriesData$1.internalField = function() {
		prepareInvertedIndex = function(data) {
			var invertedIndicesMap = data._invertedIndicesMap;
			each(invertedIndicesMap, function(invertedIndices, dim) {
				var dimInfo = data._dimInfos[dim];
				var ordinalMeta = dimInfo.ordinalMeta;
				var store = data._store;
				if (ordinalMeta) {
					invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
					for (var i = 0; i < invertedIndices.length; i++) invertedIndices[i] = INDEX_NOT_FOUND;
					for (var i = 0; i < store.count(); i++) invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
				}
			});
		};
		getIdNameFromStore = function(data, dimIdx, idx) {
			return convertOptionIdName(data._getCategory(dimIdx, idx), null);
		};
		/**
		* @see the comment of `List['getId']`.
		*/
		getId = function(data, rawIndex) {
			var id = data._idList[rawIndex];
			if (id == null && data._idDimIdx != null) id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
			if (id == null) id = ID_PREFIX + rawIndex;
			return id;
		};
		normalizeDimensions = function(dimensions) {
			if (!isArray(dimensions)) dimensions = dimensions != null ? [dimensions] : [];
			return dimensions;
		};
		/**
		* Data in excludeDimensions is copied, otherwise transferred.
		*/
		cloneListForMapAndSample = function(original) {
			var list = new SeriesData$1(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel);
			transferProperties(list, original);
			return list;
		};
		transferProperties = function(target, source) {
			each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
				if (source.hasOwnProperty(propName)) target[propName] = source[propName];
			});
			target.__wrappedMethods = source.__wrappedMethods;
			each(CLONE_PROPERTIES, function(propName) {
				target[propName] = clone(source[propName]);
			});
			target._calculationInfo = extend({}, source._calculationInfo);
		};
		makeIdFromName = function(data, idx) {
			var nameList = data._nameList;
			var idList = data._idList;
			var nameDimIdx = data._nameDimIdx;
			var idDimIdx = data._idDimIdx;
			var name = nameList[idx];
			var id = idList[idx];
			if (name == null && nameDimIdx != null) nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
			if (id == null && idDimIdx != null) idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
			if (id == null && name != null) {
				var nameRepeatCount = data._nameRepeatCount;
				var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
				id = name;
				if (nmCnt > 1) id += "__ec__" + nmCnt;
				idList[idx] = id;
			}
		};
	}();
	return SeriesData$1;
}();
var SeriesData_default = SeriesData;

//#endregion
export { SourceManager as $, parseDate as $i, getFont as $n, createFromString as $r, SOURCE_FORMAT_ARRAY_ROWS as $t, registerPreprocessor as A, isNameSpecified as Ai, registerLayOutOnCoordSysUsage as An, subPixelOptimizeLine as Ar, shouldShowAllLabels as At, findEventDispatcher as B, asc as Bi, toCamelCase as Bn, IncrementalDisplayable_default as Br, getStackedDimension as Bt, registerCoordinateSystem as C, compressBatches as Ci, mergeLayoutParam as Cn, makePath as Cr, getDataDimensionsOnAxis as Ct, registerMap as D, getTooltipRenderMode as Di, CoordinateSystem_default as Dn, retrieveZInfo as Dr, niceScaleExtent as Dt, registerLoading as E, getDataItemValue as Ei, CoordinateSystemUsageKind as En, resizePath as Er, isNameLocationCenter as Et, registerVisual as F, parseFinder as Fi, formatTime as Fn, initProps as Fr, getLayoutOnAxis as Ft, Chart_default as G, getPrecisionSafe as Gi, getScaleBreakHelper as Gn, BezierCurve_default as Gr, shouldOmitUnusedDimensions as Gt, getItemVisualFromData as H, getPercentWithPrecision as Hi, getTextRect as Hn, RadialGradient_default as Hr, SeriesDataSchema as Ht, setCanvasCreator as I, preParseFinder as Ii, formatTpl as In, removeElement as Ir, layout as It, TooltipMarkupStyleCreator as J, linearMap as Ji, Model_default as Jn, Polygon_default as Jr, BE_ORDINAL as Jt, Series_default as K, isNumeric as Ki, getLocaleModel as Kn, Line_default as Kr, createSourceFromSeriesDataOption as Kt, version as L, queryDataIndex as Li, formatTplSimple as Ln, removeElementWithFadeOut as Lr, createFloat32Array as Lt, registerTheme as M, makeInternalComponentId as Mi, addCommas as Mn, traverseElements as Mr, ensureScaleRawExtentInfo as Mt, registerTransform as N, mappingToExists as Ni, capitalFirst as Nn, traverseUpdateZ as Nr, Time_default as Nt, registerPostInit as O, groupData as Oi, decideCoordSysUsageKind as On, setTooltipConfig as Or, retrieveAxisBreaksOption as Ot, registerUpdateLifecycle as P, normalizeToArray as Pi, convertToColorString as Pn, getAnimationConfig as Pr, createProgressiveLayout as Pt, retrieveVisualColorForTooltipMarker as Q, numericToNumber as Qi, createTextStyle as Qn, Circle_default as Qr, SERIES_LAYOUT_BY_COLUMN as Qt, getCustomSeries as R, queryReferringComponents as Ri, getTooltipMarker as Rn, saveOldStyle as Rr, createRenderPlanner as Rt, registerAction as S, clearTmpModel as Si, getLayoutRect as Sn, makeImage as Sr, getAxisRawValue as St, registerLayout as T, defaultEmphasis as Ti, sizeCalculable as Tn, registerShape as Tr, ifAxisCrossZero as Tt, getVisualFromData as U, getPixelPrecision as Ui, format as Un, LinearGradient_default as Ur, createDimNameMap as Ut, createLegacyDataSelectAction as V, getPercentSeats as Vi, windowOpen as Vn, OrientedBoundingRect_default as Vr, isDimensionStacked as Vt, setItemVisualFromData as W, getPrecision as Wi, roundTime as Wn, Arc_default as Wr, ensureSourceDimNameMap as Wt, createTooltipMarkup as X, mathMin as Xi, animateLabelValue as Xn, Sector_default as Xr, makeSeriesEncodeForAxisCoordSys as Xt, buildTooltipMarkup as Y, mathMax as Yi, LabelMarginType as Yn, Ring_default as Yr, guessOrdinal as Yt, getPaddingFromTooltipModel as Z, nice as Zi, createTextConfig as Zn, Ellipse_default as Zr, makeSeriesEncodeForNameBased as Zt, getCoordinateSystemDimensions as _, throwError as _a, getECData as _i, createBoxLayoutReference as _n, getTransform as _r, symbolBuildProxies as _t, parseGeoJSON as a, reformIntervals as aa, enableHoverEmphasis as ai, increaseInterval as an, XY as ar, parseDataValue as at, getMap as b, MULTIPLE_REFERRING as bi, getCircleLayout as bn, isBoundingRectAxisAligned as br, createAxisLabelsComputingContext as bt, contain as c, makeStyleMapper as ca, enterEmphasis as ci, logTransform as cn, clipPointsByRect as cr, retrieveRawValue as ct, connect as d, inheritDefaultOption as da, leaveEmphasis as di, tokens_default as dn, ensureCopyRect as dr, clear as dt, parsePercent as ea, DISPLAY_STATES as ei, SOURCE_FORMAT_OBJECT_ROWS as en, getLabelStatesModels as er, disableTransformOptionMerge as et, dataTool as f, deprecateLog as fa, setAsHighDownDispatcher as fi, Component_default$1 as fn, ensureCopyTransform as fr, createOrUpdate as ft, dispose as g, makePrintable as ga, toggleHoverEmphasis as gi, copyLayoutParams as gn, getShapeClass as gr, normalizeSymbolSize as gt, disconnect as h, log as ha, setStatesStylesFromModel as hi, box as hn, extendShape as hr, normalizeSymbolOffset as ht, DataDiffer_default as i, quantityExponent as ia, enableComponentHighDownFeatures as ii, Ordinal_default as in, WH as ir, getRawValueParser as it, registerProcessor as j, makeInner as ji, simpleCoordSysInjectionProvider as jn, transformDirection as jr, unionAxisExtentFromData as jt, registerPostUpdate as k, interpolateRawValues as ki, injectCoordSysByOption as kn, subPixelOptimize as kr, shouldAxisShow as kt, use as l, Component_default as la, isHighDownDispatcher as li, OrdinalMeta_default as ln, clipRectByRect as lr, getDecalFromPalette as lt, disConnect as m, error as ma, setStatesFlag as mi, applyPreserveAspect as mn, extendPath as mr, createSymbol as mt, SeriesDimensionDefine_default as n, quantile as na, SPECIAL_STATES as ni, VISUAL_DIMENSIONS as nn, setLabelStyle as nr, SortOrderComparator as nt, GeoJSONRegion as o, remRadian as oa, enableHoverFocus as oi, isIntervalOrLogScale as on, applyTransform as or, DataFormatMixin as ot, dependencies as p, deprecateReplaceLog as pa, setDefaultStateProxy as pi, LOCATION_PARAMS as pn, expandOrShrinkRect as pr, throttle as pt, defaultSeriesFormatTooltip as q, isRadianAroundZero as qi, registerLocale as qn, Polyline_default as qr, isSourceInstance as qt, getDimensionTypeByAxis as r, quantity as ra, Z2_EMPHASIS_LIFT as ri, Interval_default as rn, setLabelValueAnimation as rr, createFilterComparator as rt, GeoSVGRegion as s, round as sa, enterBlur as si, isValueNice as sn, calcZ2Range as sr, normalizeTooltipFormatResult as st, SeriesData_default as t, parsePositionSizeOption as ta, HOVER_STATE_BLUR as ti, SOURCE_FORMAT_ORIGINAL as tn, labelInner as tr, CtorInt32Array$1 as tt, PRIORITY as u, getUID as ua, leaveBlur as ui, AxisModelCommonMixin as un, createIcon as ur, registerInternalOptionCreator as ut, getInstanceByDom as v, warn as va, setCommonECData as vi, fetchLayoutMode as vn, graphic_exports as vr, Axis_default as vt, registerCustomSeries$1 as w, convertOptionIdName as wi, positionElement as wn, mergePath as wr, getScaleExtent as wt, init as x, SINGLE_REFERRING as xi, getLayoutParams as xn, linePolygonIntersect as xr, createScaleByModel as xt, getInstanceById as y, ListIterator as yi, getBoxLayoutParams as yn, groupTransition as yr, AxisTickLabelComputingKind as yt, createOrUpdatePatternFromDecal as z, MAX_SAFE_INTEGER as zi, normalizeCssArray as zn, updateProps as zr, enableDataStack as zt };
//# sourceMappingURL=SeriesData-CgMBLtkn.js.map