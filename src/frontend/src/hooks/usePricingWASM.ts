import { useState, useEffect, useCallback } from 'react';
// @ts-ignore - WASM module will be generated by wasm-pack
import init, { BlackScholesWASM, Greeks } from '../wasm/bsopt_wasm';

/**
 * Hook to utilize high-performance WebAssembly for client-side pricing.
 * Allows for "What-If" analysis and real-time Greek updates without server roundtrips.
 */
export const usePricingWASM = () => {
  const [engine, setEngine] = useState<BlackScholesWASM | null>(null);
  const [isReady, setIsReady] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let mounted = true;

    const loadWasm = async () => {
      try {
        // In a real environment, this would point to the built WASM
        // For now, we'll try to initialize if the module is found
        await init();
        if (mounted) {
          const bsEngine = new BlackScholesWASM();
          setEngine(bsEngine);
          setIsReady(true);
        }
      } catch (e) {
        if (mounted) {
          setError('Failed to load WASM pricing engine');
          console.error('WASM Load Error:', e);
        }
      }
    };

    loadWasm();
    return () => { mounted = false; };
  }, []);

  const calculatePrice = useCallback((
    spot: number,
    strike: number,
    time: number,
    vol: number,
    rate: number,
    div: number,
    isCall: boolean
  ) => {
    if (!engine) return null;
    return isCall 
      ? engine.price_call(spot, strike, time, vol, rate, div)
      : engine.price_put(spot, strike, time, vol, rate, div);
  }, [engine]);

  const calculateGreeks = useCallback((
    spot: number,
    strike: number,
    time: number,
    vol: number,
    rate: number,
    div: number
  ): Greeks | null => {
    if (!engine) return null;
    return engine.calculate_greeks(spot, strike, time, vol, rate, div);
  }, [engine]);

  const solveIV = useCallback((
    price: number,
    spot: number,
    strike: number,
    time: number,
    rate: number,
    div: number,
    isCall: boolean
  ) => {
    if (!engine) return null;
    return engine.solve_iv(price, spot, strike, time, rate, div, isCall);
  }, [engine]);

  const calculateBatch = useCallback((
    params: Float64Array
  ): Float64Array | null => {
    if (!engine) return null;
    return engine.batch_calculate_compact(params);
  }, [engine]);

  return {
    isReady,
    error,
    calculatePrice,
    calculateGreeks,
    solveIV,
    calculateBatch
  };
};
